<!DOCTYPE html >
<html>
        <head>
          <title>concurrent - ScalaTest 3.0.3 - org.scalatest.concurrent</title>
          <meta name="description" content="concurrent - ScalaTest 3.0.3 - org.scalatest.concurrent" />
          <meta name="keywords" content="concurrent ScalaTest 3.0.3 org.scalatest.concurrent" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'org.scalatest.concurrent.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NJWCS90VG5"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-NJWCS90VG5');

</script>
        </head>
        <body class="value">

<!-- Top of doc.scalatest.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/4ca150665e51d0b1c3890ca1b891c507-ads.js?product=ScalaTest"></script>

      <div id="definition">
        <img alt="Package" src="../../../lib/package_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="org">org</a>.<a href="../package.html" class="extype" name="org.scalatest">scalatest</a></p>
        <h1>concurrent</h1><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">concurrent</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.
</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/scalatest/scalatest/tree/release-3.0.3/scalatest//src/main/scala/org/scalatest/concurrent/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By Inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="org.scalatest.concurrent"><span>concurrent</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show All</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.scalatest.concurrent.AbstractPatienceConfiguration" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AbstractPatienceConfigurationextendsScaledTimeSpans"></a>
      <a id="AbstractPatienceConfiguration:AbstractPatienceConfiguration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AbstractPatienceConfiguration.html"><span class="name">AbstractPatienceConfiguration</span></a><span class="result"> extends <a href="ScaledTimeSpans.html" class="extype" name="org.scalatest.concurrent.ScaledTimeSpans">ScaledTimeSpans</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@AbstractPatienceConfigurationextendsScaledTimeSpans" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that defines an abstract <code>patienceConfig</code> method that is implemented in <a href="PatienceConfiguration.html"><code>PatienceConfiguration</code></a> and can
be overriden in stackable modification traits such as <a href="IntegrationPatience.html"><code>IntegrationPatience</code></a>.</a></a></code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that defines an abstract <code>patienceConfig</code> method that is implemented in <a href="PatienceConfiguration.html"><code>PatienceConfiguration</code></a> and can
be overriden in stackable modification traits such as <a href="IntegrationPatience.html"><code>IntegrationPatience</code></a>.</p><p>The main purpose of <code>AbstractPatienceConfiguration</code> is to differentiate core <code>PatienceConfiguration</code>
traits, such as <a href="Eventually.html"><code>Eventually</code></a> and <a href="Waiters.html"><code>Waiters</code></a>, from stackable
modification traits for <code>PatienceConfiguration</code>s such as <code>IntegrationPatience</code>.
Because these stackable traits extend <code>AbstractPatienceConfiguration</code>
instead of <a href="../Suite.html"><code>Suite</code></a>, you can't simply mix in a stackable trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">IntegrationPatience</span> <span class="stLineComment">// Won't compile</span>
</pre></p><p>The previous code is undesirable because <code>IntegrationPatience</code> would have no affect on the class. Instead, you need to mix
in a core <code>PatienceConfiguration</code> trait and mix the stackable <code>IntegrationPatience</code> trait
into that, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Eventually</span> <span class="stReserved">with</span> <span class="stType">IntegrationPatience</span> <span class="stLineComment">// Compiles fine</span>
</pre></p><p>The previous code is better because <code>IntegrationPatience</code> does have an effect: it modifies the behavior
of <code>Eventually</code>.</p></div></div>
    </li><li name="org.scalatest.concurrent.AsyncCancelAfterFailure" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncCancelAfterFailureextendsAsyncTestSuiteMixin"></a>
      <a id="AsyncCancelAfterFailure:AsyncCancelAfterFailure"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncCancelAfterFailure.html"><span class="name">AsyncCancelAfterFailure</span></a><span class="result"> extends <a href="../AsyncTestSuiteMixin.html" class="extype" name="org.scalatest.AsyncTestSuiteMixin">AsyncTestSuiteMixin</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@AsyncCancelAfterFailureextendsAsyncTestSuiteMixin" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <a href="../AsyncTestSuite.html"><code>AsyncTestSuite</code></a> cancels any remaining tests in that
<code>AsyncTestSuite</code> instance after a test fails.</code></a></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="../AsyncTestSuite.html"><code>AsyncTestSuite</code></a> cancels any remaining tests in that
<code>AsyncTestSuite</code> instance after a test fails.</p><p>The intended use case for this trait is if you have a suite of long-running tests that are
related such that if one fails, you aren't interested in running the others, you can use this
trait to simply cancel any remaining tests, so you need not wait long for them to complete.</p></div></div>
    </li><li name="org.scalatest.concurrent.AsyncTimeLimitedTests" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTimeLimitedTestsextendsAsyncTestSuiteMixinwithTimeLimits"></a>
      <a id="AsyncTimeLimitedTests:AsyncTimeLimitedTests"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncTimeLimitedTests.html"><span class="name">AsyncTimeLimitedTests</span></a><span class="result"> extends <a href="../AsyncTestSuiteMixin.html" class="extype" name="org.scalatest.AsyncTestSuiteMixin">AsyncTestSuiteMixin</a> with <a href="TimeLimits.html" class="extype" name="org.scalatest.concurrent.TimeLimits">TimeLimits</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@AsyncTimeLimitedTestsextendsAsyncTestSuiteMixinwithTimeLimits" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into an asynchronous suite class establishes a time limit for its tests.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into an asynchronous suite class establishes a time limit for its tests.</p><p>This trait overrides <code>withFixture</code>, wrapping a <code>super.withFixture(test)</code> call
in a <code>failAfter</code> invocation, specifying a timeout obtained by invoking <code>timeLimit</code>:</p><p><pre class="stHighlighted">
failAfter(timeLimit) {
  <span class="stReserved">super</span>.withFixture(test)
}
</pre></p><p>Note that the <code>failAfter</code> method executes the body of the by-name passed to it using the same
thread that invoked <code>failAfter</code>. This means that the calling of <code>withFixture</code> method
will be run using the same thread, but the test body may be run using a different thread, depending on the
<code>executionContext</code> set at the <code>AsyncTestSuite</code> level.</p><p>The <code>timeLimit</code> field is abstract in this trait. Thus you must specify a time limit when you use it.
For example, the following code specifies that each test must complete within 200 milliseconds:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> org.scalatest.concurrent.AsyncTimeLimitedTests
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncTimeLimitedTests</span> {
<br/>  <span class="stLineComment">// Note: You may need to either write 200.millis or (200 millis), or</span>
  <span class="stLineComment">// place a semicolon or blank line after plain old 200 millis, to</span>
  <span class="stLineComment">// avoid the semicolon inference problems of postfix operator notation.</span>
  <span class="stReserved">val</span> timeLimit = <span class="stLiteral">200</span> millis
<br/>  describe(<span class="stQuotedString">"An asynchronous time-limited test"</span>) {
    it(<span class="stQuotedString">"should succeed if it completes within the time limit"</span>) {
      Thread.sleep(<span class="stLiteral">100</span>)
      succeed
    }
    it(<span class="stQuotedString">"should fail if it is taking too darn long"</span>) {
      Thread.sleep(<span class="stLiteral">300</span>)
      succeed
    }
  }
}
</pre></p><p>If you run the above <code>ExampleSpec</code>, the second test will fail with the error message:</p><p><code>The test did not complete within the specified 200 millisecond time limit.</code></p><p>Different from <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>, <code>AsyncTimeLimitedTests</code> does not
support <code>Interruptor</code> for now.</p></div></div>
    </li><li name="org.scalatest.concurrent.ConductorFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ConductorFixtureextendsTestSuiteMixinwithConductors"></a>
      <a id="ConductorFixture:ConductorFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ConductorFixture.html"><span class="name">ConductorFixture</span></a><span class="result"> extends <a href="../TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a> with <a href="Conductors.html" class="extype" name="org.scalatest.concurrent.Conductors">Conductors</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ConductorFixtureextendsTestSuiteMixinwithConductors" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that can pass a new <code>Conductor</code> fixture into tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that can pass a new <code>Conductor</code> fixture into tests.</p><p>Here's an example of the use of this trait to test the <code>ArrayBlockingQueue</code>
class from <code>java.util.concurrent</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> org.scalatest.concurrent.ConductorFixture
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> java.util.concurrent.ArrayBlockingQueue
<br/><span class="stReserved">class</span> <span class="stType">ArrayBlockingQueueSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSuite</span> <span class="stReserved">with</span> <span class="stType">ConductorFixture</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  test(<span class="stQuotedString">"calling put on a full queue blocks the producer thread"</span>) { conductor =&gt; <span class="stReserved">import</span> conductor._
<br/>    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>    thread(<span class="stQuotedString">"producer"</span>) {
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
      beat should be (<span class="stLiteral">1</span>)
    }
<br/>    thread(<span class="stQuotedString">"consumer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
    }
<br/>    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"calling take on an empty queue blocks the consumer thread"</span>) { conductor =&gt; <span class="stReserved">import</span> conductor._
<br/>    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>    thread(<span class="stQuotedString">"producer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
    }
<br/>    thread(<span class="stQuotedString">"consumer"</span>) {
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
      beat should be (<span class="stLiteral">1</span>)
    }
<br/>    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
}
</pre></p><p>For an explanation of how these tests work, see the documentation for <a href="Conductors.html"><code>Conductors</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.ConductorMethods" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ConductorMethodsextendsTestSuiteMixinwithConductors"></a>
      <a id="ConductorMethods:ConductorMethods"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ConductorMethods.html"><span class="name">ConductorMethods</span></a><span class="result"> extends <a href="../TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a> with <a href="Conductors.html" class="extype" name="org.scalatest.concurrent.Conductors">Conductors</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ConductorMethodsextendsTestSuiteMixinwithConductors" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that provides each test with access to a new <code>Conductor</code>
via methods.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides each test with access to a new <code>Conductor</code>
via methods.</p><p>Here's an example of the use of this trait to test the <code>ArrayBlockingQueue</code>
concurrency abstraction from <code>java.util.concurrent</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> org.scalatest.concurrent.ConductorMethods
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> java.util.concurrent.ArrayBlockingQueue
<br/><span class="stReserved">class</span> <span class="stType">ArrayBlockingQueueSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">ConductorMethods</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  test(<span class="stQuotedString">"calling put on a full queue blocks the producer thread"</span>) {
<br/>    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>    thread(<span class="stQuotedString">"producer"</span>) {
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
      beat should be (<span class="stLiteral">1</span>)
    }
<br/>    thread(<span class="stQuotedString">"consumer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
    }
<br/>    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"calling take on an empty queue blocks the consumer thread"</span>) {
<br/>    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>    thread(<span class="stQuotedString">"producer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
    }
<br/>    thread(<span class="stQuotedString">"consumer"</span>) {
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
      beat should be (<span class="stLiteral">1</span>)
    }
<br/>    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
}
</pre></p><p>For an explanation of how these tests work, see the documentation for <a href="Conductors.html"><code>Conductors</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.Conductors" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ConductorsextendsPatienceConfiguration"></a>
      <a id="Conductors:Conductors"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Conductors.html"><span class="name">Conductors</span></a><span class="result"> extends <a href="PatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration">PatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ConductorsextendsPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait whose <code>Conductor</code> member facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait whose <code>Conductor</code> member facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.</p><p>A <code>Conductor</code> conducts a multi-threaded scenario by maintaining
a clock of &quot;beats.&quot; Beats are numbered starting with 0. You can ask a
<code>Conductor</code> to run threads that interact with the class, trait,
or library (the <em>subject</em>)
you want to test. A thread can call the <code>Conductor</code>'s
<code>waitForBeat</code> method, which will cause the thread to block
until that beat has been reached. The <code>Conductor</code> will advance
the beat only when all threads participating in the test are blocked. By
tying the timing of thread activities to specific beats, you can write
tests for concurrent systems that have deterministic interleavings of
threads.</p><p>A <code>Conductor</code> object has a three-phase lifecycle. It begins its life
in the <em>setup</em> phase. During this phase, you can start threads by
invoking the <code>thread</code> method on the <code>Conductor</code>.
When <code>conduct</code> is invoked on a <code>Conductor</code>, it enters
the <em>conducting</em> phase. During this phase it conducts the one multi-threaded
scenario it was designed to conduct. After all participating threads have exited, either by
returning normally or throwing an exception, the <code>conduct</code> method
will complete, either by returning normally or throwing an exception. As soon as
the <code>conduct</code> method completes, the <code>Conductor</code>
enters its <em>defunct</em> phase. Once the <code>Conductor</code> has conducted
a multi-threaded scenario, it is defunct and can't be reused. To run the same test again,
you'll need to create a new instance of <code>Conductor</code>.</p><p>Here's an example of the use of <code>Conductor</code> to test the <code>ArrayBlockingQueue</code>
class from <code>java.util.concurrent</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.fixture.FunSuite
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> java.util.concurrent.ArrayBlockingQueue
<span class="stReserved">import</span> org.scalatest.concurrent.Conductors
<br/><span class="stReserved">class</span> <span class="stType">ArrayBlockingQueueSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> <span class="stReserved">with</span> <span class="stType">Conductors</span> {
<br/>  test(<span class="stQuotedString">"calling put on a full queue blocks the producer thread"</span>) {
<br/>    <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
    <span class="stReserved">import</span> conductor._
<br/>    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>    thread(<span class="stQuotedString">"producer"</span>) {
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
      beat should be (<span class="stLiteral">1</span>)
    }
<br/>    thread(<span class="stQuotedString">"consumer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
    }
<br/>    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
}
</pre></p><p>When the test shown is run, it will create one thread named <em>producer</em> and another named
<em>consumer</em>. The producer thread will eventually execute the code passed as a by-name
parameter to <code>thread("producer")</code>:</p><p><pre class="stHighlighted">
buf put <span class="stLiteral">42</span>
buf put <span class="stLiteral">17</span>
beat should be (<span class="stLiteral">1</span>)
</pre></p><p>Similarly, the consumer thread will eventually execute the code passed as a by-name parameter
to <code>thread("consumer")</code>:</p><p><pre class="stHighlighted">
waitForBeat(<span class="stLiteral">1</span>)
buf.take should be (<span class="stLiteral">42</span>)
buf.take should be (<span class="stLiteral">17</span>)
</pre></p><p>The <code>thread</code> creates the threads and starts them, but they will not immediately
execute the by-name parameter passed to them. They will first block, waiting for the <code>Conductor</code>
to give them a green light to proceed.</p><p>The next call in the test is <code>whenFinished</code>. This method will first call <code>conduct</code> on
the <code>Conductor</code>, which will wait until all threads that were created (in this case, producer and consumer) are
at the &quot;starting line&quot;, <em>i.e.</em>, they have all started and are blocked, waiting on the green light.
The <code>conduct</code> method will then give these threads the green light and they will
all start executing their blocks concurrently.</p><p>When the threads are given the green light, the beat is 0. The first thing the producer thread does is put 42 in
into the queue. As the queue is empty at this point, this succeeds. The producer thread next attempts to put a 17
into the queue, but because the queue has size 1, this can't succeed until the consumer thread has read the 42
from the queue. This hasn't happened yet, so producer blocks. Meanwhile, the consumer thread's first act is to
call <code>waitForBeat(1)</code>. Because the beat starts out at 0, this call will block the consumer thread.
As a result, once the producer thread has executed <code>buf put 17</code> and the consumer thread has executed
<code>waitForBeat(1)</code>, both threads will be blocked.</p><p>The <code>Conductor</code> maintains a clock that wakes up periodically and checks to see if all threads
participating in the multi-threaded scenario (in this case, producer and consumer) are blocked. If so, it
increments the beat. Thus sometime later the beat will be incremented, from 0 to 1. Because consumer was
waiting for beat 1, it will wake up (<em>i.e.</em>, the <code>waitForBeat(1)</code> call will return) and
execute the next line of code in its block, <code>buf.take should be (42)</code>. This will succeed, because
the producer thread had previously (during beat 0) put 42 into the queue. This act will also make
producer runnable again, because it was blocked on the second <code>put</code>, which was waiting for another
thread to read that 42.</p><p>Now both threads are unblocked and able to execute their next statement. The order is
non-deterministic, and can even be simultaneous if running on multiple cores. If the <code>consumer</code> thread
happens to execute <code>buf.take should be (17)</code> first, it will block (<code>buf.take</code> will not return), because the queue is
at that point empty. At some point later, the producer thread will execute <code>buf put 17</code>, which will
unblock the consumer thread. Again both threads will be runnable and the order non-deterministic and
possibly simulataneous. The producer thread may charge ahead and run its next statement, <code>beat should be (1)</code>.
This will succeed because the beat is indeed 1 at this point. As this is the last statement in the producer's block,
the producer thread will exit normally (it won't throw an exception). At some point later the consumer thread will
be allowed to complete its last statement, the <code>buf.take</code> call will return 17. The consumer thread will
execute <code>17 should be (17)</code>. This will succeed and as this was the last statement in its block, the consumer will return
normally.</p><p>If either the producer or consumer thread had completed abruptbly with an exception, the <code>conduct</code> method
(which was called by <code>whenFinished</code>) would have completed abruptly with an exception to indicate the test
failed. However, since both threads returned normally, <code>conduct</code> will return. Because <code>conduct</code> doesn't
throw an exception, <code>whenFinished</code> will execute the block of code passed as a by-name parameter to it: <code>buf should be ('empty)</code>.
This will succeed, because the queue is indeed empty at this point. The <code>whenFinished</code> method will then return, and
because the <code>whenFinished</code> call was the last statement in the test and it didn't throw an exception, the test completes successfully.</p><p>This test tests <code>ArrayBlockingQueue</code>, to make sure it works as expected. If there were a bug in <code>ArrayBlockingQueue</code>
such as a <code>put</code> called on a full queue didn't block, but instead overwrote the previous value, this test would detect
it. However, if there were a bug in <code>ArrayBlockingQueue</code> such that a call to <code>take</code> called on an empty queue
never blocked and always returned 0, this test might not detect it. The reason is that whether the consumer thread will ever call
<code>take</code> on an empty queue during this test is non-deterministic. It depends on how the threads get scheduled during beat 1.
What is deterministic in this test, because the consumer thread blocks during beat 0, is that the producer thread will definitely
attempt to write to a full queue. To make sure the other scenario is tested, you'd need a different test:</p><p><pre class="stHighlighted">
test(<span class="stQuotedString">"calling take on an empty queue blocks the consumer thread"</span>) {
<br/>  <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
  <span class="stReserved">import</span> conductor._
<br/>  <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)
<br/>  thread(<span class="stQuotedString">"producer"</span>) {
    waitForBeat(<span class="stLiteral">1</span>)
    buf put <span class="stLiteral">42</span>
    buf put <span class="stLiteral">17</span>
  }
<br/>  thread(<span class="stQuotedString">"consumer"</span>) {
    buf.take should be (<span class="stLiteral">42</span>)
    buf.take should be (<span class="stLiteral">17</span>)
    beat should be (<span class="stLiteral">1</span>)
  }
<br/>  whenFinished {
    buf should be (<span class="stQuotedString">'empty</span>)
  }
}
</pre></p><p>In this test, the producer thread will block, waiting for beat 1. The consumer thread will invoke <code>buf.take</code>
as its first act. This will block, because the queue is empty. Because both threads are blocked, the <code>Conductor</code>
will at some point later increment the beat to 1. This will awaken the producer thread. It will return from its
<code>waitForBeat(1)</code> call and execute <code>buf put 42</code>. This will unblock the consumer thread, which will
take the 42, and so on.</p><p>The problem that <code>Conductor</code> is designed to address is the difficulty, caused by the non-deterministic nature
of thread scheduling, of testing classes, traits, and libraries that are intended to be used by multiple threads.
If you just create a test in which one thread reads from an <code>ArrayBlockingQueue</code> and
another writes to it, you can't be sure that you have tested all possible interleavings of threads, no matter
how many times you run the test. The purpose of <code>Conductor</code>
is to enable you to write tests with deterministic interleavings of threads. If you write one test for each possible
interleaving of threads, then you can be sure you have all the scenarios tested. The two tests shown here, for example,
ensure that both the scenario in which a producer thread tries to write to a full queue and the scenario in which a
consumer thread tries to take from an empty queue are tested.</p><p>Class <code>Conductor</code> was inspired by the
<a href="http://www.cs.umd.edu/projects/PL/multithreadedtc/">MultithreadedTC project</a>,
created by Bill Pugh and Nat Ayewah of the University of Maryland.</p><p>Although useful, bear in mind that a <code>Conductor</code>'s results are not guaranteed to be
accurate 100% of the time. The reason is that it uses <code>java.lang.Thread</code>'s <code>getState</code> method to
decide when to advance the beat. This use goes against the advice given in the Javadoc documentation for
<code>getState</code>, which says, &quot;This method is designed for use in monitoring of the system state, not for
synchronization.&quot; In short, sometimes the return value of <code>getState</code> occasionally may be inacurrate,
which in turn means that sometimes a <code>Conductor</code> could decide to advance the beat too early. In practice,
<code>Conductor</code> has proven to be very helpful when developing thread safe classes. It is also useful in
for regression tests, but you may have to tolerate occasional false negatives.</p></div></div>
    </li><li name="org.scalatest.concurrent.Eventually" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="EventuallyextendsPatienceConfiguration"></a>
      <a id="Eventually:Eventually"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Eventually.html"><span class="name">Eventually</span></a><span class="result"> extends <a href="PatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration">PatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@EventuallyextendsPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that provides the <code>eventually</code> construct, which periodically retries executing
a passed by-name parameter, until it either succeeds or the configured timeout has been surpassed.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides the <code>eventually</code> construct, which periodically retries executing
a passed by-name parameter, until it either succeeds or the configured timeout has been surpassed.</p><p>The by-name parameter &quot;succeeds&quot; if it returns a result. It &quot;fails&quot; if it throws any exception that
would normally cause a test to fail. (These are any exceptions except <a href="../exceptions/TestPendingException.html"><code>TestPendingException</code></a> and
<code>Error</code>s listed in the
<a href="../Suite.html#errorHandling">Treatment of <code>java.lang.Error</code>s</a> section of the
documentation of trait <code>Suite</code>.)</p><p>For example, the following invocation of <code>eventually</code> would succeed (not throw an exception):</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> xs = <span class="stLiteral">1</span> to <span class="stLiteral">125</span>
<span class="stReserved">val</span> it = xs.iterator
eventually { it.next should be (<span class="stLiteral">3</span>) }
</pre></p><p>However, because the default timeout is 150 milliseconds, the following invocation of
<code>eventually</code> would ultimately produce a <code>TestFailedDueToTimeoutException</code>:</p><p><a name="secondExample"></a>
<pre class="stHighlighted">
<span class="stReserved">val</span> xs = <span class="stLiteral">1</span> to <span class="stLiteral">125</span>
<span class="stReserved">val</span> it = xs.iterator
eventually { Thread.sleep(<span class="stLiteral">50</span>); it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>Assuming the default configuration parameters, a <code>timeout</code> of 150 milliseconds and an <code>interval</code> of 15 milliseconds,
were passed implicitly to <code>eventually</code>, the detail message of the thrown
<a href="../exceptions/TestFailedDueToTimeoutException.html"><code>TestFailedDueToTimeoutException</code></a> would look like:</p><p><code>The code passed to eventually never returned normally. Attempted 2 times over 166.682 milliseconds. Last failure message: 2 was not equal to 110.</code></p><p>The cause of the thrown <code>TestFailedDueToTimeoutException</code> will be the exception most recently thrown by the block of code passed to eventually. (In
the previous example, the cause would be the <code>TestFailedException</code> with the detail message <code>2 was not equal to 100</code>.)</p><p><a name="patienceConfig"></a></p><h4> Configuration of <code>eventually</code> </h4><p>The <code>eventually</code> methods of this trait can be flexibly configured.
The two configuration parameters for <code>eventually</code> along with their
default values and meanings are described in the following table:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Configuration Parameter</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Default Value</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Meaning</strong>
</th>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>timeout</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(150 milliseconds)</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the maximum amount of time to allow unsuccessful attempts before giving up and throwing <code>TestFailedDueToTimeoutException</code>
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>interval</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(15 milliseconds)</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the amount of time to sleep between each attempt
</td>
</tr>
</table></p><p>The default values of both timeout and interval are passed to the <code>scaled</code> method, inherited
from <code>ScaledTimeSpans</code>, so that the defaults can be scaled up
or down together with other scaled time spans. See the documentation for trait <a href="ScaledTimeSpans.html"><code>ScaledTimeSpans</code></a>
for more information.</p><p>The <code>eventually</code> methods of trait <code>Eventually</code> each take a <code>PatienceConfig</code>
object as an implicit parameter. This object provides values for the two configuration parameters. (These configuration parameters
are called &quot;patience&quot; because they determine how <em>patient</em> tests will be with asynchronous operations: how long
they will tolerate failures before giving up and how long they will wait before checking again after a failure.) Trait
<code>Eventually</code> provides an implicit <code>val</code> named <code>patienceConfig</code> with each
configuration parameter set to its default value.
If you want to set one or more configuration parameters to a different value for all invocations of
<code>eventually</code> in a suite you can override this
val (or hide it, for example, if you are importing the members of the <code>Eventually</code> companion object rather
than mixing in the trait). For example, if
you always want the default <code>timeout</code> to be 2 seconds and the default <code>interval</code> to be 5 milliseconds, you
can override <code>patienceConfig</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">val</span> patienceConfig =
  <span class="stType">PatienceConfig</span>(timeout = scaled(<span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>)), interval = scaled(<span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>)))
</pre></p><p>Or, hide it by declaring a variable of the same name in whatever scope you want the changed values to be in effect:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">val</span> patienceConfig =
  <span class="stType">PatienceConfig</span>(timeout = scaled(<span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>)), interval = scaled(<span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>)))
</pre></p><p>Passing your new default values to <code>scaled</code> is optional, but a good idea because it allows them to
be easily scaled if run on a slower or faster system.</p><p>In addition to taking a <code>PatienceConfig</code> object as an implicit parameter, the <code>eventually</code> methods of trait
<code>Eventually</code> include overloaded forms that take one or two <code>PatienceConfigParam</code>
objects that you can use to override the values provided by the implicit <code>PatienceConfig</code> for a single <code>eventually</code>
invocation. For example, if you want to set <code>timeout</code> to 5 seconds for just one particular <code>eventually</code> invocation,
you can do so like this:</p><p><pre class="stHighlighted">
eventually (timeout(<span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Seconds</span>))) { Thread.sleep(<span class="stLiteral">10</span>); it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>This invocation of <code>eventually</code> will use 5 seconds for the <code>timeout</code> and whatever value is specified by the
implicitly passed <code>PatienceConfig</code> object for the <code>interval</code> configuration parameter.
If you want to set both configuration parameters in this way, just list them separated by commas:</p><p><pre class="stHighlighted">
eventually (timeout(<span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Seconds</span>)), interval(<span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>))) { it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>You can also import or mix in the members of <a href="../time/SpanSugar.html"><code>SpanSugar</code></a> if
you want a more concise DSL for expressing time spans:</p><p><pre class="stHighlighted">
eventually (timeout(<span class="stLiteral">5</span> seconds), interval(<span class="stLiteral">5</span> millis)) { it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>Note that ScalaTest will not scale any time span that is not explicitly passed to <code>scaled</code> to make
the meaning of the code as obvious as possible. Thus
if you ask for &quot;<code>timeout(5 seconds)</code>&quot; you will get exactly that: a timeout of five seconds. If you want such explicitly
given values to be scaled, you must pass them to <code>scale</code> explicitly like this:</p><p><pre class="stHighlighted">
eventually (timeout(scaled(<span class="stLiteral">5</span> seconds))) { it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>The previous code says more clearly that the timeout will be five seconds, unless scaled higher or lower by the <code>scaled</code> method.</p><p><a name="simpleBackoff"></a></p><h4> Simple backoff algorithm </h4><p>The <code>eventually</code> methods employ a very simple backoff algorithm to try and maximize the speed of tests. If an asynchronous operation
completes quickly, a smaller interval will yield a faster test. But if an asynchronous operation takes a while, a small interval will keep the CPU
busy repeatedly checking and rechecking a not-ready operation, to some extent taking CPU cycles away from other processes that could proceed. To
strike the right balance between these design tradeoffs, the <code>eventually</code> methods will check more frequently during the initial interval.</p><p>Rather than sleeping an entire interval if the initial attempt fails, <code>eventually</code> will only sleep 1/10 of the configured interval. It
will continue sleeping only 1/10 of the configured interval until the configured interval has passed, after which it sleeps the configured interval
between attempts. Here's an example in which the timeout is set equal to the interval:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> xs = <span class="stLiteral">1</span> to <span class="stLiteral">125</span>
<span class="stReserved">val</span> it = xs.iterator
eventually(timeout(<span class="stLiteral">100</span> milliseconds), interval(<span class="stLiteral">100</span> milliseconds)) { it.next should be (<span class="stLiteral">110</span>) }
</pre></p><p>Even though this call to <code>eventually</code> will time out after only one interval, approximately, the error message will likely report that more
than one (and less than ten) attempts were made:</p><p><code>The code passed to eventually never returned normally. Attempted 6 times over 100.485 milliseconds. Last failure message: 6 was not equal to 110.</code></p><p>Note that if the initial attempt takes longer than the configured interval to complete, <code>eventually</code> will never sleep for
a 1/10 interval. You can observe this behavior in the <a href="#secondExample">second example</a> above in which the first statement in the block of code passed to <code>eventually</code>
was <code>Thread.sleep(50)</code>.</p><p><a name="patienceConfig"></a></p><h4> Usage note: <code>Eventually</code> intended primarily for integration testing </h4><p>Although the default timeouts of trait <code>Eventually</code> are tuned for unit testing, the use of <code>Eventually</code> in unit tests is
a choice you should question. Usually during unit testing you'll want to mock out subsystems that would require <code>Eventually</code>, such as
network services with varying and unpredictable response times. This will allow your unit tests to run as fast as possible while still testing
the focused bits of behavior they are designed to test.</p><p>Nevertheless, because sometimes it will make sense to use <code>Eventually</code> in unit tests (and
because it is destined to happen anyway even when it isn't the best choice), <code>Eventually</code> by default uses
timeouts tuned for unit tests: Calls to <code>eventually</code> are more likely to succeed on fast development machines, and if a call does time out,
it will do so quickly so the unit tests can move on.</p><p>When you are using <code>Eventually</code> for integration testing, therefore, the default timeout and interval may be too small. A
good way to override them is by mixing in trait <a href="IntegrationPatience.html"><code>IntegrationPatience</code></a> or a similar trait of your
own making. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Eventually</span> <span class="stReserved">with</span> <span class="stType">IntegrationPatience</span> {
  <span class="stLineComment">// Your integration tests here...</span>
}
</pre></p><p>Trait <code>IntegrationPatience</code> increases the default timeout from 150 milliseconds to 15 seconds, the default
interval from 15 milliseconds to 150 milliseconds. If need be, you can do fine tuning of the timeout and interval by
specifying a <a href="../tools/Runner$.html#scalingTimeSpans">time span scale factor</a> when you
run your tests.</p></div></div>
    </li><li name="org.scalatest.concurrent.Futures" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FuturesextendsPatienceConfiguration"></a>
      <a id="Futures:Futures"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Futures.html"><span class="name">Futures</span></a><span class="result"> extends <a href="PatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration">PatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@FuturesextendsPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that facilitates testing with futures.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that facilitates testing with futures.</p><p>This trait defines a <a href="Futures$FutureConcept.html"><code>FutureConcept</code></a> trait that can be used to implicitly wrap
different kinds of futures, thereby providing a uniform testing API for futures.
The three ways this trait enables you to test futures are:</p><p>1. Invoking <code>isReadyWithin</code>, to assert that a future is ready within a a specified time period.
Here's an example:</p><p><pre class="stHighlighted">
assert(result.isReadyWithin(<span class="stLiteral">100</span> millis))
</pre></p><p>2. Invoking <code>futureValue</code>, to obtain a futures result within a specified or implicit time period,
like this:</p><p><pre class="stHighlighted">
assert(result.futureValue === <span class="stLiteral">7</span>)
<br/><span class="stLineComment">// Or, if you expect the future to fail:</span>
assert(result.failed.futureValue.isInstanceOf[<span class="stType">ArithmeticException</span>])
</pre></p><p>3. Passing the future to <code>whenReady</code>, and performing assertions on the result value passed
to the given function, as in:</p><p><pre class="stHighlighted">
whenReady(result) { s =&gt;
  s should be (<span class="stQuotedString">"hello"</span>)
}
</pre></p><p>The <code>whenReady</code> construct periodically inspects the passed
future, until it is either ready or the configured timeout has been surpassed. If the future becomes
ready before the timeout, <code>whenReady</code> passes the future's value to the specified function.</p><p>To make <code>whenReady</code> more broadly applicable, the type of future it accepts is a <code>FutureConcept[T]</code>,
where <code>T</code> is the type of value promised by the future. Passing a future to <code>whenReady</code> requires
an implicit conversion from the type of future you wish to pass (the <em>modeled type</em>) to
<code>FutureConcept[T]</code>. Subtrait <code>JavaFutures</code> provides an implicit conversion from
<code>java.util.concurrent.Future[T]</code> to <code>FutureConcept[T]</code>.</p><p>For example, the following invocation of <code>whenReady</code> would succeed (not throw an exception):</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> Matchers._
<span class="stReserved">import</span> concurrent.Futures._
<span class="stReserved">import</span> java.util.concurrent._
<br/><span class="stReserved">val</span> exec = Executors.newSingleThreadExecutor
<span class="stReserved">val</span> task = <span class="stReserved">new</span> <span class="stType">Callable[String]</span> { <span class="stReserved">def</span> call() = { Thread.sleep(<span class="stLiteral">50</span>); <span class="stQuotedString">"hi"</span> } }
whenReady(exec.submit(task)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>However, because the default timeout is 150 milliseconds, the following invocation of
<code>whenReady</code> would ultimately produce a <code>TestFailedException</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> task = <span class="stReserved">new</span> <span class="stType">Callable[String]</span> { <span class="stReserved">def</span> call() = { Thread.sleep(<span class="stLiteral">500</span>); <span class="stQuotedString">"hi"</span> } }
whenReady(exec.submit(task)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>Assuming the default configuration parameters, a <code>timeout</code> of 150 milliseconds and an
<code>interval</code> of 15 milliseconds,
were passed implicitly to <code>whenReady</code>, the detail message of the thrown
<code>TestFailedException</code> would look like:</p><p><code>The future passed to whenReady was never ready, so whenReady timed out. Queried 95 times, sleeping 10 milliseconds between each query.</code></p><p><a name="defaultPatience"></a></p><h4> Configuration of <code>whenReady</code> </h4><p>The <code>whenReady</code> methods of this trait can be flexibly configured.
The two configuration parameters for <code>whenReady</code> along with their
default values and meanings are described in the following table:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Configuration Parameter</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Default Value</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Meaning</strong>
</th>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
timeout
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
scaled(150 milliseconds)
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the maximum amount of time to allow unsuccessful queries before giving up and throwing <code>TestFailedException</code>
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
interval
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
scaled(15 milliseconds)
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the amount of time to sleep between each query
</td>
</tr>
</table></p><p>The default values of both timeout and interval are passed to the <code>scaled</code> method, inherited
from <code>ScaledTimeSpans</code>, so that the defaults can be scaled up
or down together with other scaled time spans. See the documentation for trait <a href="ScaledTimeSpans.html"><code>ScaledTimeSpans</code></a>
for more information.</p><p>The <code>whenReady</code> methods of trait <code>Futures</code> each take a <code>PatienceConfig</code>
object as an implicit parameter. This object provides values for the two configuration parameters. Trait
<code>Futures</code> provides an implicit <code>val</code> named <code>defaultPatience</code> with each
configuration parameter set to its default value.
If you want to set one or more configuration parameters to a different value for all invocations of
<code>whenReady</code> in a suite you can override this
val (or hide it, for example, if you are importing the members of the <code>Futures</code> companion object rather
than mixing in the trait). For example, if
you always want the default <code>timeout</code> to be 2 seconds and the default <code>interval</code> to be 5 milliseconds, you
can override <code>defaultPatience</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">val</span> defaultPatience =
  <span class="stType">PatienceConfig</span>(timeout = <span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>), interval = <span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>))
</pre></p><p>Or, hide it by declaring a variable of the same name in whatever scope you want the changed values to be in effect:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">val</span> defaultPatience =
  <span class="stType">PatienceConfig</span>(timeout =  <span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>), interval = <span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>))
</pre></p><p>In addition to taking a <code>PatienceConfig</code> object as an implicit parameter, the <code>whenReady</code> methods of trait
<code>Futures</code> include overloaded forms that take one or two <code>PatienceConfigParam</code>
objects that you can use to override the values provided by the implicit <code>PatienceConfig</code> for a single <code>whenReady</code>
invocation. For example, if you want to set <code>timeout</code> to 6 seconds for just one particular <code>whenReady</code> invocation,
you can do so like this:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stType">Span</span>(<span class="stLiteral">6</span>, <span class="stType">Seconds</span>))) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>This invocation of <code>eventually</code> will use 6000 for <code>timeout</code> and whatever value is specified by the
implicitly passed <code>PatienceConfig</code> object for the <code>interval</code> configuration parameter.
If you want to set both configuration parameters in this way, just list them separated by commas:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stType">Span</span>(<span class="stLiteral">6</span>, <span class="stType">Seconds</span>)), interval(<span class="stType">Span</span>(<span class="stLiteral">500</span>, <span class="stType">Millis</span>))) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>You can also import or mix in the members of <a href="../time/SpanSugar.html"><code>SpanSugar</code></a> if
you want a more concise DSL for expressing time spans:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stLiteral">6</span> seconds), interval(<span class="stLiteral">500</span> millis)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p><em>Note: The <code>whenReady</code> construct was in part inspired by the <code>whenDelivered</code> matcher of the
<a href="http://github.com/jdegoes/blueeyes" target="_blank">BlueEyes</a> project, a lightweight, asynchronous web framework for Scala.</em></p></div></div>
    </li><li name="org.scalatest.concurrent.IntegrationPatience" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="IntegrationPatienceextendsAbstractPatienceConfiguration"></a>
      <a id="IntegrationPatience:IntegrationPatience"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="IntegrationPatience.html"><span class="name">IntegrationPatience</span></a><span class="result"> extends <a href="AbstractPatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.AbstractPatienceConfiguration">AbstractPatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@IntegrationPatienceextendsAbstractPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Stackable modification trait for <a href="PatienceConfiguration.html"><code>PatienceConfiguration</code></a> that provides default timeout and interval
values appropriate for integration testing.</a></p><div class="fullcomment"><div class="comment cmt"><p>Stackable modification trait for <a href="PatienceConfiguration.html"><code>PatienceConfiguration</code></a> that provides default timeout and interval
values appropriate for integration testing.</p><p>The default values for the parameters are:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><strong>Configuration Parameter</strong></th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><strong>Default Value</strong></th></tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>timeout</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(15 seconds)</code>
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>interval</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(150 milliseconds)</code>
</td>
</tr>
</table></p><p>The default values of both timeout and interval are passed to the <code>scaled</code> method, inherited
from <code>ScaledTimeSpans</code>, so that the defaults can be scaled up
or down together with other scaled time spans. See the documentation for trait <a href="ScaledTimeSpans.html"><code>ScaledTimeSpans</code></a>
for more information.</p><p>Mix this trait into any class that uses <code>PatienceConfiguration</code> (such as classes that mix in <a href="Eventually.html"><code>Eventually</code></a>
or <a href="Waiters.html"><code>Waiters</code></a>) to get timeouts tuned towards integration testing, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Eventually</span> <span class="stReserved">with</span> <span class="stType">IntegrationPatience</span> {
  <span class="stLineComment">// ...</span>
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.concurrent.JavaFutures" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="JavaFuturesextendsFutures"></a>
      <a id="JavaFutures:JavaFutures"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="JavaFutures.html"><span class="name">JavaFutures</span></a><span class="result"> extends <a href="Futures.html" class="extype" name="org.scalatest.concurrent.Futures">Futures</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@JavaFuturesextendsFutures" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Provides an implicit conversion from <code>java.util.concurrent.Future[T]</code> to
<a href="Futures$FutureConcept.html"><code>FutureConcept[T]</code></a>.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit conversion from <code>java.util.concurrent.Future[T]</code> to
<a href="Futures$FutureConcept.html"><code>FutureConcept[T]</code></a>.</p><p>This trait enables you to invoke the methods defined on <code>FutureConcept</code> on a Java <code>Future</code>, as well as to pass a Java future
to the <code>whenReady</code> methods of supertrait <code>Futures</code>.
See the documentation for supertrait <a href="Futures.html"><code>Futures</code></a> for the details on the syntax this trait provides
for testing with Java futures.</p></div></div>
    </li><li name="org.scalatest.concurrent.PatienceConfiguration" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PatienceConfigurationextendsAbstractPatienceConfiguration"></a>
      <a id="PatienceConfiguration:PatienceConfiguration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="PatienceConfiguration.html"><span class="name">PatienceConfiguration</span></a><span class="result"> extends <a href="AbstractPatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.AbstractPatienceConfiguration">AbstractPatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@PatienceConfigurationextendsAbstractPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait providing methods and classes used to configure timeouts and, where relevant, the interval
between retries.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing methods and classes used to configure timeouts and, where relevant, the interval
between retries.</p><p>This trait is called <code>PatienceConfiguration</code> because it allows configuration of two
values related to patience: The timeout specifies how much time asynchronous operations will be given
to succeed before giving up. The interval specifies how much time to wait between checks to determine
success when polling.</p><p>The default values for timeout and interval provided by trait <code>PatienceConfiguration</code> are tuned for unit testing,
where running tests as fast as
possible is a high priority and subsystems requiring asynchronous operations are therefore often replaced
by mocks. This table shows the default values:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><strong>Configuration Parameter</strong></th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><strong>Default Value</strong></th></tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>timeout</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(150 milliseconds)</code>
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>interval</code>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<code>scaled(15 milliseconds)</code>
</td>
</tr>
</table></p><p>Values more appropriate to integration testing, where asynchronous operations tend to take longer because the tests are run
against the actual subsytems (not mocks), can be obtained by mixing in trait <a href="IntegrationPatience.html"><code>IntegrationPatience</code></a>.</p><p>The default values of both timeout and interval are passed to the <code>scaled</code> method, inherited
from <code>ScaledTimeSpans</code>, so that the defaults can be scaled up
or down together with other scaled time spans. See the documentation for trait <a href="ScaledTimeSpans.html"><code>ScaledTimeSpans</code></a>
for more information.</p><p>Timeouts are used by the <code>eventually</code> methods of trait
<a href="Eventually.html"><code>Eventually</code></a> and the <code>await</code> method of class
<code>Waiter</code>, a member of trait
<a href="Waiters.html"><code>Waiters</code></a>. Intervals are used by
the <code>eventually</code> methods.</p></div></div>
    </li><li name="org.scalatest.concurrent.ScalaFutures" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ScalaFuturesextendsFutures"></a>
      <a id="ScalaFutures:ScalaFutures"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ScalaFutures.html"><span class="name">ScalaFutures</span></a><span class="result"> extends <a href="Futures.html" class="extype" name="org.scalatest.concurrent.Futures">Futures</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ScalaFuturesextendsFutures" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Provides an implicit conversion from <code>scala.concurrent.Future[T]</code> to
<a href="Futures$FutureConcept.html"><code>FutureConcept[T]</code></a>.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit conversion from <code>scala.concurrent.Future[T]</code> to
<a href="Futures$FutureConcept.html"><code>FutureConcept[T]</code></a>.</p><p>This trait enables you to invoke the methods defined on <code>FutureConcept</code> on a Scala <code>Future</code>, as well as to pass a Scala future
to the <code>whenReady</code> methods of supertrait <code>Futures</code>.
The three ways this trait enables you to test futures are:</p><p>1. Invoking <code>isReadyWithin</code>, to assert that a future is ready within a a specified time period.
Here's an example:</p><p><pre class="stHighlighted">
assert(result.isReadyWithin(<span class="stLiteral">100</span> millis))
</pre></p><p>2. Invoking <code>futureValue</code>, to obtain a futures result within a specified or implicit time period,
like this:</p><p><pre class="stHighlighted">
assert(result.futureValue === <span class="stLiteral">7</span>)
<br/><span class="stLineComment">// Or, if you expect the future to fail:</span>
assert(result.failed.futureValue.isInstanceOf[<span class="stType">ArithmeticException</span>])
</pre></p><p>3. Passing the future to <code>whenReady</code>, and performing assertions on the result value passed
to the given function, as in:</p><p><pre class="stHighlighted">
whenReady(result) { s =&gt;
  s should be (<span class="stQuotedString">"hello"</span>)
}
</pre></p><p>The <code>whenReady</code> construct periodically inspects the passed
future, until it is either ready or the configured timeout has been surpassed. If the future becomes
ready before the timeout, <code>whenReady</code> passes the future's value to the specified function.</p><p>To make <code>whenReady</code> more broadly applicable, the type of future it accepts is a <code>FutureConcept[T]</code>,
where <code>T</code> is the type of value promised by the future. Passing a future to <code>whenReady</code> requires
an implicit conversion from the type of future you wish to pass (the <em>modeled type</em>) to
<code>FutureConcept[T]</code>. Subtrait <code>JavaFutures</code> provides an implicit conversion from
<code>java.util.concurrent.Future[T]</code> to <code>FutureConcept[T]</code>.</p><p>For example, the following invocation of <code>whenReady</code> would succeed (not throw an exception):</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> Matchers._
<span class="stReserved">import</span> concurrent.Futures._
<span class="stReserved">import</span> java.util.concurrent._
<br/><span class="stReserved">val</span> exec = Executors.newSingleThreadExecutor
<span class="stReserved">val</span> task = <span class="stReserved">new</span> <span class="stType">Callable[String]</span> { <span class="stReserved">def</span> call() = { Thread.sleep(<span class="stLiteral">50</span>); <span class="stQuotedString">"hi"</span> } }
whenReady(exec.submit(task)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>However, because the default timeout is 150 milliseconds, the following invocation of
<code>whenReady</code> would ultimately produce a <code>TestFailedException</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> task = <span class="stReserved">new</span> <span class="stType">Callable[String]</span> { <span class="stReserved">def</span> call() = { Thread.sleep(<span class="stLiteral">500</span>); <span class="stQuotedString">"hi"</span> } }
whenReady(exec.submit(task)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>Assuming the default configuration parameters, a <code>timeout</code> of 150 milliseconds and an
<code>interval</code> of 15 milliseconds,
were passed implicitly to <code>whenReady</code>, the detail message of the thrown
<code>TestFailedException</code> would look like:</p><p><code>The future passed to whenReady was never ready, so whenReady timed out. Queried 95 times, sleeping 10 milliseconds between each query.</code></p><p><a name="defaultPatience"></a></p><h4> Configuration of <code>whenReady</code> </h4><p>The <code>whenReady</code> methods of this trait can be flexibly configured.
The two configuration parameters for <code>whenReady</code> along with their
default values and meanings are described in the following table:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Configuration Parameter</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Default Value</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Meaning</strong>
</th>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
timeout
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
scaled(150 milliseconds)
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the maximum amount of time to allow unsuccessful queries before giving up and throwing <code>TestFailedException</code>
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
interval
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
scaled(15 milliseconds)
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
the amount of time to sleep between each query
</td>
</tr>
</table></p><p>The default values of both timeout and interval are passed to the <code>scaled</code> method, inherited
from <code>ScaledTimeSpans</code>, so that the defaults can be scaled up
or down together with other scaled time spans. See the documentation for trait <a href="ScaledTimeSpans.html"><code>ScaledTimeSpans</code></a>
for more information.</p><p>The <code>whenReady</code> methods of trait <code>Futures</code> each take a <code>PatienceConfig</code>
object as an implicit parameter. This object provides values for the two configuration parameters. Trait
<code>Futures</code> provides an implicit <code>val</code> named <code>defaultPatience</code> with each
configuration parameter set to its default value.
If you want to set one or more configuration parameters to a different value for all invocations of
<code>whenReady</code> in a suite you can override this
val (or hide it, for example, if you are importing the members of the <code>Futures</code> companion object rather
than mixing in the trait). For example, if
you always want the default <code>timeout</code> to be 2 seconds and the default <code>interval</code> to be 5 milliseconds, you
can override <code>defaultPatience</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">val</span> defaultPatience =
  <span class="stType">PatienceConfig</span>(timeout = <span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>), interval = <span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>))
</pre></p><p>Or, hide it by declaring a variable of the same name in whatever scope you want the changed values to be in effect:</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">val</span> defaultPatience =
  <span class="stType">PatienceConfig</span>(timeout =  <span class="stType">Span</span>(<span class="stLiteral">2</span>, <span class="stType">Seconds</span>), interval = <span class="stType">Span</span>(<span class="stLiteral">5</span>, <span class="stType">Millis</span>))
</pre></p><p>In addition to taking a <code>PatienceConfig</code> object as an implicit parameter, the <code>whenReady</code> methods of trait
<code>Futures</code> include overloaded forms that take one or two <code>PatienceConfigParam</code>
objects that you can use to override the values provided by the implicit <code>PatienceConfig</code> for a single <code>whenReady</code>
invocation. For example, if you want to set <code>timeout</code> to 6 seconds for just one particular <code>whenReady</code> invocation,
you can do so like this:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stType">Span</span>(<span class="stLiteral">6</span>, <span class="stType">Seconds</span>))) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>This invocation of <code>eventually</code> will use 6000 for <code>timeout</code> and whatever value is specified by the
implicitly passed <code>PatienceConfig</code> object for the <code>interval</code> configuration parameter.
If you want to set both configuration parameters in this way, just list them separated by commas:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stType">Span</span>(<span class="stLiteral">6</span>, <span class="stType">Seconds</span>)), interval(<span class="stType">Span</span>(<span class="stLiteral">500</span>, <span class="stType">Millis</span>))) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p>You can also import or mix in the members of <a href="../time/SpanSugar.html"><code>SpanSugar</code></a> if
you want a more concise DSL for expressing time spans:</p><p><pre class="stHighlighted">
whenReady (exec.submit(task), timeout(<span class="stLiteral">6</span> seconds), interval(<span class="stLiteral">500</span> millis)) { s =&gt;
  s should be (<span class="stQuotedString">"hi"</span>)
}
</pre></p><p><em>Note: The <code>whenReady</code> construct was in part inspired by the <code>whenDelivered</code> matcher of the
<a href="http://github.com/jdegoes/blueeyes" target="_blank">BlueEyes</a> project, a lightweight, asynchronous web framework for Scala.</em></p></div></div>
    </li><li name="org.scalatest.concurrent.ScaledTimeSpans" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ScaledTimeSpansextendsAnyRef"></a>
      <a id="ScaledTimeSpans:ScaledTimeSpans"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ScaledTimeSpans.html"><span class="name">ScaledTimeSpans</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ScaledTimeSpansextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait providing a <code>scaled</code> method that can be used to scale time
<code>Span</code>s used during the testing of asynchronous operations.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Trait providing a <code>scaled</code> method that can be used to scale time
<code>Span</code>s used during the testing of asynchronous operations.</p><p>The <code>scaled</code> method allows tests of asynchronous operations to be tuned
according to need.  For example, <code>Span</code>s can be scaled larger when running
tests on slower continuous integration servers or smaller when running on faster
development machines.</p><p>The <code>Double</code> factor by which to scale the <code>Span</code>s passed to
<code>scaled</code> is obtained from the <code>spanScaleFactor</code> method, also declared
in this trait. By default this method returns 1.0, but can be configured to return
a different value by passing a <code>-F</code> argument to <a href="../tools/Runner$.html"><code>Runner</code></a> (or
an equivalent mechanism in an ant, sbt, or Maven build file).</p><p>The default timeouts and intervals defined for traits <a href="Eventually.html"><code>Eventually</code></a> and
<a href="Waiters.html"><code>Waiters</code></a> invoke <code>scaled</code>, so those defaults
will be scaled automatically. Other than such defaults, however, to get a <code>Span</code>
to scale you'll need to explicitly pass it to <code>scaled</code>.
For example, here's how you would scale a <code>Span</code> you supply to
the <code>failAfter</code> method from trait <code>Timeouts</code>:</p><p><pre class="stHighlighted">
failAfter(scaled(<span class="stLiteral">150</span> millis)) {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>The reason <code>Span</code>s are not scaled automatically in the general case is
to make code obvious. If a reader sees <code>failAfter(1 second)</code>, it will
mean exactly that: fail after one second. And if a <code>Span</code> will be scaled,
the reader will clearly see that as well: <code>failAfter(scaled(1 second))</code>.</p><h4> Overriding <code>spanScaleFactor</code> </h4><p>You can override the <code>spanScaleFactor</code> method to configure the factor by a
different means. For example, to configure the factor from Akka
TestKit's test time factor you might create a trait like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.concurrent.ScaledTimeSpans
<span class="stReserved">import</span> akka.actor.ActorSystem
<span class="stReserved">import</span> akka.testkit.TestKitExtension
<br/><span class="stReserved">trait</span> <span class="stType">AkkaSpanScaleFactor</span> <span class="stReserved">extends</span> <span class="stType">ScaledTimeSpans</span> {
  <span class="stReserved">override</span> <span class="stReserved">def</span> spanScaleFactor: <span class="stType">Double</span> =
      TestKitExtension.get(<span class="stType">ActorSystem</span>()).TestTimeFactor
}
</pre></p><p>This trait overrides <code>spanScaleFactor</code> so that it takes its
scale factor from Akka's <code>application.conf</code> file.
You could then scale <code>Span</code>s tenfold in Akka's configuration file
like this:</p><p><pre>
akka {
  test {
    timefactor = 10.0
  }
}
</pre></p><p>Armed with this trait and configuration file, you can simply mix trait
<code>AkkaSpanScaleFactor</code> into any test class whose <code>Span</code>s
you want to scale, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MySpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Eventually</span> <span class="stReserved">with</span> <span class="stType">AkkaSpanScaleFactor</span> {
  <span class="stLineComment">// ..</span>
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.concurrent.SelectorSignaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SelectorSignalerextendsSignaler"></a>
      <a id="SelectorSignaler:SelectorSignaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SelectorSignaler.html"><span class="name">SelectorSignaler</span></a><span class="result"> extends <a href="Signaler.html" class="extype" name="org.scalatest.concurrent.Signaler">Signaler</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SelectorSignalerextendsSignaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for signaling an operation in which <code>wakeup</code> is called on the <code>java.nio.channels.Selector</code> passed to
the constructor.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for signaling an operation in which <code>wakeup</code> is called on the <code>java.nio.channels.Selector</code> passed to
the constructor.</p><p>This class can be used for configuration when using traits <a href="TimeLimits.html"><code>TimeLimits</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.Signaler" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SignalerextendsAnyRef"></a>
      <a id="Signaler:Signaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Signaler.html"><span class="name">Signaler</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SignalerextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for signaling an operation after a timeout expires.</p><div class="fullcomment"><div class="comment cmt"><p>Strategy for signaling an operation after a timeout expires.</p><p>An instance of this trait is used for configuration when using traits
<a href="TimeLimits.html"><code>TimeLimits</code></a> and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.SocketSignaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SocketSignalerextendsSignaler"></a>
      <a id="SocketSignaler:SocketSignaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SocketSignaler.html"><span class="name">SocketSignaler</span></a><span class="result"> extends <a href="Signaler.html" class="extype" name="org.scalatest.concurrent.Signaler">Signaler</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SocketSignalerextendsSignaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for signaling an operation in which <code>close</code> is called on the <code>java.net.Socket</code> passed to
the constructor.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for signaling an operation in which <code>close</code> is called on the <code>java.net.Socket</code> passed to
the constructor.</p><p>This class can be used for configuration when using traits <a href="TimeLimits.html"><code>TimeLimits</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.TimeLimitedTests" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TimeLimitedTestsextendsTestSuiteMixin"></a>
      <a id="TimeLimitedTests:TimeLimitedTests"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="TimeLimitedTests.html"><span class="name">TimeLimitedTests</span></a><span class="result"> extends <a href="../TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@TimeLimitedTestsextendsTestSuiteMixin" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a suite class establishes a time limit for its tests.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a suite class establishes a time limit for its tests.</p><p><strong>
Unfortunately this trait experienced a potentially breaking change in 3.0: previously
this trait declared a <code>defaultTestInterruptor</code> <code>val</code> of type
<code>Interruptor</code>, in 3.0 that was renamed to <code>defaultTestSignaler</code>
and given type <code>Signaler</code>. The reason is that the default <code>Interruptor</code>, <code>ThreadInterruptor</code>,
did not make sense on Scala.js&#8212;in fact, the entire notion of interruption did not make
sense on Scala.js. <code>Signaler</code>'s default is <code>DoNotSignal</code>, which is a better
default on Scala.js, and works fine as a default on the JVM.
<code>Timeouts</code> was left the same in 3.0, so existing code using it would
continue to work as before, but after a deprecation period <code>Timeouts</code> will be
supplanted by <code>TimeLimits</code>, which uses <code>Signaler</code>. <code>TimeLimitedTests</code>
now uses <code>TimeLimits</code> instead of <code>Timeouts</code>, so if you overrode the default
<code>Interruptor</code> before, you'll need to change it to the equivalent <code>Signaler</code>.
And if you were depending on the default being a <code>ThreadInterruptor</code>, you'll need to
override <code>defaultTestSignaler</code> and set it to <code>ThreadSignaler</code>.
</strong></p><p>This trait overrides <code>withFixture</code>, wrapping a <code>super.withFixture(test)</code> call
in a <code>failAfter</code> invocation, specifying a time limit obtained by invoking <code>timeLimit</code>
and a <a href="Signaler.html"><code>Signaler</code></a> by invoking <code>defaultTestSignaler</code>:</p><p><pre class="stHighlighted">
failAfter(timeLimit) {
  <span class="stReserved">super</span>.withFixture(test)
} (defaultTestSignaler)
</pre></p><p>Note that the <code>failAfter</code> method executes the body of the by-name passed to it using the same
thread that invoked <code>failAfter</code>. This means that the same thread will run the <code>withFixture</code> method
as well as each test, so no extra synchronization is required. A second thread is used to run a timer, and if the timeout
expires, that second thread will attempt to signal the main test thread via the <code>defaultTestSignaler</code>.</p><p>The <code>timeLimit</code> field is abstract in this trait. Thus you must specify a time limit when you use it.
For example, the following code specifies that each test must complete within 200 milliseconds:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.concurrent.TimeLimitedTests
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">TimeLimitedTests</span> {
<br/>  <span class="stLineComment">// Note: You may need to either write 200.millis or (200 millis), or</span>
  <span class="stLineComment">// place a semicolon or blank line after plain old 200 millis, to</span>
  <span class="stLineComment">// avoid the semicolon inference problems of postfix operator notation.</span>
  <span class="stReserved">val</span> timeLimit = <span class="stLiteral">200</span> millis
<br/>  describe(<span class="stQuotedString">"A time-limited test"</span>) {
    it(<span class="stQuotedString">"should succeed if it completes within the time limit"</span>) {
      Thread.sleep(<span class="stLiteral">100</span>)
    }
    it(<span class="stQuotedString">"should fail if it is taking too darn long"</span>) {
      Thread.sleep(<span class="stLiteral">300</span>)
    }
  }
}
</pre></p><p>If you run the above <code>ExampleSpec</code>, the second test will fail with the error message:</p><p><code>The test did not complete within the specified 200 millisecond time limit.</code></p><p>The <code>failAfter</code> method uses an <code>Signaler</code> to attempt to signal the main test thread if the timeout
expires. The default <code>Signaler</code> returned by the <code>defaultTestSignaler</code> method is a
<a href="DoNotSignal$.html"><code>DoNotSignal</code></a>, which does not signal the main test thread to stop. If you wish to change this
signaling strategy, override <code>defaultTestSignaler</code> to return a different <code>Signaler</code>. For example,
here's how you'd change the default to <a href="ThreadSignaler$.html"><code>ThreadSignaler</code></a>, which will
interrupt the main test thread when time is up:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.concurrent.{<span class="stType">ThreadSignaler</span>, <span class="stType">TimeLimitedTests</span>}
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSignalerSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">TimeLimitedTests</span> {
<br/><span class="stReserved">val</span> timeLimit = <span class="stLiteral">200</span> millis
<br/><span class="stReserved">override</span> <span class="stReserved">val</span> defaultTestSignaler = <span class="stType">ThreadSignaler</span>
<br/>describe(<span class="stQuotedString">"A time-limited test"</span>) {
    it(<span class="stQuotedString">"should succeed if it completes within the time limit"</span>) {
      Thread.sleep(<span class="stLiteral">100</span>)
    }
    it(<span class="stQuotedString">"should fail if it is taking too darn long"</span>) {
      Thread.sleep(<span class="stLiteral">300</span>)
    }
  }
}
</pre></p><p>Like the previous incarnation of <code>ExampleSuite</code>, the second test will fail with an error message that indicates
a timeout expired. But whereas in the previous case, the <code>Thread.sleep</code> would be interrupted after 200 milliseconds,
in this case it is never interrupted. In the previous case, the failed test requires a little over 200 milliseconds to run.
In this case, because the <code>sleep(300)</code> is never interrupted, the failed test requires a little over 300 milliseconds
to run.</p></div></div>
    </li><li name="org.scalatest.concurrent.TimeLimits" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TimeLimitsextendsAnyRef"></a>
      <a id="TimeLimits:TimeLimits"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="TimeLimits.html"><span class="name">TimeLimits</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@TimeLimitsextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that provides <code>failAfter</code> and <code>cancelAfter</code> methods, which allow you to specify a time limit for an
operation passed as a by-name parameter, as well as a way to signal it if the operation exceeds its time limit.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides <code>failAfter</code> and <code>cancelAfter</code> methods, which allow you to specify a time limit for an
operation passed as a by-name parameter, as well as a way to signal it if the operation exceeds its time limit.</p><p>The time limit is passed as the first parameter, as a <a href="../time/Span.html"><code>Span</code></a>. The operation is
passed as the second parameter. A <a href="Signaler.html"><code>Signaler</code></a>, a strategy for interrupting the operation, is
passed as an implicit third parameter.  Here's a simple example of its use:</p><p><pre class="stHighlighted">
failAfter(<span class="stType">Span</span>(<span class="stLiteral">100</span>, <span class="stType">Millis</span>)) {
  Thread.sleep(<span class="stLiteral">200</span>)
}
</pre></p><p>The above code will eventually produce a <a href="../exceptions/TestFailedDueToTimeoutException.html"><code>TestFailedDueToTimeoutException</code></a> with a message
that indicates a time limit has been exceeded:</p><p><code>The code passed to failAfter did not complete within 100 milliseconds.</code></p><p>If you use <code>cancelAfter</code> in place of <code>failAfter</code>, a <a href="../exceptions/TestCanceledException.html"><code>TestCanceledException</code></a> will be thrown
instead, also with a message that indicates a time limit has been exceeded:</p><p><code>The code passed to cancelAfter did not complete within 100 milliseconds.</code></p><p>If you prefer you can mix in or import the members of <a href="../time/SpanSugar.html"><code>SpanSugar</code></a> and place a units value after the integer timeout.
Here are some examples:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/>failAfter(<span class="stLiteral">100</span> millis) {
  Thread.sleep(<span class="stLiteral">200</span>)
}
<br/>failAfter(<span class="stLiteral">1</span> second) {
  Thread.sleep(<span class="stLiteral">2000</span>)
}
</pre></p><p>The code passed via the by-name parameter to <code>failAfter</code> or <code>cancelAfter</code> will be executed by the thread that invoked
<code>failAfter</code> or <code>cancelAfter</code>, so that no synchronization is necessary to access variables declared outside the by-name.</p><p><pre class="stHighlighted">
<span class="stReserved">var</span> result = -<span class="stLiteral">1</span> <span class="stLineComment">// No need to make this volatile</span>
failAfter(<span class="stLiteral">100</span> millis) {
  result = accessNetService()
}
result should be (<span class="stLiteral">99</span>)
</pre></p><p>The <code>failAfter</code> or <code>cancelAfter</code> method will create a timer that runs on a different thread than the thread that
invoked <code>failAfter</code> or <code>cancelAfter</code>, so that it can detect when the time limit has been exceeded and attempt to <em>signal</em>
the main thread. Because different operations can require different signaling strategies, the <code>failAfter</code> and <code>cancelAfter</code>
methods accept an implicit third parameter of type <code>Signaler</code> that is responsible for signaling
the main thread.</p><p><a name="signalerConfig"></a></p><h4> Configuring <code>failAfter</code> or <code>cancelAfter</code> with a <code>Signaler</code> </h4><p>The <code>Signaler</code> companion object declares an implicit <code>val</code> of type <code>Signaler</code> that returns
a <code>DoNotSignal</code>. This serves as the default signaling strategy.
If you wish to use a different strategy, you can declare an implicit <code>val</code> that establishes a different <code>Signaler</code>
as the policy.  Here's an example
in which the default signaling strategy is changed to <a href="ThreadSignaler.html"><code>ThreadSignaler</code></a>, which does not attempt to
interrupt the main thread in any way:</p><p><pre class="stHighlighted">
<span class="stReserved">override</span> <span class="stReserved">val</span> signaler: <span class="stType">Signaler</span> = <span class="stType">ThreadSignaler</span>
failAfter(<span class="stLiteral">100</span> millis) {
  Thread.sleep(<span class="stLiteral">500</span>)
}
</pre></p><p>As with the default <code>Signaler</code>, the above code will eventually produce a
<code>TestFailedDueToTimeoutException</code> with a message that indicates a timeout expired. However, instead
of throwing the exception after approximately 500 milliseconds, it will throw it after approximately 100 milliseconds.</p><p>This illustrates an important feature of <code>failAfter</code> and <code>cancelAfter</code>: it will throw a
<code>TestFailedDueToTimeoutException</code> (or <code>TestCanceledException</code> in case of <code>cancelAfter</code>)
if the code passed as the by-name parameter takes longer than the specified timeout to execute, even if it
is allowed to run to completion beyond the specified timeout and returns normally.</p><p>ScalaTest provides the following <code>Signaler</code> implementations:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong><code>Signaler</code> implementation</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Usage</strong>
</th>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="DoNotSignal$.html">DoNotSignal</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
The default signaler, does not attempt to interrupt the main test thread in any way
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="ThreadSignaler$.html">ThreadSignaler</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Invokes <code>interrupt</code> on the main test thread. This will
set the interrupted status for the main test thread and,
if the main thread is blocked, will in some cases cause the main thread to complete abruptly with
an <code>InterruptedException</code>.
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="SelectorSignaler.html">SelectorSignaler</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Invokes <code>wakeup</code> on the passed <code>java.nio.channels.Selector</code>, which
will cause the main thread, if blocked in <code>Selector.select</code>, to complete abruptly with a
<code>ClosedSelectorException</code>.
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="SocketSignaler.html">SocketSignaler</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Invokes <code>close</code> on the <code>java.io.Socket</code>, which
will cause the main thread, if blocked in a read or write of an <code>java.io.InputStream</code> or
<code>java.io.OutputStream</code> that uses the <code>Socket</code>, to complete abruptly with a
<code>SocketException</code>.
</td>
</tr>
</table></p><p>You may wish to create your own <code>Signaler</code> in some situations. For example, if your operation is performing
a loop and can check a volatile flag each pass through the loop, you could write a <code>Signaler</code> that
sets that flag so that the next time around, the loop would exit.</p></div></div>
    </li><li name="org.scalatest.concurrent.Waiters" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="WaitersextendsPatienceConfiguration"></a>
      <a id="Waiters:Waiters"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Waiters.html"><span class="name">Waiters</span></a><span class="result"> extends <a href="PatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration">PatienceConfiguration</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@WaitersextendsPatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that facilitates performing assertions outside the main test thread, such as assertions in callback methods
that are invoked asynchronously.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that facilitates performing assertions outside the main test thread, such as assertions in callback methods
that are invoked asynchronously.</p><p>Trait <code>Waiters</code> provides a <code>Waiter</code> class that you can use to orchestrate the inter-thread
communication required to perform assertions outside the main test thread, and a means to configure it.</p><p>To use <code>Waiter</code>, create an instance of it in the main test thread:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> w = <span class="stReserved">new</span> <span class="stType">Waiter</span> <span class="stLineComment">// Do this in the main test thread</span>
</pre></p><p>At some point later, call <code>await</code> on the waiter:</p><p><pre class="stHighlighted">
w.await() <span class="stLineComment">// Call await() from the main test thread</span>
</pre></p><p>The <code>await</code> call will block until it either receives a report of a failed assertion from a different thread, at which
point it will complete abruptly with the same exception, or until it is <em>dismissed</em> by a different thread (or threads), at
which point it will return normally. You can optionally specify a timeout and/or a number
of dismissals to wait for. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/>w.await(timeout(<span class="stLiteral">300</span> millis), dismissals(<span class="stLiteral">2</span>))
</pre></p><p>The default value for <code>timeout</code>, provided via an implicit <code>PatienceConfig</code> parameter, is 150 milliseconds. The default value for
<code>dismissals</code> is 1. The <code>await</code> method will block until either it is dismissed a sufficient number of times by other threads or
an assertion fails in another thread. Thus if you just want to perform assertions in just one other thread, only that thread will be
performing a dismissal, so you can use the default value of 1 for <code>dismissals</code>.</p><p><code>Waiter</code> contains four overloaded forms of <code>await</code>, two of which take an implicit
<code>PatienceConfig</code> parameter. To change the default timeout configuration, override or hide
(if you imported the members of <code>Waiters</code> companion object instead of mixing in the
trait) <code>patienceConfig</code> with a new one that returns your desired configuration.</p><p>To dismiss a waiter, you just invoke <code>dismiss</code> on it:</p><p><pre class="stHighlighted">
w.dismiss() <span class="stLineComment">// Call this from one or more other threads</span>
</pre></p><p>You may want to put <code>dismiss</code> invocations in a finally clause to ensure they happen even if an exception is thrown.
Otherwise if a dismissal is missed because of a thrown exception, an <code>await</code> call will wait until it times out.</p><p>Note that if a <code>Waiter</code> receives <em>more </em> than the expected number of dismissals, it will not report
this as an error: <em>i.e.</em>, receiving greater than the number of expected dismissals without any failed assertion will simply
cause the the test to complete, not to fail. The only way a <code>Waiter</code> will cause a test to fail is if one of the
asynchronous assertions to which it is applied fails.</p><p>Finally, to perform an assertion in a different thread, you just apply the <code>Waiter</code> to the assertion code. Here are
some examples:</p><p><pre class="stHighlighted">
w { assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>) }    <span class="stLineComment">// Can use assertions</span>
w { <span class="stLiteral">1</span> + <span class="stLiteral">1</span> should equal (<span class="stLiteral">3</span>) } <span class="stLineComment">// Or matchers</span>
w { <span class="stQuotedString">"hi"</span>.charAt(-<span class="stLiteral">1</span>) }        <span class="stLineComment">// Any exceptions will be forwarded to await</span>
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> concurrent.Waiters
<span class="stReserved">import</span> scala.actors.Actor
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> <span class="stReserved">with</span> <span class="stType">Waiters</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Message</span>(text: <span class="stType">String</span>)
<br/>  <span class="stReserved">class</span> <span class="stType">Publisher</span> <span class="stReserved">extends</span> <span class="stType">Actor</span> {
<br/>    @volatile <span class="stReserved">private</span> <span class="stReserved">var</span> handle: <span class="stType">Message</span> =&gt; <span class="stType">Unit</span> = { (msg) =&gt; }
<br/>    <span class="stReserved">def</span> registerHandler(f: <span class="stType">Message</span> =&gt; <span class="stType">Unit</span>) {
      handle = f
    }
<br/>    <span class="stReserved">def</span> act() {
      <span class="stReserved">var</span> done = <span class="stReserved">false</span>
      <span class="stReserved">while</span> (!done) {
        react {
          <span class="stReserved">case</span> msg: <span class="stType">Message</span> =&gt; handle(msg)
          <span class="stReserved">case</span> <span class="stQuotedString">"Exit"</span> =&gt; done = <span class="stReserved">true</span>
        }
      }
    }
  }
<br/>  test(<span class="stQuotedString">"example one"</span>) {
<br/>    <span class="stReserved">val</span> publisher = <span class="stReserved">new</span> <span class="stType">Publisher</span>
    <span class="stReserved">val</span> message = <span class="stReserved">new</span> <span class="stType">Message</span>(<span class="stQuotedString">"hi"</span>)
    <span class="stReserved">val</span> w = <span class="stReserved">new</span> <span class="stType">Waiter</span>
<br/>    publisher.start()
<br/>    publisher.registerHandler { msg =&gt;
      w { msg should equal (message) }
      w.dismiss()
    }
<br/>    publisher ! message
    w.await()
    publisher ! <span class="stQuotedString">"Exit"</span>
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.concurrent.AsyncAssertions" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AsyncAssertions=org.scalatest.concurrent.Waiters"></a>
      <a id="AsyncAssertions:AsyncAssertions"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Waiters instead">AsyncAssertions</span><span class="result"> = <a href="Waiters.html" class="extype" name="org.scalatest.concurrent.Waiters">Waiters</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@AsyncAssertions=org.scalatest.concurrent.Waiters" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>The name <code>org.scalatest.concurrent.AsyncAssertions</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.concurrent.Waiters</code>, instead.</strong> </strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalatest.concurrent.AsyncAssertions</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.concurrent.Waiters</code>, instead.</strong></p><p>We deprecate this name because this is blocking while our new asynchronous style traits are not, thus could potentially cause some confusion.
Another reason is that this name sounds like it is a subclass of Assertions, while it is not.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Waiters instead</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.DeprecatedTimeLimitedTests" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DeprecatedTimeLimitedTestsextendsTestSuiteMixin"></a>
      <a id="DeprecatedTimeLimitedTests:DeprecatedTimeLimitedTests"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="DeprecatedTimeLimitedTests.html"><span class="name deprecated" title="Deprecated: DeprecatedTimeLimitedTests is deprecated and will be removed in a future version of ScalaTest. Please use TimeLimitedTests instead.">DeprecatedTimeLimitedTests</span></a><span class="result"> extends <a href="../TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@DeprecatedTimeLimitedTestsextendsTestSuiteMixin" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a suite class establishes a time limit for its tests.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a suite class establishes a time limit for its tests.</p><p>This trait overrides <code>withFixture</code>, wrapping a <code>super.withFixture(test)</code> call
in a <code>failAfter</code> invocation, specifying a timeout obtained by invoking <code>timeLimit</code>
and an <a href="Interruptor.html"><code>Interruptor</code></a> by invoking <code>defaultTestInterruptor</code>:</p><p><pre class="stHighlighted">
failAfter(timeLimit) {
  <span class="stReserved">super</span>.withFixture(test)
} (defaultTestInterruptor)
</pre></p><p>Note that the <code>failAfter</code> method executes the body of the by-name passed to it using the same
thread that invoked <code>failAfter</code>. This means that the same thread will run the <code>withFixture</code> method
as well as each test, so no extra synchronization is required. A second thread is used to run a timer, and if the timeout
expires, that second thread will attempt to interrupt the main test thread via the <code>defaultTestInterruptor</code>.</p><p>The <code>timeLimit</code> field is abstract in this trait. Thus you must specify a time limit when you use it.
For example, the following code specifies that each test must complete within 200 milliseconds:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.concurrent.DeprecatedTimeLimitedTests
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">DeprecatedTimeLimitedTests</span> {
<br/>  <span class="stLineComment">// Note: You may need to either write 200.millis or (200 millis), or</span>
  <span class="stLineComment">// place a semicolon or blank line after plain old 200 millis, to</span>
  <span class="stLineComment">// avoid the semicolon inference problems of postfix operator notation.</span>
  <span class="stReserved">val</span> timeLimit = <span class="stLiteral">200</span> millis
<br/>  describe(<span class="stQuotedString">"A time-limited test"</span>) {
    it(<span class="stQuotedString">"should succeed if it completes within the time limit"</span>) {
      Thread.sleep(<span class="stLiteral">100</span>)
    }
    it(<span class="stQuotedString">"should fail if it is taking too darn long"</span>) {
      Thread.sleep(<span class="stLiteral">300</span>)
    }
  }
}
</pre></p><p>If you run the above <code>ExampleSpec</code>, the second test will fail with the error message:</p><p><code>The test did not complete within the specified 200 millisecond time limit.</code></p><p>The <code>failAfter</code> method uses an <code>Interruptor</code> to attempt to interrupt the main test thread if the timeout
expires. The default <code>Interruptor</code> returned by the <code>defaultTestInterruptor</code> method is a
<a href="ThreadInterruptor$.html"><code>ThreadInterruptor</code></a>, which calls <code>interrupt</code> on the main test thread. If you wish to change this
interruption strategy, override <code>defaultTestInterruptor</code> to return a different <code>Interruptor</code>. For example,
here's how you'd change the default to <a href="DoNotInterrupt$.html"><code>DoNotInterrupt</code></a>, a very patient interruption strategy that does nothing to
interrupt the main test thread:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.concurrent.DeprecatedTimeLimitedTests
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">DeprecatedTimeLimitedTests</span> {
<br/>  <span class="stReserved">val</span> timeLimit = <span class="stLiteral">200</span> millis
<br/>  <span class="stReserved">override</span> <span class="stReserved">val</span> defaultTestInterruptor = <span class="stType">DoNotInterrupt</span>
<br/>  describe(<span class="stQuotedString">"A time-limited test"</span>) {
    it(<span class="stQuotedString">"should succeed if it completes within the time limit"</span>) {
      Thread.sleep(<span class="stLiteral">100</span>)
    }
    it(<span class="stQuotedString">"should fail if it is taking too darn long"</span>) {
      Thread.sleep(<span class="stLiteral">300</span>)
    }
  }
}
</pre></p><p>Like the previous incarnation of <code>ExampleSuite</code>, the second test will fail with an error message that indicates
a timeout expired. But whereas in the previous case, the <code>Thread.sleep</code> would be interrupted after 200 milliseconds,
in this case it is never interrupted. In the previous case, the failed test requires a little over 200 milliseconds to run.
In this case, because the <code>sleep(300)</code> is never interrupted, the failed test requires a little over 300 milliseconds
to run.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>DeprecatedTimeLimitedTests is deprecated and will be removed in a future version of ScalaTest. Please use TimeLimitedTests instead.</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Interruptor" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InterruptorextendsThread=&gt;Unit"></a>
      <a id="Interruptor:Interruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Interruptor.html"><span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Signaler instead.">Interruptor</span></a><span class="result"> extends (<span class="extype" name="java.lang.Thread">Thread</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@InterruptorextendsThread=&gt;Unit" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for interrupting an operation after a timeout expires.</p><div class="fullcomment"><div class="comment cmt"><p>Strategy for interrupting an operation after a timeout expires.</p><p>An instance of this trait is used for configuration when using traits
<a href="Timeouts.html"><code>Timeouts</code></a> and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Signaler instead.</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.SelectorInterruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SelectorInterruptorextendsInterruptor"></a>
      <a id="SelectorInterruptor:SelectorInterruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SelectorInterruptor.html"><span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Signaler instead.">SelectorInterruptor</span></a><span class="result"> extends <a href="Interruptor.html" class="extype" name="org.scalatest.concurrent.Interruptor">Interruptor</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SelectorInterruptorextendsInterruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for interrupting an operation in which <code>wakeup</code> is called on the <code>java.nio.channels.Selector</code> passed to
the constructor.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for interrupting an operation in which <code>wakeup</code> is called on the <code>java.nio.channels.Selector</code> passed to
the constructor.</p><p>This class can be used for configuration when using traits <a href="Timeouts.html"><code>Timeouts</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Signaler instead.</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.SocketInterruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SocketInterruptorextendsInterruptor"></a>
      <a id="SocketInterruptor:SocketInterruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SocketInterruptor.html"><span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Signaler instead.">SocketInterruptor</span></a><span class="result"> extends <a href="Interruptor.html" class="extype" name="org.scalatest.concurrent.Interruptor">Interruptor</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SocketInterruptorextendsInterruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for interrupting an operation in which <code>close</code> is called on the <code>java.net.Socket</code> passed to
the constructor.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for interrupting an operation in which <code>close</code> is called on the <code>java.net.Socket</code> passed to
the constructor.</p><p>This class can be used for configuration when using traits <a href="Timeouts.html"><code>Timeouts</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Signaler instead.</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Timeouts" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TimeoutsextendsAnyRef"></a>
      <a id="Timeouts:Timeouts"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Timeouts.html"><span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.TimeLimits instead">Timeouts</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@TimeoutsextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>This trait has been deprecated and will be removed in a later version of ScalaTest. Please use trait
<a href="TimeLimits.scala">TimeLimits</a> instead.</strong> </strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>This trait has been deprecated and will be removed in a later version of ScalaTest. Please use trait
<a href="TimeLimits.scala">TimeLimits</a> instead.</strong></p><p><strong>
<code>TimeLimits</code> differs from <code>Timeouts</code> in two ways. First, its behavior is driven by a <a href=""><code>Timed</code></a>
typeclass, so that it can treat <code>Future</code>s (and <a href="FutureOutcome.html"><code>FutureOutcome</code></a>s) differently than
non-<code>Future</code>s. Second, where <code>Timeouts</code> <code>failAfter</code> and <code>cancelAfter</code> take an implicit
<code>Interruptor</code> strategy, the corresponding methods in <code>TimeLimits</code> take an implicit  <code>Signaler</code> strategy.
Although the <code>Signaler</code> hierarchy corresponds exactly to the <code>Interruptor</code> hierarchy, the default is different.
For <code>Timeouts</code>, the default is <code>ThreadInterruptor</code>; For <code>Signaler</code>, the default is
<code>DoNotSignal</code>.
</strong></p><p>Trait that provides a <code>failAfter</code> and <code>cancelAfter</code> construct, which allows you to specify a time limit for an
operation passed as a by-name parameter, as well as a way to interrupt it if the operation exceeds its time limit.</p><p>The time limit is passed as the first parameter, as a <a href="../time/Span.html"><code>Span</code></a>. The operation is
passed as the second parameter. And an <a href="Interruptor.html"><code>Interruptor</code></a>, a strategy for interrupting the operation, is
passed as an implicit third parameter.  Here's a simple example of its use:</p><p><pre class="stHighlighted">
failAfter(<span class="stType">Span</span>(<span class="stLiteral">100</span>, <span class="stType">Millis</span>)) {
  Thread.sleep(<span class="stLiteral">200</span>)
}
</pre></p><p>The above code, after 100 milliseconds, will produce a <a href="../exceptions/TestFailedDueToTimeoutException.html"><code>TestFailedDueToTimeoutException</code></a> with a message
that indicates a timeout expired:</p><p><code>The code passed to failAfter did not complete within 100 milliseconds.</code></p><p>If you use <code>cancelAfter</code> in place of <code>failAfter</code>, a <a href="../exceptions/TestCanceledException.html"><code>TestCanceledException</code></a> with a message
that indicates a timeout expired:</p><p><code>The code passed to cancelAfter did not complete within 100 milliseconds.</code></p><p>If you prefer you can mix in or import the members of <a href="../time/SpanSugar.html"><code>SpanSugar</code></a> and place a units value after the integer timeout.
Here are some examples:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.time.SpanSugar._
<br/>failAfter(<span class="stLiteral">100</span> millis) {
  Thread.sleep(<span class="stLiteral">200</span>)
}
<br/>failAfter(<span class="stLiteral">1</span> second) {
  Thread.sleep(<span class="stLiteral">2000</span>)
}
</pre></p><p>The code passed via the by-name parameter to <code>failAfter</code> or <code>cancelAfter</code> will be executed by the thread that invoked
<code>failAfter</code> or <code>cancelAfter</code>, so that no synchronization is necessary to access variables declared outside the by-name.</p><p><pre class="stHighlighted">
<span class="stReserved">var</span> result = -<span class="stLiteral">1</span> <span class="stLineComment">// No need to make this volatile</span>
failAfter(<span class="stLiteral">100</span> millis) {
  result = accessNetService()
}
result should be (<span class="stLiteral">99</span>)
</pre></p><p>The <code>failAfter</code> or <code>cancelAfter</code> method will create a timer that runs on a different thread than the thread that
invoked <code>failAfter</code> or <code>cancelAfter</code>, so that it can detect when the timeout has expired and attempt to <em>interrupt</em>
the main thread. Because different operations can require different interruption strategies, the <code>failAfter</code> or <code>cancelAfter</code>
method accepts an implicit third parameter of type <code>Interruptor</code> that is responsible for interrupting
the main thread.</p><p><a name="interruptorConfig"></a></p><h4> Configuring <code>failAfter</code> or <code>cancelAfter</code> with an <code>Interruptor</code> </h4><p>This trait declares an implicit <code>val</code> named <code>defaultInterruptor</code>,
initialized with a <a href="ThreadInterruptor$.html"><code>ThreadInterruptor</code></a>, which attempts to interrupt the main thread by invoking
<code>Thread.interrupt</code>. If you wish to use a different strategy, you can override this <code>val</code> (or hide
it, for example if you imported the members of <code>Timeouts</code> rather than mixing it in). Here's an example
in which the default interruption method is changed to <a href="DoNotInterrupt$.html"><code>DoNotInterrupt</code></a>, which does not attempt to
interrupt the main thread in any way:</p><p><pre class="stHighlighted">
<span class="stReserved">override</span> <span class="stReserved">val</span> defaultInterruptor = <span class="stType">DoNotInterrupt</span>
failAfter(<span class="stLiteral">100</span> millis) {
  Thread.sleep(<span class="stLiteral">500</span>)
}
</pre></p><p>As with the default <code>Interruptor</code>, the above code will eventually produce a
<code>TestFailedDueToTimeoutException</code> with a message that indicates a timeout expired. However, instead
of throwing the exception after approximately 100 milliseconds, it will throw it after approximately 500 milliseconds.</p><p>This illustrates an important feature of <code>failAfter</code> and <code>cancelAfter</code>: it will throw a
<code>TestFailedDueToTimeoutException</code> (or <code>TestCanceledException</code> in case of <code>cancelAfter</code>)
if the code passed as the by-name parameter takes longer than the specified timeout to execute, even if it
is allowed to run to completion beyond the specified timeout and returns normally.</p><p>ScalaTest provides the following <code>Interruptor</code> implementations:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong><code>Interruptor</code> implementation</strong>
</th>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">
<strong>Usage</strong>
</th>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="ThreadInterruptor$.html">ThreadInterruptor</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
The default interruptor, invokes <code>interrupt</code> on the main test thread. This will
set the interrupted status for the main test thread and,
if the main thread is blocked, will in some cases cause the main thread to complete abruptly with
an <code>InterruptedException</code>.
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="DoNotInterrupt$.html">DoNotInterrupt</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Does not attempt to interrupt the main test thread in any way
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="SelectorInterruptor.html">SelectorInterruptor</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Invokes <code>wakeup</code> on the passed <code>java.nio.channels.Selector</code>, which
will cause the main thread, if blocked in <code>Selector.select</code>, to complete abruptly with a
<code>ClosedSelectorException</code>.
</td>
</tr>
<tr>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">
<a href="SocketInterruptor.html">SocketInterruptor</a>
</td>
<td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
Invokes <code>close</code> on the <code>java.io.Socket</code>, which
will cause the main thread, if blocked in a read or write of an <code>java.io.InputStream</code> or
<code>java.io.OutputStream</code> that uses the <code>Socket</code>, to complete abruptly with a
<code>SocketException</code>.
</td>
</tr>
</table></p><p>You may wish to create your own <code>Interruptor</code> in some situations. For example, if your operation is performing
a loop and can check a volatile flag each pass through the loop. You could in that case write an <code>Interruptor</code> that
sets that flag so that the next time around, the loop would exit.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.TimeLimits instead</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="org.scalatest.concurrent.DoNotInterrupt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DoNotInterrupt"></a>
      <a id="DoNotInterrupt:DoNotInterrupt"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="DoNotInterrupt$.html"><span class="name">DoNotInterrupt</span></a><span class="result"> extends <a href="Interruptor.html" class="extype" name="org.scalatest.concurrent.Interruptor">Interruptor</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@DoNotInterrupt" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Interruption strategy in which nothing is done to try and interrupt an operation.</p><div class="fullcomment"><div class="comment cmt"><p>Interruption strategy in which nothing is done to try and interrupt an operation.</p><p>This object can be used for configuration when using traits <a href="Timeouts.html"><code>Timeouts</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.DoNotSignal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DoNotSignal"></a>
      <a id="DoNotSignal:DoNotSignal"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="DoNotSignal$.html"><span class="name">DoNotSignal</span></a><span class="result"> extends <a href="Signaler.html" class="extype" name="org.scalatest.concurrent.Signaler">Signaler</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@DoNotSignal" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Signaling strategy in which nothing is done to try and signal or interrupt an operation.</p><div class="fullcomment"><div class="comment cmt"><p>Signaling strategy in which nothing is done to try and signal or interrupt an operation.</p><p>This object can be used for configuration when using traits <a href="TimeLimits.html"><code>TimeLimits</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.Eventually" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Eventually"></a>
      <a id="Eventually:Eventually"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Eventually$.html"><span class="name">Eventually</span></a><span class="result"> extends <a href="Eventually.html" class="extype" name="org.scalatest.concurrent.Eventually">Eventually</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@Eventually" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Eventually</code> members as
an alternative to mixing in the trait.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Eventually</code> members as
an alternative to mixing in the trait. One use case is to import <code>Eventually</code>'s members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.8.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Matchers._
import Matchers._

scala&gt; import concurrent.Eventually._
import concurrent.Eventually._

scala&gt; val xs = 1 to 125
xs: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..., 125)

scala&gt; val it = xs.iterator
it: Iterator[Int] = non-empty iterator

scala&gt; eventually { it.next should be (3) }

scala&gt; eventually { Thread.sleep(999); it.next should be (3) }
org.scalatest.TestFailedException: The code passed to eventually never returned normally.
    Attempted 2 times, sleeping 10 milliseconds between each attempt.
  at org.scalatest.Eventually$class.tryTryAgain$1(Eventually.scala:313)
  at org.scalatest.Eventually$class.eventually(Eventually.scala:322)
  ...
</pre>
</p></div></div>
    </li><li name="org.scalatest.concurrent.Interruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Interruptor"></a>
      <a id="Interruptor:Interruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Interruptor$.html"><span class="name">Interruptor</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@Interruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for an <code>Interruptor</code> defined
in terms of a function from a function of type <code>Thread</code> to </code>Unit</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for an <code>Interruptor</code> defined
in terms of a function from a function of type <code>Thread</code> to </code>Unit</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.PatienceConfiguration" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="PatienceConfiguration"></a>
      <a id="PatienceConfiguration:PatienceConfiguration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="PatienceConfiguration$.html"><span class="name">PatienceConfiguration</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@PatienceConfiguration" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="org.scalatest.concurrent.ScalaFutures" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ScalaFutures"></a>
      <a id="ScalaFutures:ScalaFutures"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ScalaFutures$.html"><span class="name">ScalaFutures</span></a><span class="result"> extends <a href="ScalaFutures.html" class="extype" name="org.scalatest.concurrent.ScalaFutures">ScalaFutures</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ScalaFutures" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>ScalaFutures</code> members as
an alternative to mixing in the trait.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>ScalaFutures</code> members as
an alternative to mixing in the trait. One use case is to import <code>ScalaFutures</code>'s members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.concurrent.SelectorInterruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SelectorInterruptor"></a>
      <a id="SelectorInterruptor:SelectorInterruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="SelectorInterruptor$.html"><span class="name">SelectorInterruptor</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SelectorInterruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for a <code>SelectorInterruptor</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for a <code>SelectorInterruptor</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.SelectorSignaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SelectorSignaler"></a>
      <a id="SelectorSignaler:SelectorSignaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="SelectorSignaler$.html"><span class="name">SelectorSignaler</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SelectorSignaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for a <code>SelectorSignaler</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for a <code>SelectorSignaler</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.Signaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Signaler"></a>
      <a id="Signaler:Signaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Signaler$.html"><span class="name">Signaler</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@Signaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for a <code>Singlaer</code> defined
in terms of a function from a function of type <code>Thread</code> to </code>Unit</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for a <code>Singlaer</code> defined
in terms of a function from a function of type <code>Thread</code> to </code>Unit</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.SocketInterruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SocketInterruptor"></a>
      <a id="SocketInterruptor:SocketInterruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="SocketInterruptor$.html"><span class="name">SocketInterruptor</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SocketInterruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for a <code>SocketInterruptor</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for a <code>SocketInterruptor</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.SocketSignaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SocketSignaler"></a>
      <a id="SocketSignaler:SocketSignaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="SocketSignaler$.html"><span class="name">SocketSignaler</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@SocketSignaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that provides a factory method for a <code>SocketSignaler</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that provides a factory method for a <code>SocketSignaler</code>.
</p></div></div>
    </li><li name="org.scalatest.concurrent.ThreadSignaler" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ThreadSignaler"></a>
      <a id="ThreadSignaler:ThreadSignaler"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ThreadSignaler$.html"><span class="name">ThreadSignaler</span></a><span class="result"> extends <a href="Signaler.html" class="extype" name="org.scalatest.concurrent.Signaler">Signaler</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ThreadSignaler" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for signaling an operation in which <code>interrupt</code> is called on the <code>Thread</code> passed
to <code>apply</code>.</code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for signaling an operation in which <code>interrupt</code> is called on the <code>Thread</code> passed
to <code>apply</code>.</p><p>This object can be used for configuration when using traits <a href="TimeLimits.html"><code>TimeLimits</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div></div>
    </li><li name="org.scalatest.concurrent.TimeLimits" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TimeLimits"></a>
      <a id="TimeLimits:TimeLimits"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="TimeLimits$.html"><span class="name">TimeLimits</span></a><span class="result"> extends <a href="TimeLimits.html" class="extype" name="org.scalatest.concurrent.TimeLimits">TimeLimits</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@TimeLimits" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Timeouts</code> members as
an alternative to mixing in the trait.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Timeouts</code> members as
an alternative to mixing in the trait. One use case is to import <code>Timeouts</code>'s members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.concurrent.Timeouts" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Timeouts"></a>
      <a id="Timeouts:Timeouts"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Timeouts$.html"><span class="name">Timeouts</span></a><span class="result"> extends <a href="Timeouts.html" class="extype" name="org.scalatest.concurrent.Timeouts">Timeouts</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@Timeouts" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Timeouts</code> members as
an alternative to mixing in the trait.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Timeouts</code> members as
an alternative to mixing in the trait. One use case is to import <code>Timeouts</code>'s members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.concurrent.Waiters" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Waiters"></a>
      <a id="Waiters:Waiters"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Waiters$.html"><span class="name">Waiters</span></a><span class="result"> extends <a href="Waiters.html" class="extype" name="org.scalatest.concurrent.Waiters">Waiters</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@Waiters" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Waiters</code> members as
an alternative to mixing in the trait.</code></p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Waiters</code> members as
an alternative to mixing in the trait. One use case is to import <code>Waiters</code>'s members so you can use
them in the Scala interpreter.
</p></div></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="org.scalatest.concurrent#AsyncAssertions" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AsyncAssertions:org.scalatest.concurrent.Waiters.type"></a>
      <a id="AsyncAssertions:Waiters.type"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Waiters instead">AsyncAssertions</span><span class="result">: <a href="Waiters$.html" class="extype" name="org.scalatest.concurrent.Waiters">Waiters</a>.type</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@AsyncAssertions:org.scalatest.concurrent.Waiters.type" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>The name <code>org.scalatest.concurrent.AsyncAssertions</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.concurrent.Waiters</code>, instead.</strong> </strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalatest.concurrent.AsyncAssertions</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.concurrent.Waiters</code>, instead.</strong></p><p>We deprecate this name because this is blocking while our new asynchronous style traits are not, thus could potentially cause some confusion.
Another reason is that this name sounds like it is a subclass of Assertions, while it is not.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Waiters instead</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.ThreadInterruptor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ThreadInterruptor"></a>
      <a id="ThreadInterruptor:ThreadInterruptor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ThreadInterruptor$.html"><span class="name deprecated" title="Deprecated: Please use org.scalatest.concurrent.Signaler instead.">ThreadInterruptor</span></a><span class="result"> extends <a href="Interruptor.html" class="extype" name="org.scalatest.concurrent.Interruptor">Interruptor</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.concurrent.package@ThreadInterruptor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Strategy for interrupting an operation in which <code>interrupt</code> is called on the <code>Thread</code> passed
to <code>apply</code>.</code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Strategy for interrupting an operation in which <code>interrupt</code> is called on the <code>Thread</code> passed
to <code>apply</code>.</p><p>This object can be used for configuration when using traits <a href="Timeouts.html"><code>Timeouts</code></a>
and <a href="TimeLimitedTests.html"><code>TimeLimitedTests</code></a>.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.concurrent.Signaler instead.</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
