<!DOCTYPE html >
<html>
        <head>
          <title>fixture - ScalaTest 3.0.3 - org.scalatest.fixture</title>
          <meta name="description" content="fixture - ScalaTest 3.0.3 - org.scalatest.fixture" />
          <meta name="keywords" content="fixture ScalaTest 3.0.3 org.scalatest.fixture" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'org.scalatest.fixture.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NJWCS90VG5"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-NJWCS90VG5');

</script>
        </head>
        <body class="value">

<!-- Top of doc.scalatest.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/4ca150665e51d0b1c3890ca1b891c507-ads.js?product=ScalaTest"></script>

      <div id="definition">
        <img alt="Package" src="../../../lib/package_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="org">org</a>.<a href="../package.html" class="extype" name="org.scalatest">scalatest</a></p>
        <h1>fixture</h1><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">fixture</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.scalatest.fixture.AsyncConfigMapFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncConfigMapFixtureextendsAnyRef"></a>
      <a id="AsyncConfigMapFixture:AsyncConfigMapFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncConfigMapFixture.html"><span class="name">AsyncConfigMapFixture</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncConfigMapFixtureextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <a href="AsyncTestSuite.html"><code>fixture.AsyncTestSuite</code></a> passes
the config map passed to <code>runTest</code> as a fixture into each test.</code></a></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="AsyncTestSuite.html"><code>fixture.AsyncTestSuite</code></a> passes
the config map passed to <code>runTest</code> as a fixture into each test.</p><p>Here's an example in which tests just check to make sure <code>"hello"</code> and <code>"world"</code>
are defined keys in the config map:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.configmapfixture
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleAsyncSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">fixture.AsyncConfigMapFixture</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stQuotedString">"The config map"</span> should <span class="stQuotedString">"contain hello"</span> in { configMap =&gt;
    <span class="stLineComment">// Use the configMap passed to runTest in the test</span>
    configMap should contain key <span class="stQuotedString">"hello"</span>
  }
<br/>  it should <span class="stQuotedString">"contain world"</span> in { configMap =&gt;
    configMap should contain key <span class="stQuotedString">"world"</span>
  }
}
</pre></p><p>If you run this class without defining <code>"hello"</code> and <code>"world"</code>
in the confg map, the tests will fail:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
The config map</span>
<span class="stRed">- should contain hello *** FAILED ***
  Map() did not contain key "hello" (<console>:20)
- should contain world *** FAILED ***
  Map() did not contain key "world" (<console>:24)</span>
</pre></p><p>If you do define <code>"hello"</code> and <code>"world"</code> keys
in the confg map, the tests will success:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec, configMap = Map("hello" -&gt; "hi", "world" -&gt; "globe"))
<span class="stGreen">ExampleSpec:
The config map
- should contain hello
- should contain world</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFeatureSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFeatureSpecextendsAsyncFeatureSpecLike"></a>
      <a id="AsyncFeatureSpec:AsyncFeatureSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncFeatureSpec.html"><span class="name">AsyncFeatureSpec</span></a><span class="result"> extends <a href="AsyncFeatureSpecLike.html" class="extype" name="org.scalatest.fixture.AsyncFeatureSpecLike">AsyncFeatureSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFeatureSpecextendsAsyncFeatureSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncFeatureSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncFeatureSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncFeatureSpec</code> in situations for which <a href="../AsyncFeatureSpec.html"><code>AsyncFeatureSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncFeatureSpec</code> is intended for use in special situations, with class <code>AsyncFeatureSpec</code> used for general needs. For
more insight into where <code>fixture.AsyncFeatureSpec</code> fits in the big picture, see the <a href="../AsyncFeatureSpec.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncFeatureSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncFeatureSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncFeatureSpec</code> behaves similarly to class <code>org.scalatest.AsyncFeatureSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncFeatureSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) => sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> => sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to reason about!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      }
    }
  }
}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
* <span class="stReserved">package</span> org.scalatest.examples.fixture.asyncfeaturespec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"Testing should be easy to write"</span>) { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"easy to write!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is easy to write!"</span>)
      }
    }
<br/>    scenario(<span class="stQuotedString">"Testing should be fun"</span>) { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"fun to write!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is fun to write!"</span>)
      }
    }
<br/>    <span class="stLineComment">// This test doesn't need a Db</span>
    scenario(<span class="stQuotedString">"Testing code should be clear"</span>) { () =&gt;
      <span class="stType">Future</span> {
        <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
        buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
        buf.append(<span class="stQuotedString">"clear!"</span>)
        assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
      }
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFeatureSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFeatureSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncFeatureSpecLike:AsyncFeatureSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncFeatureSpecLike.html"><span class="name">AsyncFeatureSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFeatureSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncFeatureSpec</code>, which is
a sister class to <a href="../AsyncFeatureSpec.html"><code>org.scalatest.AsyncFeatureSpec</code></a> that can pass a
fixture object into its tests.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncFeatureSpec</code>, which is
a sister class to <a href="../AsyncFeatureSpec.html"><code>org.scalatest.AsyncFeatureSpec</code></a> that can pass a
fixture object into its tests.</p><p><a href="AsyncFeatureSpec.html"><code>fixture.AsyncFeatureSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncFeatureSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncFeatureSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFeatureSpec.html">detailed
overview of <code>fixture.AsyncFeatureSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFlatSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFlatSpecextendsAsyncFlatSpecLike"></a>
      <a id="AsyncFlatSpec:AsyncFlatSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncFlatSpec.html"><span class="name">AsyncFlatSpec</span></a><span class="result"> extends <a href="AsyncFlatSpecLike.html" class="extype" name="org.scalatest.fixture.AsyncFlatSpecLike">AsyncFlatSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFlatSpecextendsAsyncFlatSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncFlatSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncFlatSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncFlatSpec</code> in situations for which <a href="../AsyncFlatSpec.html"><code>AsyncFlatSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncFlatSpec</code> is intended for use in special situations, with class <code>AsyncFlatSpec</code> used for general needs. For
more insight into where <code>fixture.AsyncFlatSpec</code> fits in the big picture, see the <a href="../AsyncFlatSpec.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncFlatSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncFlatSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncFlatSpec</code> behaves similarly to class <code>org.scalatest.AsyncFlatSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncFlatSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) => sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> => sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFlatSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in { actor =>
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =>
      assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { actor =>
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =>
      assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.asyncflatspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"should be easy"</span> in { db =&gt;
    <span class="stType">Future</span> {
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { db =&gt;
    <span class="stType">Future</span> {
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be clear"</span> in { () =&gt;
    <span class="stType">Future</span> {
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFlatSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFlatSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncFlatSpecLike:AsyncFlatSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncFlatSpecLike.html"><span class="name">AsyncFlatSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="../words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="../words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFlatSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncFlatSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFlatSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncFlatSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFlatSpec</code> that can pass a
fixture object into its tests.</p><p><a href="AsyncFlatSpec.html"><code>fixture.AsyncFlatSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncFlatSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncFlatSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFlatSpec.html">detailed
overview of <code>fixture.AsyncFlatSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFreeSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFreeSpecextendsAsyncFreeSpecLike"></a>
      <a id="AsyncFreeSpec:AsyncFreeSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncFreeSpec.html"><span class="name">AsyncFreeSpec</span></a><span class="result"> extends <a href="AsyncFreeSpecLike.html" class="extype" name="org.scalatest.fixture.AsyncFreeSpecLike">AsyncFreeSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFreeSpecextendsAsyncFreeSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncFunSpec</code> in situations for which <a href="../AsyncFunSpec.html"><code>AsyncFunSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncFunSpec</code> is intended for use in special situations, with class <code>AsyncFunSpec</code> used for general needs. For
more insight into where <code>fixture.AsyncFunSpec</code> fits in the big picture, see the <a href="../AsyncFunSpec.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncFunSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncFunSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncFunSpec</code> behaves similarly to class <code>org.scalatest.AsyncFunSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncFunSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) => sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> => sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFreeSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.asyncfreespec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/> <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"easy!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"fun!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
<br/>    <span class="stLineComment">// This test doesn't need a Db</span>
    <span class="stQuotedString">"code should be clear"</span> in { () =&gt;
      <span class="stType">Future</span> {
        <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
        buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
        buf.append(<span class="stQuotedString">"clear!"</span>)
        assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
      }
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFreeSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFreeSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncFreeSpecLike:AsyncFreeSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncFreeSpecLike.html"><span class="name">AsyncFreeSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFreeSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncFreeSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFreeSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncFreeSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFreeSpec</code> that can pass a
fixture object into its tests.</p><p><a href="AsyncFreeSpec.html"><code>fixture.AsyncFreeSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncFreeSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncFreeSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFreeSpec.html">detailed
overview of <code>fixture.AsyncFreeSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFunSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSpecextendsAsyncFunSpecLike"></a>
      <a id="AsyncFunSpec:AsyncFunSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncFunSpec.html"><span class="name">AsyncFunSpec</span></a><span class="result"> extends <a href="AsyncFunSpecLike.html" class="extype" name="org.scalatest.fixture.AsyncFunSpecLike">AsyncFunSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFunSpecextendsAsyncFunSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncFunSpec</code> in situations for which <a href="../AsyncFunSpec.html"><code>AsyncFunSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncFunSpec</code> is intended for use in special situations, with class <code>AsyncFunSpec</code> used for general needs. For
more insight into where <code>fixture.AsyncFunSpec</code> fits in the big picture, see the <a href="../AsyncFunSpec.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncFunSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncFunSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncFunSpec</code> behaves similarly to class <code>org.scalatest.AsyncFunSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncFunSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) => sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> => sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.asyncfunspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  describe(<span class="stQuotedString">"testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"easy!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"fun!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
<br/>    <span class="stLineComment">// This test doesn't need a Db</span>
    it(<span class="stQuotedString">"code should be clear"</span>) { () =&gt;
      <span class="stType">Future</span> {
        <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
        buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
        buf.append(<span class="stQuotedString">"clear!"</span>)
        assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
      }
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFunSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncFunSpecLike:AsyncFunSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncFunSpecLike.html"><span class="name">AsyncFunSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFunSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncFunSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncFunSpec</code>, which is
a sister class to <code>org.scalatest.AsyncFunSpec</code> that can pass a
fixture object into its tests.</p><p><a href="AsyncFunSpec.html"><code>fixture.AsyncFunSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncFunSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncFunSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFunSpec.html">detailed
overview of <code>fixture.AsyncFunSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFunSuite" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSuiteextendsAsyncFunSuiteLike"></a>
      <a id="AsyncFunSuite:AsyncFunSuite"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncFunSuite.html"><span class="name">AsyncFunSuite</span></a><span class="result"> extends <a href="AsyncFunSuiteLike.html" class="extype" name="org.scalatest.fixture.AsyncFunSuiteLike">AsyncFunSuiteLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFunSuiteextendsAsyncFunSuiteLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncFunSuite</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncFunSuite</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncFunSuite</code> in situations for which <a href="../AsyncFunSuite.html"><code>AsyncFunSuite</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncFunSuite</code> is intended for use in special situations, with class <code>AsyncFunSuite</code> used for general needs. For
more insight into where <code>fixture.AsyncFunSuite</code> fits in the big picture, see the <a href="../AsyncFunSuite.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncFunSuite.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncFunSuite</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncFunSuite</code> behaves similarly to class <code>org.scalatest.AsyncFunSuite</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncFunSuite</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> java.io._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSuite</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.asyncfunsuite.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  test(<span class="stQuotedString">"testing should be easy"</span>) { db =&gt;
    <span class="stType">Future</span> {
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"testing should be fun"</span>) { db =&gt;
    <span class="stType">Future</span> {
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  test(<span class="stQuotedString">"test code should be clear"</span>) { () =&gt;
    <span class="stType">Future</span> {
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncFunSuiteLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSuiteLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncFunSuiteLike:AsyncFunSuiteLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncFunSuiteLike.html"><span class="name">AsyncFunSuiteLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncFunSuiteLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncFunSuite</code>, which is
a sister class to <code>org.scalatest.AsyncFunSuite</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncFunSuite</code>, which is
a sister class to <code>org.scalatest.AsyncFunSuite</code> that can pass a
fixture object into its tests.</p><p><a href="AsyncFunSuite.html"><code>fixture.AsyncFunSuite</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncFunSuite</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncFunSuite</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFunSuite.html">detailed
overview of <code>fixture.AsyncFunSuite</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncTestDataFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTestDataFixtureextendsAnyRef"></a>
      <a id="AsyncTestDataFixture:AsyncTestDataFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncTestDataFixture.html"><span class="name">AsyncTestDataFixture</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncTestDataFixtureextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <a href="AsyncTestSuite.html"><code>fixture.AsyncTestSuite</code></a> passes the
<a href="../TestData.html"><code>TestData</code></a> passed to <code>withFixture</code> as a fixture into each test.</code></a></a></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="AsyncTestSuite.html"><code>fixture.AsyncTestSuite</code></a> passes the
<a href="../TestData.html"><code>TestData</code></a> passed to <code>withFixture</code> as a fixture into each test.</p><p>For example, here's how you could access the test's name in each test using <code>AsyncTestDataFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.testdatafixture
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleAsyncSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">fixture.AsyncTestDataFixture</span> {
<br/>  <span class="stQuotedString">"Accessing the test data"</span> should <span class="stQuotedString">"be easy!"</span> in { td =&gt;
    assert(td.name == <span class="stQuotedString">"Accessing the test data should be easy!"</span>)
  }
<br/>  it should <span class="stQuotedString">"be fun!"</span> in { td =&gt;
    assert(td.name == <span class="stQuotedString">"Accessing the test data should be fun!"</span>)
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncTestRegistration" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTestRegistrationextendsAnyRef"></a>
      <a id="AsyncTestRegistration:AsyncTestRegistration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncTestRegistration.html"><span class="name">AsyncTestRegistration</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncTestRegistrationextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait declaring methods that can be used to register test functions that accept
a fixture parameter and have result type <code>Future[Assertion]</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait declaring methods that can be used to register test functions that accept
a fixture parameter and have result type <code>Future[Assertion]</code>.
</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncTestSuite" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTestSuiteextendsSuitewithAsyncTestSuite"></a>
      <a id="AsyncTestSuite:AsyncTestSuite"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncTestSuite.html"><span class="name">AsyncTestSuite</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.fixture.Suite">Suite</a> with <a href="../AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">scalatest.AsyncTestSuite</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncTestSuiteextendsSuitewithAsyncTestSuite" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The base trait of ScalaTest's &quot;fixture&quot; async testing styles, which enable you to pass fixture objects into tests.</p><div class="fullcomment"><div class="comment cmt"><p>The base trait of ScalaTest's &quot;fixture&quot; async testing styles, which enable you to pass fixture objects into tests.</p><p>This trait provides a final override of <code>withFixture(OneArgTest)</code>, declared in
supertrait <code>fixture.Suite</code>, because the <code>withFixture(OneArgTest)</code> lifecycle
method assumes synchronous testing. Here is its signature:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>): <span class="stType">Outcome</span>
</pre></p><p>The test function interface, <a href="Suite$OneArgTest.html"><code>OneArgTest</code></a>, offers an <code>apply</code> method
that takes a <code>FixtureParam</code> and returns <a href="Outcome.html"><code>Outcome</code></a>:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In trait OneArgTest:</span>
<span class="stReserved">def</span> apply(fixture: <span class="stType">FixtureParam</span>): <span class="stType">Outcome</span>
</pre></p><p>Because the result of a test is an <code>Outcome</code>, when the test function returns, the test body must have determined an outcome already. It
will already be one of <a href="../Succeeded$.html"><code>Succeeded</code></a>, <a href="../Failed.html"><code>Failed</code></a>, <a href="../Canceled.html"><code>Canceled</code></a>, or <a href="../Pending$.html"></code>Pending</code></a>. This is
also true when <code>withFixture(OneArgTest)</code> returns: because the result type of <code>withFixture(OneArgTest)</code> is <code>Outcome</code>,
the test body has by definition has already finished execution.</p><p>This trait overrides and makes abstract the <code>runTest</code> method. Subtraits must
must implement this method to call <code>withFixture(OneArgAsyncTest)</code> instead of <code>withFixture(OneArgTest)</code>,
where <code>withFixture(OneArgAsyncTest)</code> is a new method declared in this trait with the following
signature and implementation:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>Instead of returning <code>Outcome</code> like <code>withFixture</code>, the <code>withFixture</code> method
returns a <code>FutureOutcome</code>. Similarly, the <code>apply</code> method of test function interface,
<code>OneArgAsyncTest</code>, returns <code>FutureOutcome</code>:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In trait OneArgAsyncTest:</span>
<span class="stReserved">def</span> apply(fixture: <span class="stType">FixtureParam</span>): <span class="stType">FutureOutcome</span>
</pre></p><p>The <code>withFixture</code> method supports async testing, because when the test function returns,
the test body has not necessarily finished execution.</p><p>The recommended way to ensure cleanup is performed after a test body finishes execution is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait
<a href="../CompleteLastly.html"><code>org.scalatest.CompleteLastly</code></a>, which will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre class="stHighlighted">
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Thus, the recommended structure of a <code>withFixture</code> implementation that performs cleanup looks like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">val</span> theFixture = ...
<br/>  complete {
    withFixture(test.toNoArgAsyncTest(theFixture)) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">val</span> theFixture = ...
<br/>  withFixture(test.toNoArgAsyncTest(theFixture)) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code> registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failure)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callaback using <code>onSuccess</code>,
like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">val</span> theFixture = ...
<br/>  <span class="stReserved">val</span> futureOutcome =
      withFixture(test.toNoArgAsyncTest(theFixture)) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome onFailedThen { _ =&gt;
    <span class="stLineComment">// perform action that you want to occur</span>
    <span class="stLineComment">// only if a test fails here</span>
  }
}
</pre></p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">val</span> theFixture = ...
<br/>  <span class="stReserved">val</span> futureOutcome =
      withFixture(test.toNoArgAsyncTest(theFixture)) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will only return a <code>Failure</code> if
the test completes abruptly with an exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such suite-aborting exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned in a <code>Failure</code>.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncWordSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncWordSpecextendsAsyncWordSpecLike"></a>
      <a id="AsyncWordSpec:AsyncWordSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AsyncWordSpec.html"><span class="name">AsyncWordSpec</span></a><span class="result"> extends <a href="AsyncWordSpecLike.html" class="extype" name="org.scalatest.fixture.AsyncWordSpecLike">AsyncWordSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncWordSpecextendsAsyncWordSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.AsyncWordSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.AsyncWordSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.AsyncWordSpec</code> in situations for which <a href="../AsyncWordSpec.html"><code>AsyncWordSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.AsyncWordSpec</code> is intended for use in special situations, with class <code>AsyncWordSpec</code> used for general needs. For
more insight into where <code>fixture.AsyncWordSpec</code> fits in the big picture, see the <a href="../AsyncWordSpec.html#withFixtureOneArgAsyncTest"><code>withFixture(OneArgAsyncTest)</code></a> subsection of the <a href="../AsyncWordSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>AsyncWordSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.AsyncWordSpec</code> behaves similarly to class <code>org.scalatest.AsyncWordSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgAsyncTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgAsyncTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgAsyncTest)</code>, passing
in the test code to run via the <code>OneArgAsyncTest</code> argument. The <code>withFixture(OneArgAsyncTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.AsyncWordSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgAsyncTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) => sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> => sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncWordSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in { actor =>
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =>
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If a test fails, the future returned by the <code>OneArgAsyncTest</code> function will result in
an <a href="../Failed.html" class="extype" name="org.scalatest.Failed">org.scalatest.Failed</a> wrapping the exception describing
the failure. To ensure clean up happens even if a test fails, you should invoke the test function and do the cleanup using
<code>complete</code>-<code>lastly</code>, as shown in the previous example. The <code>complete</code>-<code>lastly</code> syntax, defined in <code>CompleteLastly</code>, which is extended by <code>AsyncTestSuite</code>, ensures
the second, cleanup block of code is executed, whether the the first block throws an exception or returns a future. If it returns a
future, the cleanup will be executed when the future completes.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgAsyncTest)</code>
implementations in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your
integration tests use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait
that creates a database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in
the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.asyncwordspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    complete {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgAsyncTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"easy!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in { db =&gt;
      <span class="stType">Future</span> {
        db.append(<span class="stQuotedString">"fun!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
<br/>  <span class="stQuotedString">"Testing code"</span> should {
    <span class="stLineComment">// This test doesn't need a Db</span>
    <span class="stQuotedString">"be clear"</span> in { () =&gt;
      <span class="stType">Future</span> {
        <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
        buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
        buf.append(<span class="stQuotedString">"clear!"</span>)
        assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
      }
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgAsyncTest)</code>. It will instead directly invoke <code>withFixture(NoArgAsyncTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.AsyncWordSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncWordSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="AsyncWordSpecLike:AsyncWordSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AsyncWordSpecLike.html"><span class="name">AsyncWordSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.fixture.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.fixture.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="../words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="../words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="../words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@AsyncWordSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.AsyncWordSpec</code>, which is
a sister class to <a href="../AsyncWordSpec.html"><code>org.scalatest.AsyncWordSpec</code></a> that can pass a
fixture object into its tests.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.AsyncWordSpec</code>, which is
a sister class to <a href="../AsyncWordSpec.html"><code>org.scalatest.AsyncWordSpec</code></a> that can pass a
fixture object into its tests.</p><p><a href="AsyncWordSpec.html"><code>fixture.AsyncWordSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.AsyncWordSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.AsyncWordSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncWordSpec.html">detailed
overview of <code>fixture.AsyncWordSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.ConfigMapFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ConfigMapFixtureextendsAnyRef"></a>
      <a id="ConfigMapFixture:ConfigMapFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ConfigMapFixture.html"><span class="name">ConfigMapFixture</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@ConfigMapFixtureextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <a href="Suite.html"><code>fixture.Suite</code></a> passes
the config map passed to <code>runTest</code> as a fixture into each test.</code></a></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="Suite.html"><code>fixture.Suite</code></a> passes
the config map passed to <code>runTest</code> as a fixture into each test.</p><p>Here's an example in which tests just check to make sure <code>"hello"</code> and <code>"world"</code>
are defined keys in the config map:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.configmapfixture
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> <span class="stReserved">with</span> <span class="stType">fixture.ConfigMapFixture</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stQuotedString">"The config map"</span> should <span class="stQuotedString">"contain hello"</span> in { configMap =&gt;
    <span class="stLineComment">// Use the configMap passed to runTest in the test</span>
    configMap should contain key <span class="stQuotedString">"hello"</span>
  }
<br/>  it should <span class="stQuotedString">"contain world"</span> in { configMap =&gt;
    configMap should contain key <span class="stQuotedString">"world"</span>
  }
}
</pre></p><p>If you run this class without defining <code>"hello"</code> and <code>"world"</code>
in the confg map, the tests will fail:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
The config map</span>
<span class="stRed">- should contain hello *** FAILED ***
  Map() did not contain key "hello" (<console>:20)
- should contain world *** FAILED ***
  Map() did not contain key "world" (<console>:24)</span>
</pre></p><p>If you do define <code>"hello"</code> and <code>"world"</code> keys
in the confg map, the tests will success:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec, configMap = Map("hello" -&gt; "hi", "world" -&gt; "globe"))
<span class="stGreen">ExampleSpec:
The config map
- should contain hello
- should contain world</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.fixture.FeatureSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FeatureSpecextendsFeatureSpecLike"></a>
      <a id="FeatureSpec:FeatureSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FeatureSpec.html"><span class="name">FeatureSpec</span></a><span class="result"> extends <a href="FeatureSpecLike.html" class="extype" name="org.scalatest.fixture.FeatureSpecLike">FeatureSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FeatureSpecextendsFeatureSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FeatureSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FeatureSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.FeatureSpec</code> in situations for which <a href="../FeatureSpec.html"><code>FeatureSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.FeatureSpec</code> is intended for use in special situations, with class <code>FeatureSpec</code> used for general needs. For
more insight into where <code>fixture.FeatureSpec</code> fits in the big picture, see the <a href="../FeatureSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../FeatureSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>FeatureSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.FeatureSpec</code> behaves similarly to class <code>org.scalatest.FeatureSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This trait also has an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.FeatureSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FeatureSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is designed to be "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"encourage clear code!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">49</span>)
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"be easy to reason about!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">52</span>)
    }
  }
}
</pre></p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception describing the failure.
To ensure clean up happens even if a test fails, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.featurespec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is designed to "</span>)
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
<br/>    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) { db =&gt;
      db.append(<span class="stQuotedString">"encourage clear code!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) { db =&gt;
      db.append(<span class="stQuotedString">"be easy to reason about!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
    }
<br/>    scenario(<span class="stQuotedString">"User needs to write tests"</span>) { () =&gt;
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest is designed to be "</span>)
      buf.append(<span class="stQuotedString">"easy to learn!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to learn!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSpec</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>Test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSpec</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.FeatureSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FeatureSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FeatureSpecLike:FeatureSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FeatureSpecLike.html"><span class="name">FeatureSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FeatureSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.FeatureSpec</code>, which is
a sister class to <a href="../FeatureSpec.html"><code>org.scalatest.FeatureSpec</code></a> that can pass a
fixture object into its tests.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.FeatureSpec</code>, which is
a sister class to <a href="../FeatureSpec.html"><code>org.scalatest.FeatureSpec</code></a> that can pass a
fixture object into its tests.</p><p><a href="FeatureSpec.html"><code>fixture.FeatureSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.FeatureSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.FeatureSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FeatureSpec.html">detailed
overview of <code>fixture.FeatureSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.FlatSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FlatSpecextendsFlatSpecLike"></a>
      <a id="FlatSpec:FlatSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FlatSpec.html"><span class="name">FlatSpec</span></a><span class="result"> extends <a href="FlatSpecLike.html" class="extype" name="org.scalatest.fixture.FlatSpecLike">FlatSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FlatSpecextendsFlatSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FlatSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FlatSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.FlatSpec</code> in situations for which <a href="../FlatSpec.html"><code>FlatSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.FlatSpec</code> is intended for use in special situations, with class <code>FlatSpec</code> used for general needs. For
more insight into where <code>fixture.FlatSpec</code> fits in the big picture, see the <a href="../FlatSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../FlatSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>FlatSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.FlatSpec</code> behaves similarly to class <code>org.scalatest.FlatSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.FlatSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">"easy!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">"fun!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p><p>If a test fails because of an exception, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception.
To ensure clean up happens even if an exception occurs, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.flatspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be clear"</span> in { () =&gt;
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSpec</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>Test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSpec</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.FlatSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FlatSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FlatSpecLike:FlatSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FlatSpecLike.html"><span class="name">FlatSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="../words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="../words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FlatSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.FlatSpec</code>, which is
a sister class to <code>org.scalatest.FlatSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.FlatSpec</code>, which is
a sister class to <code>org.scalatest.FlatSpec</code> that can pass a
fixture object into its tests.</p><p><a href="FlatSpec.html"><code>fixture.FlatSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.FlatSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.FlatSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FlatSpec.html">detailed
overview of <code>fixture.FlatSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.FreeSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecextendsFreeSpecLike"></a>
      <a id="FreeSpec:FreeSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FreeSpec.html"><span class="name">FreeSpec</span></a><span class="result"> extends <a href="FreeSpecLike.html" class="extype" name="org.scalatest.fixture.FreeSpecLike">FreeSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FreeSpecextendsFreeSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FreeSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FreeSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.FreeSpec</code> in situations for which <a href="../FreeSpec.html"><code>FreeSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.FreeSpec</code> is intended for use in special situations, with class <code>FreeSpec</code> used for general needs. For
more insight into where <code>fixture.FreeSpec</code> fits in the big picture, see the <a href="../FreeSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../FreeSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>FreeSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.FreeSpec</code> behaves similarly to class <code>org.scalatest.FreeSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also has an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.FreeSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FreeSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception describing the failure.
To ensure clean up happens even if a test fails, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.freespec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FreeSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  <span class="stQuotedString">"Test code"</span> - {
    <span class="stQuotedString">"should be clear"</span> in { () =&gt;
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSpec</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>Test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSpec</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.FreeSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FreeSpecLike:FreeSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FreeSpecLike.html"><span class="name">FreeSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FreeSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.FreeSpec</code>, which is
a sister class to <code>org.scalatest.FreeSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.FreeSpec</code>, which is
a sister class to <code>org.scalatest.FreeSpec</code> that can pass a
fixture object into its tests.</p><p><a href="FreeSpec.html"><code>fixture.FreeSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.FreeSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.FreeSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FreeSpec.html">detailed
overview of <code>fixture.FreeSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.FunSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSpecextendsFunSpecLike"></a>
      <a id="FunSpec:FunSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FunSpec.html"><span class="name">FunSpec</span></a><span class="result"> extends <a href="FunSpecLike.html" class="extype" name="org.scalatest.fixture.FunSpecLike">FunSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FunSpecextendsFunSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FunSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FunSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.FunSpec</code> in situations for which <a href="../FunSpec.html"><code>FunSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.FunSpec</code> is intended for use in special situations, with class <code>FunSpec</code> used for general needs. For
more insight into where <code>fixture.FunSpec</code> fits in the big picture, see the <a href="../FunSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../FunSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>FunSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.FunSpec</code> behaves similarly to class <code>org.scalatest.FunSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.FunSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception describing the failure.
To ensure clean up happens even if a test fails, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.funspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { db =&gt;
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { db =&gt;
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  describe(<span class="stQuotedString">"Test code"</span>) {
    it(<span class="stQuotedString">"should be clear"</span>) { () =&gt;
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSpec</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>Test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSpec</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.FunSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FunSpecLike:FunSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FunSpecLike.html"><span class="name">FunSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FunSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.FunSpec</code>, which is
a sister class to <code>org.scalatest.FunSpec</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.FunSpec</code>, which is
a sister class to <code>org.scalatest.FunSpec</code> that can pass a
fixture object into its tests.</p><p><a href="FunSpec.html"><code>fixture.FunSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.FunSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.FunSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FunSpec.html">detailed
overview of <code>fixture.FunSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.FunSuite" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSuiteextendsFunSuiteLike"></a>
      <a id="FunSuite:FunSuite"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FunSuite.html"><span class="name">FunSuite</span></a><span class="result"> extends <a href="FunSuiteLike.html" class="extype" name="org.scalatest.fixture.FunSuiteLike">FunSuiteLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FunSuiteextendsFunSuiteLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FunSuite</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FunSuite</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.FunSuite</code> in situations for which <a href="../FunSuite.html"><code>FunSuite</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.FunSuite</code> is intended for use in special situations, with class <code>FunSuite</code> used for general needs. For
more insight into where <code>fixture.FunSuite</code> fits in the big picture, see the <a href="../FunSuite.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../FunSuite.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>FunSuite</code>.</em>
</td></tr></table></p><p>Class <code>fixture.FunSuite</code> behaves similarly to class <code>org.scalatest.FunSuite</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also contains an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.FunSuite</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSuite</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  test(<span class="stQuotedString">"testing should be easy"</span>) { f =&gt;
    f.writer.write(<span class="stQuotedString">"easy!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br/>  test(<span class="stQuotedString">"testing should be fun"</span>) { f =&gt;
    f.writer.write(<span class="stQuotedString">"fun!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception describing the failure.
To ensure clean up happens even if a test fails, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.funsuite.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSuite</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  test(<span class="stQuotedString">"testing should be easy"</span>) { db =&gt;
    db.append(<span class="stQuotedString">"easy!"</span>)
    assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
  }
<br/>  test(<span class="stQuotedString">"testing should be fun"</span>) { db =&gt;
    db.append(<span class="stQuotedString">"fun!"</span>)
    assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  test(<span class="stQuotedString">"test code should be clear"</span>) { () =&gt;
    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
    buf.append(<span class="stQuotedString">"clear!"</span>)
    assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSuite</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSuite</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.FunSuiteLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSuiteLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FunSuiteLike:FunSuiteLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FunSuiteLike.html"><span class="name">FunSuiteLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@FunSuiteLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.FunSuite</code>, which is
a sister class to <code>org.scalatest.FunSuite</code> that can pass a
fixture object into its tests.</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.FunSuite</code>, which is
a sister class to <code>org.scalatest.FunSuite</code> that can pass a
fixture object into its tests.</p><p><a href="FunSuite.html"><code>fixture.FunSuite</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.FunSuite</code> into some other
class, you can use this trait instead, because class
<code>fixture.FunSuite</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FunSuite.html">detailed
overview of <code>fixture.FunSuite</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.NoArg" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NoArgextendsDelayedInitwith()=&gt;Unit"></a>
      <a id="NoArg:NoArg"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="NoArg.html"><span class="name">NoArg</span></a><span class="result"> extends <span class="extype" name="scala.DelayedInit">DelayedInit</span> with () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@NoArgextendsDelayedInitwith()=&gt;Unit" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A function that takes no parameters (<em>i.e.</em>, a <code>Function0</code> or &quot;no-arg&quot; function) and results in <code>Unit</code>, which when
invoked executes the body of the constructor of the class into which this trait is mixed.</code></code></em></p><div class="fullcomment"><div class="comment cmt"><p>A function that takes no parameters (<em>i.e.</em>, a <code>Function0</code> or &quot;no-arg&quot; function) and results in <code>Unit</code>, which when
invoked executes the body of the constructor of the class into which this trait is mixed.</p><p>This trait extends <code>DelayedInit</code> and defines a <code>delayedInit</code> method that
saves the body of the constructor (passed to <code>delayedInit</code>) for later execution when <code>apply</code> is invoked.</p><p>This trait is somewhat magical and therefore may be challenging for your collegues to understand, so please use it as a last resort only when the
simpler options described in the &quot;<a href="../FlatSpec.html#sharedFixtures">shared fixtures</a>&quot; section of your chosen style trait won't do
the job. <code>NoArg</code> is
intended to address a specific use case that will likely be rare, and is unlikely to be useful outside of its intended use case, but
it is quite handy for its intended use case (described in the next paragraph).
One potential gotcha, for example, is that a subclass's constructor body could in theory be executed multiple times by simply invoking <code>apply</code> multiple
times. In the intended use case for this trait, however, the body will be executed only once.</p><p>The intended use case for this method is (relatively rare) situations in which you want to extend a different instance of the same class
for each test, with the body of the test inheriting the members of that class, and with code executed before and/or after
the body of the test.</p><p>For example, Akka's <code>TestKit</code> class takes an <code>ActorSystem</code>,
which must have a unique name. To run a suite of tests in parallel, each test must get its own <code>ActorSystem</code>, to
ensure the tests run in isolation. At the end of each test, the <code>ActorSystem</code> must be shutdown. With <code>NoArg</code>,
you can achieve this by first defining a class that extends <code>TestKit</code> and mixes in <code>NoArg</code>.
Here's an example taken with permission from the book <a href="http://www.artima.com/shop/akka_concurrency"><em>Akka Concurrency</em></a>, by Derek Wyatt:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> akka.actor.ActorSystem
<span class="stReserved">import</span> akka.testkit.{<span class="stType">TestKit</span>, <span class="stType">ImplicitSender</span>}
<span class="stReserved">import</span> java.util.concurrent.atomic.AtomicInteger
<span class="stReserved">import</span> org.scalatest.fixture.NoArg
<br/><span class="stReserved">object</span> <span class="stType">ActorSys</span> {
  <span class="stReserved">val</span> uniqueId = <span class="stReserved">new</span> <span class="stType">AtomicInteger</span>(<span class="stLiteral">0</span>)
}
<br/><span class="stReserved">class</span> <span class="stType">ActorSys</span>(name: <span class="stType">String</span>) <span class="stReserved">extends</span>
        <span class="stType">TestKit</span>(<span class="stType">ActorSystem</span>(name))
        <span class="stReserved">with</span> <span class="stType">ImplicitSender</span>
        <span class="stReserved">with</span> <span class="stType">NoArg</span> {
<br/>  <span class="stReserved">def</span> <span class="stReserved">this</span>() = <span class="stReserved">this</span>(
    <span class="stQuotedString">"TestSystem%05d"</span>.format(
       ActorSys.uniqueId.getAndIncrement()))
<br/>  <span class="stReserved">def</span> shutdown(): <span class="stType">Unit</span> = system.shutdown()
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> apply() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.apply()
    <span class="stReserved">finally</span> shutdown()
  }
}
</pre></p><p>Given this implementation of <code>ActorSys</code>, which will invoke <code>shutdown</code> after the constructor code
is executed, you can run each test in a suite in a subclass of <code>TestKit</code>, giving each test's <code>TestKit</code>
an <code>ActorSystem</code> with a unique name, allowing you to safely run those tests in parallel. Here's an example
from <em>Akka Concurrency</em>:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MyActorSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.WordSpec</span>
        <span class="stReserved">with</span> <span class="stType">Matchers</span>
        <span class="stReserved">with</span> <span class="stType">UnitFixture</span>
        <span class="stReserved">with</span> <span class="stType">ParallelTestExecution</span> {
<br/>  <span class="stReserved">def</span> makeActor(): <span class="stType">ActorRef</span> =
    system.actorOf(<span class="stType">Props[MyActor]</span>, <span class="stQuotedString">"MyActor"</span>)
<br/>  <span class="stQuotedString">"My Actor"</span> should {
    <span class="stQuotedString">"throw when made with the wrong name"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      an [<span class="stType">Exception</span>] should be thrownBy {
        <span class="stLineComment">// use a generated name</span>
        <span class="stReserved">val</span> a = system.actorOf(<span class="stType">Props[MyActor]</span>)
      }
    }
    <span class="stQuotedString">"construct without exception"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      <span class="stReserved">val</span> a = makeActor()
      <span class="stLineComment">// The throw will cause the test to fail</span>
    }
    <span class="stQuotedString">"respond with a Pong to a Ping"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      <span class="stReserved">val</span> a = makeActor()
      a ! <span class="stType">Ping</span>
      expectMsg(<span class="stType">Pong</span>)
    }
  }
}
</pre></p><p><a href="UnitFixture.html"><code>UnitFixture</code></a> is used in this example, because in this case, the <code>fixture.WordSpec</code> feature enabling tests to be defined as
functions from fixture objects of type <code>FixtureParam</code> to <code>Unit</code> is not being used. Rather, only the secondary feature that enables
tests to be defined as functions from <em>no parameters</em> to <code>Unit</code> is being used. This secondary feature is described in the second-to-last
paragraph on the main Scaladoc documentation of <a href="WordSpec.html"><code>fixture.WordSpec</code></a>, which says:</p><p><blockquote>
If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, ...
In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.
</blockquote></p><p>Since <code>FixtureParam</code> is unused in this use case, it could
be anything. Making it <code>Unit</code> will hopefully help readers more easily recognize that it is not being used.</p><p>Note: As of Scala 2.11, <code>DelayedInit</code> (which is used by <code>NoArg</code>) has been deprecated, to indicate it is buggy and should be avoided
if possible. Those in charge of the Scala compiler and standard library have promised that <code>DelayedInit</code> will not be removed from Scala
unless an alternate way to achieve the same goal is provided. Thus it <em>should</em> be safe to use <code>NoArg</code>, but if you'd rather
not you can achieve the same effect with a bit more boilerplate by extending (<code>() =&gt; Unit</code>) instead of <code>NoArg</code> and placing
your code in an explicit <code>body</code> method. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> akka.actor.ActorSystem
<span class="stReserved">import</span> akka.testkit.{<span class="stType">TestKit</span>, <span class="stType">ImplicitSender</span>}
<span class="stReserved">import</span> java.util.concurrent.atomic.AtomicInteger
<span class="stReserved">import</span> org.scalatest.fixture.NoArg
<br/><span class="stReserved">object</span> <span class="stType">ActorSys</span> {
  <span class="stReserved">val</span> uniqueId = <span class="stReserved">new</span> <span class="stType">AtomicInteger</span>(<span class="stLiteral">0</span>)
}
<br/><span class="stReserved">class</span> <span class="stType">ActorSys</span>(name: <span class="stType">String</span>) <span class="stReserved">extends</span>
        <span class="stType">TestKit</span>(<span class="stType">ActorSystem</span>(name))
        <span class="stReserved">with</span> <span class="stType">ImplicitSender</span>
        <span class="stReserved">with</span> (() =&gt; <span class="stType">Unit</span>) {
<br/>  <span class="stReserved">def</span> <span class="stReserved">this</span>() = <span class="stReserved">this</span>(
    <span class="stQuotedString">"TestSystem%05d"</span>.format(
       ActorSys.uniqueId.getAndIncrement()))
<br/>  <span class="stReserved">def</span> shutdown(): <span class="stType">Unit</span> = system.shutdown()
  <span class="stReserved">def</span> body(): <span class="stType">Unit</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> apply() = {
    <span class="stReserved">try</span> body()
    <span class="stReserved">finally</span> shutdown()
  }
}
</pre></p><p>Using this version of <code>ActorSys</code> will require an explicit
<code>body</code> method in the tests:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MyActorSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.WordSpec</span>
        <span class="stReserved">with</span> <span class="stType">Matchers</span>
        <span class="stReserved">with</span> <span class="stType">UnitFixture</span>
        <span class="stReserved">with</span> <span class="stType">ParallelTestExecution</span> {
<br/>  <span class="stReserved">def</span> makeActor(): <span class="stType">ActorRef</span> =
    system.actorOf(<span class="stType">Props[MyActor]</span>, <span class="stQuotedString">"MyActor"</span>)
<br/>  <span class="stQuotedString">"My Actor"</span> should {
    <span class="stQuotedString">"throw when made with the wrong name"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      <span class="stReserved">def</span> body() =
        an [<span class="stType">Exception</span>] should be thrownBy {
          <span class="stLineComment">// use a generated name</span>
          <span class="stReserved">val</span> a = system.actorOf(<span class="stType">Props[MyActor]</span>)
        }
    }
    <span class="stQuotedString">"construct without exception"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      <span class="stReserved">def</span> body() = {
        <span class="stReserved">val</span> a = makeActor()
        <span class="stLineComment">// The throw will cause the test to fail</span>
      }
    }
    <span class="stQuotedString">"respond with a Pong to a Ping"</span> in <span class="stReserved">new</span> <span class="stType">ActorSys</span> {
      <span class="stReserved">def</span> body() = {
        <span class="stReserved">val</span> a = makeActor()
        a ! <span class="stType">Ping</span>
        expectMsg(<span class="stType">Pong</span>)
      }
    }
  }
}
</pre></p></div></div>
    </li><li name="org.scalatest.fixture.PropSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PropSpecextendsPropSpecLike"></a>
      <a id="PropSpec:PropSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="PropSpec.html"><span class="name">PropSpec</span></a><span class="result"> extends <a href="PropSpecLike.html" class="extype" name="org.scalatest.fixture.PropSpecLike">PropSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@PropSpecextendsPropSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.PropSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.PropSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.PropSpec</code> in situations for which <a href="../PropSpec.html"><code>PropSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.PropSpec</code> is intended for use in special
situations, with class <code>PropSpec</code> used for general needs. For
more insight into where <code>fixture.PropSpec</code> fits in the big picture, see
the <a href="../PropSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of
the <a href="../PropSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>PropSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.PropSpec</code> behaves similarly to class <code>org.scalatest.PropSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also has an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.PropSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.propspec
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop.PropertyChecks
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.PropSpec</span> <span class="stReserved">with</span> <span class="stType">PropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stLineComment">// 1. define type FixtureParam</span>
  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">FileReader</span>
<br/>  <span class="stLineComment">// 2. define the withFixture method</span>
  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stReserved">val</span> <span class="stType">FileName</span> = <span class="stQuotedString">"TempFile.txt"</span>
<br/>    <span class="stLineComment">// Set up the temp file needed by the test</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(<span class="stType">FileName</span>)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"Hello, test!"</span>)
    }
    <span class="stReserved">finally</span> {
      writer.close()
    }
<br/>    <span class="stLineComment">// Create the reader needed by the test</span>
    <span class="stReserved">val</span> reader = <span class="stReserved">new</span> <span class="stType">FileReader</span>(<span class="stType">FileName</span>)
<br/>    <span class="stReserved">try</span> {
      <span class="stLineComment">// Run the test using the temp file</span>
      test(reader)
    }
    <span class="stReserved">finally</span> {
      <span class="stLineComment">// Close and delete the temp file</span>
      reader.close()
      <span class="stReserved">val</span> file = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stType">FileName</span>)
      file.delete()
    }
  }
<br/>  <span class="stLineComment">// 3. write property-based tests that take a fixture parameter</span>
  <span class="stLineComment">// (Hopefully less contrived than the examples shown here.)</span>
  property(<span class="stQuotedString">"can read from a temp file"</span>) { reader =&gt;
    <span class="stReserved">var</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
    <span class="stReserved">var</span> c = reader.read()
    <span class="stReserved">while</span> (c != -<span class="stLiteral">1</span>) {
      builder.append(c.toChar)
      c = reader.read()
    }
    <span class="stReserved">val</span> fileContents = builder.toString
    forAll { (c: <span class="stType">Char</span>) =&gt;
      whenever (c != <span class="stQuotedString">'H'</span>) {
        fileContents should not startWith c.toString
      }
    }
  }
<br/>  property(<span class="stQuotedString">"can read the first char of the temp file"</span>) { reader =&gt;
    <span class="stReserved">val</span> firstChar = reader.read()
    forAll { (c: <span class="stType">Char</span>) =&gt;
      whenever (c != <span class="stQuotedString">'H'</span>) {
        c should not equal firstChar
      }
    }
  }
<br/>  <span class="stLineComment">// (You can also write tests that don't take a fixture parameter.)</span>
  property(<span class="stQuotedString">"can write tests that don't take the fixture"</span>) { () =&gt;
    forAll { (i: <span class="stType">Int</span>) => i + i should equal (<span class="stLiteral">2</span> * i) }
  }
}
</pre></p><p>Note: to run the examples on this page, you'll need to include <a href="http://www.scalacheck.org">ScalaCheck</a> on the classpath in addition to ScalaTest.</p><p>In the previous example, <code>withFixture</code> creates and initializes a temp file, then invokes the test function,
passing in a <code>FileReader</code> connected to that file.  In addition to setting up the fixture before a test,
the <code>withFixture</code> method also cleans it up afterwards. If you need to do some clean up
that must happen even if a test fails, you should invoke the test function from inside a <code>try</code> block and do
the cleanup in a <code>finally</code> clause, as shown in the previous example.</p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the
exception describing the failure.
The reason you must perform cleanup in a <code>finally</code> clause is that in case an exception propagates back through
<code>withFixture</code>, the <code>finally</code> clause will ensure the fixture cleanup happens as that exception
propagates back up the call stack to <code>runTest</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function.
In other words, instead of starting your function literal
with something like &ldquo;<code>reader =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;, as is done
in the third test in the above example. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p><a name="multipleFixtures"></a></p><h4> Passing multiple fixture objects </h4><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(builder: <span class="stType">StringBuilder</span>, buffer: <span class="stType">ListBuffer[String]</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.propspec.multi
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop.PropertyChecks
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.PropSpec</span> <span class="stReserved">with</span> <span class="stType">PropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(builder: <span class="stType">StringBuilder</span>, buffer: <span class="stType">ListBuffer[String]</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// Create needed mutable objects</span>
    <span class="stReserved">val</span> stringBuilder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> listBuffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(stringBuilder, listBuffer)
<br/>    <span class="stLineComment">// Invoke the test function, passing in the mutable objects</span>
    withFixture(test.toNoArgTest(theFixture))
  }
<br/>  property(<span class="stQuotedString">"testing should be easy"</span>) { f =&gt;
    f.builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(f.buffer.isEmpty)
    <span class="stReserved">val</span> firstChar = f.builder(<span class="stLiteral">0</span>)
    forAll { (c: <span class="stType">Char</span>) =&gt;
      whenever (c != <span class="stQuotedString">'S'</span>) {
        c should not equal firstChar
      }
    }
    f.buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  property(<span class="stQuotedString">"testing should be fun"</span>) { f =&gt;
    f.builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(f.buffer.isEmpty)
    <span class="stReserved">val</span> firstChar = f.builder(<span class="stLiteral">0</span>)
    forAll { (c: <span class="stType">Char</span>) =&gt;
      whenever (c != <span class="stQuotedString">'S'</span>) {
        c should not equal firstChar
      }
    }
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.fixture.PropSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PropSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="PropSpecLike:PropSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="PropSpecLike.html"><span class="name">PropSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@PropSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.PropSpec</code>, which is
a sister class to <a href="../PropSpec.html"><code>org.scalatest.PropSpec</code></a> that can pass a
fixture object into its tests.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.PropSpec</code>, which is
a sister class to <a href="../PropSpec.html"><code>org.scalatest.PropSpec</code></a> that can pass a
fixture object into its tests.</p><p><a href="PropSpec.html"><code>fixture.PropSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.PropSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.PropSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="PropSpec.html">detailed
overview of <code>fixture.PropSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.Suite" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="SuiteextendsSuite"></a>
      <a id="Suite:Suite"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Suite.html"><span class="name">Suite</span></a><span class="result"> extends <a href="../Suite.html" class="extype" name="org.scalatest.Suite">scalatest.Suite</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@SuiteextendsSuite" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base trait for a family of style traits that can pass a fixture object into tests.</p>
    </li><li name="org.scalatest.fixture.TestDataFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TestDataFixtureextendsAnyRef"></a>
      <a id="TestDataFixture:TestDataFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="TestDataFixture.html"><span class="name">TestDataFixture</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@TestDataFixtureextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <a href="Suite.html"><code>fixture.Suite</code></a> passes the
<a href="../TestData.html"><code>TestData</code></a> passed to <code>withFixture</code> as a fixture into each test.</code></a></a></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="Suite.html"><code>fixture.Suite</code></a> passes the
<a href="../TestData.html"><code>TestData</code></a> passed to <code>withFixture</code> as a fixture into each test.</p><p>For example, here's how you could access the test's name in each test using <code>TestDataFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.testdatafixture
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> <span class="stReserved">with</span> <span class="stType">fixture.TestDataFixture</span> {
<br/>  <span class="stQuotedString">"Accessing the test data"</span> should <span class="stQuotedString">"be easy!"</span> in { td =&gt;
    assert(td.name == <span class="stQuotedString">"Accessing the test data should be easy!"</span>)
  }
<br/>  it should <span class="stQuotedString">"be fun!"</span> in { td =&gt;
    assert(td.name == <span class="stQuotedString">"Accessing the test data should be fun!"</span>)
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.fixture.TestRegistration" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="TestRegistrationextendsAnyRef"></a>
      <a id="TestRegistration:TestRegistration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="TestRegistration.html"><span class="name">TestRegistration</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@TestRegistrationextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait declaring methods that can be used to register test functions that accept
a fixture parameter and have any result type.</p>
    </li><li name="org.scalatest.fixture.TestSuite" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="TestSuiteextendsSuitewithTestSuite"></a>
      <a id="TestSuite:TestSuite"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="TestSuite.html"><span class="name">TestSuite</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.fixture.Suite">Suite</a> with <a href="../TestSuite.html" class="extype" name="org.scalatest.TestSuite">scalatest.TestSuite</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@TestSuiteextendsSuitewithTestSuite" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="org.scalatest.fixture.UnitFixture" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="UnitFixtureextendsAnyRef"></a>
      <a id="UnitFixture:UnitFixture"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="UnitFixture.html"><span class="name">UnitFixture</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@UnitFixtureextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Trait that when mixed into a <code>fixture.Suite</code> passes
the unit value as a fixture into each test.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <code>fixture.Suite</code> passes
the unit value as a fixture into each test.</p><p>Since a unit value is unlikely to be of much use to a test, this trait is useful
when the unit value fixture is actually never passed into any tests. Instead
each test in the <a href="Suite.html"><code>fixture.Suite</code></a> is defined as a <em>no-arg</em> function; no tests are defined as one-arg functions.
This should be quite rare, but occasionally can be useful.
For an example, see the main documentation for trait <a href="NoArg.html"><code>NoArg</code></a>.
</p></div></div>
    </li><li name="org.scalatest.fixture.WordSpec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="WordSpecextendsWordSpecLike"></a>
      <a id="WordSpec:WordSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="WordSpec.html"><span class="name">WordSpec</span></a><span class="result"> extends <a href="WordSpecLike.html" class="extype" name="org.scalatest.fixture.WordSpecLike">WordSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@WordSpecextendsWordSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.WordSpec</code> that can pass a fixture object into its tests.</code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.WordSpec</code> that can pass a fixture object into its tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use class <code>fixture.WordSpec</code> in situations for which <a href="../WordSpec.html"><code>WordSpec</code></a>
would be a good choice, when all or most tests need the same fixture objects
that must be cleaned up afterwards. <em>Note: <code>fixture.WordSpec</code> is intended for use in special situations, with class <code>WordSpec</code> used for general needs. For
more insight into where <code>fixture.WordSpec</code> fits in the big picture, see the <a href="../WordSpec.html#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a> subsection of the <a href="../WordSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for class <code>WordSpec</code>.</em>
</td></tr></table></p><p>Class <code>fixture.WordSpec</code> behaves similarly to class <code>org.scalatest.WordSpec</code>, except that tests may have a
fixture parameter. The type of the
fixture parameter is defined by the abstract <code>FixtureParam</code> type, which is a member of this class.
This class also has an abstract <code>withFixture</code> method. This <code>withFixture</code> method
takes a <code>OneArgTest</code>, which is a nested trait defined as a member of this class.
<code>OneArgTest</code> has an <code>apply</code> method that takes a <code>FixtureParam</code>.
This <code>apply</code> method is responsible for running a test.
This class's <code>runTest</code> method delegates the actual running of each test to <code>withFixture(OneArgTest)</code>, passing
in the test code to run via the <code>OneArgTest</code> argument. The <code>withFixture(OneArgTest)</code> method (abstract in this class) is responsible
for creating the fixture argument and passing it to the test function.</p><p>Subclasses of this class must, therefore, do three things differently from a plain old <code>org.scalatest.WordSpec</code>:</p><ul><li>define the type of the fixture parameter by specifying type <code>FixtureParam</code></li><li>define the <code>withFixture(OneArgTest)</code> method</li><li>write tests that take a fixture parameter</li><li>(You can also define tests that don't take a fixture parameter.)</li></ul><p>If the fixture you want to pass into your tests consists of multiple objects, you will need to combine
them into one object to use this class. One good approach to passing multiple fixture objects is
to encapsulate them in a case class. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
</pre></p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.WordSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    <span class="stQuotedString">"be fun"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>If a test fails, the <code>OneArgTest</code> function will result in a <a href="../Failed.html" class="extype" name="org.scalatest.Failed">Failed</a> wrapping the exception describing the failure.
To ensure clean up happens even if a test fails, you should invoke the test function from inside a <code>try</code> block and do the cleanup in a
<code>finally</code> clause, as shown in the previous example.</p><p><a name="sharingFixturesAcrossClasses"></a></p><h4> Sharing fixtures across classes </h4><p>If multiple test classes need the same fixture, you can define the <code>FixtureParam</code> and <code>withFixture(OneArgTest)</code> implementations
in a trait, then mix that trait into the test classes that need it. For example, if your application requires a database and your integration tests
use that database, you will likely have many test classes that need a database fixture. You can create a &quot;database fixture&quot; trait that creates a
database with a unique name, passes the connector into the test, then removes the database once the test completes. This is shown in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.fixture.wordspec.sharing
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">DbFixture</span> { <span class="stReserved">this</span>: <span class="stType">fixture.Suite</span> =&gt;
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">Db</span>
<br/>  <span class="stLineComment">// Allow clients to populate the database after</span>
  <span class="stLineComment">// it is created</span>
  <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) {}
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      populateDb(db) <span class="stLineComment">// setup the fixture</span>
      withFixture(test.toNoArgTest(db)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.WordSpec</span> <span class="stReserved">with</span> <span class="stType">DbFixture</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> populateDb(db: <span class="stType">Db</span>) { <span class="stLineComment">// setup the fixture</span>
    db.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"should be easy"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"easy!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { db =&gt;
      db.append(<span class="stQuotedString">"fun!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test doesn't need a Db</span>
  <span class="stQuotedString">"Test code"</span> should {
    <span class="stQuotedString">"should be clear"</span> in { () =&gt;
      <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
      buf.append(<span class="stQuotedString">"ScalaTest code is "</span>)
      buf.append(<span class="stQuotedString">"clear!"</span>)
      assert(buf.toString === <span class="stQuotedString">"ScalaTest code is clear!"</span>)
    }
  }
}
</pre></p><p>Often when you create fixtures in a trait like <code>DbFixture</code>, you'll still need to enable individual test classes
to &quot;setup&quot; a newly created fixture before it gets passed into the tests. A good way to accomplish this is to pass the newly
created fixture into a setup method, like <code>populateDb</code> in the previous example, before passing it to the test
function. Classes that need to perform such setup can override the method, as does <code>ExampleSpec</code>.</p><p>If a test doesn't need the fixture, you can indicate that by providing a no-arg instead of a one-arg function, as is done in the
third test in the previous example, &ldquo;<code>Test code should be clear</code>&rdquo;. In other words, instead of starting your function literal
with something like &ldquo;<code>db =&gt;</code>&rdquo;, you'd start it with &ldquo;<code>() =&gt;</code>&rdquo;. For such tests, <code>runTest</code>
will not invoke <code>withFixture(OneArgTest)</code>. It will instead directly invoke <code>withFixture(NoArgTest)</code>.</p><p>Both examples shown above demonstrate the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in these examples. This keeps tests completely isolated, allowing you to run them in parallel if desired. You could mix
<a href="../ParallelTestExecution.html"><code>ParallelTestExecution</code></a> into either of these <code>ExampleSpec</code> classes, and the tests would run in parallel just fine.</p></div></div>
    </li><li name="org.scalatest.fixture.WordSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="WordSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="WordSpecLike:WordSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="WordSpecLike.html"><span class="name">WordSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.fixture.TestRegistration">TestRegistration</a> with <a href="../words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="../words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="../words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@WordSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>fixture.WordSpec</code>, which is
a sister class to <a href="../WordSpec.html"><code>org.scalatest.WordSpec</code></a> that can pass a
fixture object into its tests.</a></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>fixture.WordSpec</code>, which is
a sister class to <a href="../WordSpec.html"><code>org.scalatest.WordSpec</code></a> that can pass a
fixture object into its tests.</p><p><a href="WordSpec.html"><code>fixture.WordSpec</code></a> is a class,
not a trait, to minimize compile time given there is a slight compiler
overhead to mixing in traits compared to extending classes. If you need
to mix the behavior of <code>fixture.WordSpec</code> into some other
class, you can use this trait instead, because class
<code>fixture.WordSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="WordSpec.html">detailed
overview of <code>fixture.WordSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.fixture.Spec" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SpecextendsSpecLike"></a>
      <a id="Spec:Spec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Spec.html"><span class="name deprecated" title="Deprecated: fixture.Spec has been deprecated and will be removed in a future version of ScalaTest. Please use org.scalatest.fixture.FunSpec instead.">Spec</span></a><span class="result"> extends <a href="SpecLike.html" class="extype" name="org.scalatest.fixture.SpecLike">SpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@SpecextendsSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>Class <code>fixture.Spec</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
<code>org.scalatest.fixture.FunSpec</code> instead.</strong> </strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>Class <code>fixture.Spec</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
<code>org.scalatest.fixture.FunSpec</code> instead.</strong></p><p>Because this style uses reflection at runtime to discover scopes and tests, it can only be supported on the JVM, not Scala.js.
Thus in ScalaTest 3.0.0, class <code>org.scalatest.Spec</code> was moved to the <code>org.scalatest.refspec</code> package and renamed
<code>RefSpec</code>, with the intention of later moving it to a separate module available only on the JVM. If the
<code>org.scalatest.refspec._</code> package contained a <code>fixture</code> subpackage, then importing <code>org.scalatest.refspec._</code>
would import the name <code>fixture</code> as <code>org.scalatest.refspec.fixture</code>. This would likely be confusing for users,
who expect <code>fixture</code> to mean <code>org.scalatest.fixture</code>.</p><p>As a result this class has been deprecated and will <em>not</em>
be moved to package <code>org.scalatest.refspec</code>. Instead we recommend you rewrite any test classes that currently extend
<code>org.scalatest.fixture.Spec</code> to extend <a href="FunSpec.html"><code>org.scalatest.fixture.FunSpec</code></a> instead,
replacing any scope <code>object</code>
with a <code>describe</code> clause, and any test method with an <code>it</code> clause.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>fixture.Spec has been deprecated and will be removed in a future version of ScalaTest. Please use org.scalatest.fixture.FunSpec instead.</p></dd></dl></div>
    </li><li name="org.scalatest.fixture.SpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SpecLikeextendsTestSuitewithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="SpecLike:SpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="SpecLike.html"><span class="name deprecated" title="Deprecated: fixture.SpecLike has been deprecated and will be removed in a future version of ScalaTest. Please use org.scalatest.fixture.FunSpecLike instead.">SpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.fixture.TestSuite">TestSuite</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.fixture.package@SpecLikeextendsTestSuitewithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>Trait <code>fixture.SpecLike</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
<code>org.scalatest.fixture.FunSpec</code> instead.</strong> </strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>Trait <code>fixture.SpecLike</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
<code>org.scalatest.fixture.FunSpec</code> instead.</strong></p><p>Because this style uses reflection at runtime to discover scopes and tests, it can only be supported on the JVM, not Scala.js.
Thus in ScalaTest 3.0.0, class <code>org.scalatest.SpecLike</code> was moved to the <code>org.scalatest.refspec</code> package and renamed
<code>RefSpecLike</code>, with the intention of later moving it to a separate module available only on the JVM. If the
<code>org.scalatest.refspec._</code> package contained a <code>fixture</code> subpackage, then importing <code>org.scalatest.refspec._</code>
would import the name <code>fixture</code> as <code>org.scalatest.refspec.fixture</code>. This would likely be confusing for users,
who expect <code>fixture</code> to mean <code>org.scalatest.fixture</code>.</p><p>As a result this class has been deprecated and will <em>not</em>
be moved to package <code>org.scalatest.refspec</code>. Instead we recommend you rewrite any test classes that currently extend
<code>org.scalatest.fixture.SpecLike</code> to extend <a href="FunSpecLike.html"><code>org.scalatest.fixture.FunSpecLike</code></a> instead,
replacing any scope <code>object</code>
with a <code>describe</code> clause, and any test method with an <code>it</code> clause.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>fixture.SpecLike has been deprecated and will be removed in a future version of ScalaTest. Please use org.scalatest.fixture.FunSpecLike instead.</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
