<!DOCTYPE html >
<html>
        <head>
          <title>path - ScalaTest 3.0.2 - org.scalatest.path</title>
          <meta name="description" content="path - ScalaTest 3.0.2 - org.scalatest.path" />
          <meta name="keywords" content="path ScalaTest 3.0.2 org.scalatest.path" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'org.scalatest.path.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-71294502-1"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'UA-71294502-1');

</script>
        </head>
        <body class="value">

<!-- Top of doc.scalatest.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/4ca150665e51d0b1c3890ca1b891c507-ads.js?product=ScalaTest"></script>

      <div id="definition">
        <img alt="Package" src="../../../lib/package_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="org">org</a>.<a href="../package.html" class="extype" name="org.scalatest">scalatest</a></p>
        <h1>path</h1><span class="permalink">
      <a href="../../../index.html#org.scalatest.path.package" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">path</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.scalatest.path.FreeSpec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecextendsFreeSpecLike"></a>
      <a id="FreeSpec:FreeSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FreeSpec.html"><span class="name">FreeSpec</span></a><span class="result"> extends <a href="FreeSpecLike.html" class="extype" name="org.scalatest.path.FreeSpecLike">FreeSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.path.package@FreeSpecextendsFreeSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FreeSpec</code> that isolates tests by running each test in its own
instance of the test class, and for each test, only executing the <em>path</em> leading to that test.</em></code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FreeSpec</code> that isolates tests by running each test in its own
instance of the test class, and for each test, only executing the <em>path</em> leading to that test.</p><p>Class <code>path.FreeSpec</code> behaves similarly to class <code>org.scalatest.FreeSpec</code>, except that tests
are isolated based on their path. The purpose of <code>path.FreeSpec</code> is to facilitate writing
specification-style tests for mutable objects in a clear, boilerpate-free way. To test mutable objects, you need to
mutate them. Using a path class, you can make a statement in text, then implement that statement in code (including
mutating state), and nest and combine these test/code pairs in any way you wish. Each test will only see
the side effects of code that is in blocks that enclose the test. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.path
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">path.FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stQuotedString">"A ListBuffer"</span> - {
<br/>    <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>] <span class="stLineComment">// This implements "A ListBuffer"</span>
<br/>    <span class="stQuotedString">"should be empty when created"</span> in {
<br/>      <span class="stLineComment">// This test sees:</span>
      <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
      <span class="stLineComment">// So buf is: ListBuffer()</span>
<br/>      buf should be (<span class="stQuotedString">'empty</span>)
    }
<br/>    <span class="stQuotedString">"when 1 is appended"</span> - {
<br/>      buf += <span class="stLiteral">1</span> <span class="stLineComment">// This implements "when 1 is appended", etc...</span>
<br/>      <span class="stQuotedString">"should contain 1"</span> in {
<br/>        <span class="stLineComment">// This test sees:</span>
        <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
        <span class="stLineComment">//   buf += 1</span>
        <span class="stLineComment">// So buf is: ListBuffer(1)</span>
<br/>        buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
        buf should be (<span class="stQuotedString">'empty</span>)
      }
<br/>      <span class="stQuotedString">"when 2 is appended"</span> - {
<br/>        buf += <span class="stLiteral">2</span>
<br/>        <span class="stQuotedString">"should contain 1 and 2"</span> in {
<br/>          <span class="stLineComment">// This test sees:</span>
          <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
          <span class="stLineComment">//   buf += 1</span>
          <span class="stLineComment">//   buf += 2</span>
          <span class="stLineComment">// So buf is: ListBuffer(1, 2)</span>
<br/>          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        <span class="stQuotedString">"when 2 is removed"</span> - {
<br/>          buf -= <span class="stLiteral">2</span>
<br/>          <span class="stQuotedString">"should contain only 1 again"</span> in {
<br/>            <span class="stLineComment">// This test sees:</span>
            <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
            <span class="stLineComment">//   buf += 1</span>
            <span class="stLineComment">//   buf += 2</span>
            <span class="stLineComment">//   buf -= 2</span>
            <span class="stLineComment">// So buf is: ListBuffer(1)</span>
<br/>            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
        }
<br/>        <span class="stQuotedString">"when 3 is appended"</span> - {
<br/>          buf += <span class="stLiteral">3</span>
<br/>          <span class="stQuotedString">"should contain 1, 2, and 3"</span> in {
<br/>            <span class="stLineComment">// This test sees:</span>
            <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
            <span class="stLineComment">//   buf += 1</span>
            <span class="stLineComment">//   buf += 2</span>
            <span class="stLineComment">//   buf += 3</span>
            <span class="stLineComment">// So buf is: ListBuffer(1, 2, 3)</span>
<br/>            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
        }
      }
<br/>      <span class="stQuotedString">"when 88 is appended"</span> - {
<br/>        buf += <span class="stLiteral">88</span>
<br/>        <span class="stQuotedString">"should contain 1 and 88"</span> in {
<br/>          <span class="stLineComment">// This test sees:</span>
          <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
          <span class="stLineComment">//   buf += 1</span>
          <span class="stLineComment">//   buf += 88</span>
          <span class="stLineComment">// So buf is: ListBuffer(1, 88)</span>
<br/>          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">88</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
      }
    }
<br/>    <span class="stQuotedString">"should have size 0 when created"</span> in {
<br/>      <span class="stLineComment">// This test sees:</span>
      <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
      <span class="stLineComment">// So buf is: ListBuffer()</span>
<br/>      buf should have size <span class="stLiteral">0</span>
    }
  }
}
</pre></p><p>Note that the above class is organized by writing a bit of specification text that opens a new block followed
by, at the top of the new block, some code that &quot;implements&quot; or &quot;performs&quot; what is described in the text. This is repeated as
the mutable object (here, a <code>ListBuffer</code>), is prepared for the enclosed tests. For example:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A ListBuffer"</span> - {
  <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>]
</pre></p><p>Or:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"when 2 is appended"</span> - {
  buf += <span class="stLiteral">2</span>
</pre></p><p>Note also that although each test mutates the <code>ListBuffer</code>, none of the other tests observe those
side effects:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"should contain 1"</span> in {
<br/>  buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
  <span class="stLineComment">// ...</span>
}
<br/><span class="stQuotedString">"when 2 is appended"</span> - {
<br/>  buf += <span class="stLiteral">2</span>
<br/>  <span class="stQuotedString">"should contain 1 and 2"</span> in {
<br/>    <span class="stLineComment">// This test does not see the buf.remove(0) from the previous test,</span>
    <span class="stLineComment">// so the first element in the ListBuffer is again 1</span>
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
</pre></p><p>This kind of isolation of tests from each other is a consequence of running each test in its own instance of the test
class, and can also be achieved by simply mixing <code>OneInstancePerTest</code> into a regular
<code>org.scalatest.FreeSpec</code>. However, <code>path.FreeSpec</code> takes isolation one step further: a test
in a <code>path.FreeSpec</code> does not observe side effects performed outside tests in earlier blocks that do not
enclose it. Here's an example:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"when 2 is removed"</span> - {
<br/>  buf -= <span class="stLiteral">2</span>
<br/>  <span class="stLineComment">// ...</span>
}
<br/><span class="stQuotedString">"when 3 is appended"</span> - {
<br/>  buf += <span class="stLiteral">3</span>
<br/>  <span class="stQuotedString">"should contain 1, 2, and 3"</span> in {
<br/>    <span class="stLineComment">// This test does not see the buf -= 2 from the earlier "when 2 is removed" block,</span>
    <span class="stLineComment">// because that block does not enclose this test, so the second element in the</span>
    <span class="stLineComment">// ListBuffer is still 2</span>
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
</pre></p><p>Running the full <code>ExampleSpec</code>, shown above, in the Scala interpeter would give you:</p><p><pre class="stREPL">
scala> import org.scalatest._
import org.scalatest._

scala> run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
A ListBuffer
- should be empty when created
&nbsp; when 1 is appended
&nbsp; - should contain 1
&nbsp;   when 2 is appended
&nbsp;   - should contain 1 and 2
&nbsp;     when 2 is removed
&nbsp;     - should contain only 1 again
&nbsp;     when 3 is appended
&nbsp;     - should contain 1, 2, and 3
&nbsp;   when 88 is appended
&nbsp;   - should contain 1 and 88
- should have size 0 when created</span>
</pre></p><p><em>Note: class <code>path.FreeSpec</code>'s approach to isolation was inspired in part by the
<a href="https://github.com/orfjackal/specsy">specsy</a> framework, written by Esko Luontola.</em></p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is objects or other artifacts (such as files, sockets, database
connections, <em>etc.</em>) used by tests to do their work.
If a fixture is used by only one test, then the definitions of the fixture objects can
be local to the method. If multiple tests need to share an immutable fixture, you can simply
assign them to instance variables. If multiple tests need to share mutable fixture objects or <code>var</code>s,
there's one and only one way to do it in a <code>path.FreeSpec</code>: place the mutable objects lexically before
the test. Any mutations needed by the test must be placed lexically before and/or after the test.
As used here, &quot;Lexically before&quot; means that the code needs to be executed during construction of that test's
instance of the test class to <em>reach</em> the test (or put another way, the
code is along the &quot;path to the test.&quot;) &quot;Lexically after&quot; means that the code needs to be executed to exit the
constructor after the test has been executed.</p><p>The reason lexical placement is the one and only one way to share fixtures in a <code>path.FreeSpec</code> is because
all of its lifecycle methods are overridden and declared <code>final</code>. Thus you can't mix in <code>BeforeAndAfter</code> or
<code>BeforeAndAfterEach</code>, because both override <code>runTest</code>, which is <code>final</code> in
a <code>path.FreeSpec</code>. You also can't override <code>withFixture</code>, because <code>path.FreeSpec</code>
extends <a href="../Suite.html"><code>Suite</code></a> not <a href="../TestSuite.html"><code>TestSuite</code></a>,
where <code>withFixture</code> is defined. In short:</p><p><table style="border-collapse: collapse; border: 1px solid black; width: 70%; margin: auto">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 15px; text-align: left; border: 1px solid black; font-size: 125%; font-weight: bold">
In a <code>path.FreeSpec</code>, if you need some code to execute before a test, place that code lexically before
the test. If you need some code to execute after a test, place that code lexically after the test.
</th>
</tr>
</table></p><p>The reason the life cycle methods are final, by the way, is to prevent users from attempting to combine
a <code>path.FreeSpec</code>'s approach to isolation with other ways ScalaTest provides to share fixtures or
execute tests, because doing so could make the resulting test code hard to reason about. A
<code>path.FreeSpec</code>'s execution model is a bit magical, but because it executes in one and only one
way, users should be able to reason about the code.
To help you visualize how a <code>path.FreeSpec</code> is executed, consider the following variant of
<code>ExampleSpec</code> that includes print statements:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.path
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">path.FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  println(<span class="stQuotedString">"Start of: ExampleSpec"</span>)
  <span class="stQuotedString">"A ListBuffer"</span> - {
<br/>    println(<span class="stQuotedString">"Start of: A ListBuffer"</span>)
    <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>]
<br/>    <span class="stQuotedString">"should be empty when created"</span> in {
<br/>      println(<span class="stQuotedString">"In test: should be empty when created; buf is: "</span> + buf)
      buf should be (<span class="stQuotedString">'empty</span>)
    }
<br/>    <span class="stQuotedString">"when 1 is appended"</span> - {
<br/>      println(<span class="stQuotedString">"Start of: when 1 is appended"</span>)
      buf += <span class="stLiteral">1</span>
<br/>      <span class="stQuotedString">"should contain 1"</span> in {
<br/>        println(<span class="stQuotedString">"In test: should contain 1; buf is: "</span> + buf)
        buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
        buf should be (<span class="stQuotedString">'empty</span>)
      }
<br/>      <span class="stQuotedString">"when 2 is appended"</span> - {
<br/>        println(<span class="stQuotedString">"Start of: when 2 is appended"</span>)
        buf += <span class="stLiteral">2</span>
<br/>        <span class="stQuotedString">"should contain 1 and 2"</span> in {
<br/>          println(<span class="stQuotedString">"In test: should contain 1 and 2; buf is: "</span> + buf)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        <span class="stQuotedString">"when 2 is removed"</span> - {
<br/>          println(<span class="stQuotedString">"Start of: when 2 is removed"</span>)
          buf -= <span class="stLiteral">2</span>
<br/>          <span class="stQuotedString">"should contain only 1 again"</span> in {
<br/>            println(<span class="stQuotedString">"In test: should contain only 1 again; buf is: "</span> + buf)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
<br/>          println(<span class="stQuotedString">"End of: when 2 is removed"</span>)
        }
<br/>        <span class="stQuotedString">"when 3 is appended"</span> - {
<br/>          println(<span class="stQuotedString">"Start of: when 3 is appended"</span>)
          buf += <span class="stLiteral">3</span>
<br/>          <span class="stQuotedString">"should contain 1, 2, and 3"</span> in {
<br/>            println(<span class="stQuotedString">"In test: should contain 1, 2, and 3; buf is: "</span> + buf)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
          println(<span class="stQuotedString">"End of: when 3 is appended"</span>)
        }
<br/>        println(<span class="stQuotedString">"End of: when 2 is appended"</span>)
      }
<br/>      <span class="stQuotedString">"when 88 is appended"</span> - {
<br/>        println(<span class="stQuotedString">"Start of: when 88 is appended"</span>)
        buf += <span class="stLiteral">88</span>
<br/>        <span class="stQuotedString">"should contain 1 and 88"</span> in {
<br/>          println(<span class="stQuotedString">"In test: should contain 1 and 88; buf is: "</span> + buf)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">88</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        println(<span class="stQuotedString">"End of: when 88 is appended"</span>)
      }
<br/>      println(<span class="stQuotedString">"End of: when 1 is appended"</span>)
    }
<br/>    <span class="stQuotedString">"should have size 0 when created"</span> in {
<br/>      println(<span class="stQuotedString">"In test: should have size 0 when created; buf is: "</span> + buf)
      buf should have size <span class="stLiteral">0</span>
    }
<br/>    println(<span class="stQuotedString">"End of: A ListBuffer"</span>)
  }
  println(<span class="stQuotedString">"End of: ExampleSpec"</span>)
  println()
}
</pre></p><p>Running the above version of <code>ExampleSpec</code> in the Scala interpreter will give you output similar to:</p><p><pre class="stREPL">
scala> import org.scalatest._
import org.scalatest._

scala> run(new ExampleSpec)
<span class="stGreen">ExampleSpec:</span>
Start of: ExampleSpec
Start of: A ListBuffer
In test: should be empty when created; buf is: ListBuffer()
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
In test: should contain 1; buf is: ListBuffer(1)
ExampleSpec:
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
In test: should contain 1 and 2; buf is: ListBuffer(1, 2)
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
Start of: when 2 is removed
In test: should contain only 1 again; buf is: ListBuffer(1)
End of: when 2 is removed
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
Start of: when 3 is appended
In test: should contain 1, 2, and 3; buf is: ListBuffer(1, 2, 3)
End of: when 3 is appended
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 88 is appended
In test: should contain 1 and 88; buf is: ListBuffer(1, 88)
End of: when 88 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
In test: should have size 0 when created; buf is: ListBuffer()
End of: A ListBuffer
End of: ExampleSpec

<span class="stGreen">A ListBuffer
- should be empty when created
  when 1 is appended
&nbsp; - should contain 1
&nbsp;   when 2 is appended
&nbsp;   - should contain 1 and 2
&nbsp;     when 2 is removed
&nbsp;     - should contain only 1 again
&nbsp;     when 3 is appended
&nbsp;     - should contain 1, 2, and 3
&nbsp;   when 88 is appended
&nbsp;   - should contain 1 and 88
- should have size 0 when created</span>
</pre></p><p>Note that each test is executed in order of appearance in the <code>path.FreeSpec</code>, and that only
those <code>println</code> statements residing in blocks that enclose the test being run are executed. Any
<code>println</code> statements in blocks that do not form the &quot;path&quot; to a test are not executed in the
instance of the class that executes that test.</p><p><a name="howItExecutes"></a></p><h4> How it executes </h4><p>To provide its special brand of test isolation, <code>path.FreeSpec</code> executes quite differently from its
sister class in <code>org.scalatest</code>. An <code>org.scalatest.FreeSpec</code>
registers tests during construction and executes them when <code>run</code> is invoked. An
<code>org.scalatest.path.FreeSpec</code>, by contrast, runs each test in its own instance <em>while that
instance is being constructed</em>. During construction, it registers not the tests to run, but the results of
running those tests. When <code>run</code> is invoked on a <code>path.FreeSpec</code>, it reports the registered
results and does not run the tests again. If <code>run</code> is invoked a second or third time, in fact,
a <code>path.FreeSpec</code> will each time report the same results registered during construction. If you want
to run the tests of a <code>path.FreeSpec</code> anew, you'll need to create a new instance and invoke
<code>run</code> on that.</p><p>A <code>path.FreeSpec</code> will create one instance for each &quot;leaf&quot; node it contains. The main kind of leaf node is
a test, such as:</p><p><pre class="stHighlighted">
<span class="stLineComment">// One instance will be created for each test</span>
<span class="stQuotedString">"should be empty when created"</span> in {
  buf should be (<span class="stQuotedString">'empty</span>)
}
</pre></p><p>However, an empty scope (a scope that contains no tests or nested scopes) is also a leaf node:</p><p><pre class="stHighlighted">
<span class="stLineComment">// One instance will be created for each empty scope</span>
<span class="stQuotedString">"when 99 is added"</span> - {
  <span class="stLineComment">// A scope is "empty" and therefore a leaf node if it has no</span>
  <span class="stLineComment">// tests or nested scopes, though it may have other code (which</span>
  <span class="stLineComment">// will be executed in the instance created for that leaf node)</span>
  buf += <span class="stLiteral">99</span>
}
</pre></p><p>The tests will be executed sequentially, in the order of appearance. The first test (or empty scope,
if that is first) will be executed when a class that mixes in <code>path.FreeSpec</code> is
instantiated. Only the first test will be executed during this initial instance, and of course, only
the path to that test. Then, the first time the client uses the initial instance (by invoking one of <code>run</code>,
<code>expectedTestsCount</code>, <code>tags</code>, or <code>testNames</code> on the instance), the initial instance will,
before doing anything else, ensure that any remaining tests are executed, each in its own instance.</p><p>To ensure that the correct path is taken in each instance, and to register its test results, the initial
<code>path.FreeSpec</code> instance must communicate with the other instances it creates for running any subsequent
leaf nodes. It does so by setting a thread-local variable prior to creating each instance (a technique
suggested by Esko Luontola). Each instance
of <code>path.FreeSpec</code> checks the thread-local variable. If the thread-local is not set, it knows it
is an initial instance and therefore executes every block it encounters until it discovers, and executes the
first test (or empty scope, if that's the first leaf node). It then discovers, but does not execute the next
leaf node, or discovers there are no other leaf nodes remaining to execute. It communicates the path to the next
leaf node, if any, and the result of running the test it did execute, if any, back to the initial instance. The
initial instance repeats this process until all leaf nodes have been executed and all test results registered.</p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>You mark a test as ignored in an <code>org.scalatest.path.FreeSpec</code> in the same manner as in
an <code>org.scalatest.FreeSpec</code>. Please see the <a href="../FreeSpec.html#ignoredTests">Ignored tests</a> section
in its documentation for more information.</p><p>Note that a separate instance will be created for an ignored test,
and the path to the ignored test will be executed in that instance, but the test function itself will not
be executed. Instead, a <code>TestIgnored</code> event will be fired.</p><p><a name="informers"></a></p><h4> Informers </h4><p>You output information using <code>Informer</code>s in an <code>org.scalatest.path.FreeSpec</code> in the same manner
as in an <code>org.scalatest.FreeSpec</code>. Please see the <a href="../FreeSpec.html#informers">Informers</a>
section in its documentation for more information.</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>You mark a test as pending in an <code>org.scalatest.path.FreeSpec</code> in the same manner as in
an <code>org.scalatest.FreeSpec</code>. Please see the <a href="../FreeSpec.html#pendingTests">Pending tests</a>
section in its documentation for more information.</p><p>Note that a separate instance will be created for a pending test,
and the path to the ignored test will be executed in that instance, as well as the test function (up until it
completes abruptly with a <code>TestPendingException</code>).</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>You can place tests into groups by tagging them in an <code>org.scalatest.path.FreeSpec</code> in the same manner
as in an <code>org.scalatest.FreeSpec</code>. Please see the <a href="../FreeSpec.html#taggingTests">Tagging tests</a>
section in its documentation for more information.</p><p>Note that one difference between this class and its sister class
<code>org.scalatest.FreeSpec</code> is that because tests are executed at construction time, rather than each
time run is invoked, an <code>org.scalatest.path.FreeSpec</code> will always execute all non-ignored tests. When
<code>run</code> is invoked on a <code>path.FreeSpec</code>, if some tests are excluded based on tags, the registered
results of running those tests will not be reported. (But those tests will have already run and the results
registered.) By contrast, because an <code>org.scalatest.FreeSpec</code> only executes tests after <code>run</code>
has been called, and at that time the tags to include and exclude are known, only tests selected by the tags
will be executed.</p><p>In short, in an <code>org.scalatest.FreeSpec</code>, tests not selected by the tags to include
and exclude specified for the run (via the <code>Filter</code> passed to <code>run</code>) will not be executed.
In an <code>org.scalatest.path.FreeSpec</code>, by contrast, all non-ignored tests will be executed, each
during the construction of its own instance, and tests not selected by the tags to include and exclude specified
for a run will not be reported. (One upshot of this is that if you have tests that you want to tag as being slow so
you can sometimes exclude them during a run, you probably don't want to put them in a <code>path.FreeSpec</code>. Because
in a <code>path.Freespec</code> the slow tests will be run regardless, with only their registered results not being <em>reported</em>
if you exclude slow tests during a run.)</p><p><a name="SharedTests"></a></p><h4> Shared tests </h4><p>You can factor out shared tests in an <code>org.scalatest.path.FreeSpec</code> in the same manner as in
an <code>org.scalatest.FreeSpec</code>. Please see the <a href="../FreeSpec.html#SharedTests">Shared tests</a>
section in its documentation for more information.</p><p><a name="nestedSuites"></a></p><h4> Nested suites </h4><p>Nested suites are not allowed in a <code>path.FreeSpec</code>. Because
a <code>path.FreeSpec</code> executes tests eagerly at construction time, registering the results of those test runs
and reporting them later when <code>run</code> is invoked, the order of nested suites versus test runs would be
different in a <code>org.scalatest.path.FreeSpec</code> than in an <code>org.scalatest.FreeSpec</code>. In
<code>org.scalatest.FreeSpec</code>'s implementation of <code>run</code>, nested suites are executed then tests
are executed. A <code>org.scalatest.path.FreeSpec</code> with nested suites would execute these in the opposite
order: first tests then nested suites. To help make <code>path.FreeSpec</code> code easier to
reason about by giving readers of one less difference to think about, nested suites are not allowed. If you want
to add nested suites to a <code>path.FreeSpec</code>, you can instead wrap them all in a
<a href="../Suites.html"><code>Suites</code></a> object. They will
be executed in the order of appearance (unless a <a href="../Distributor">Distributor</a> is passed, in which case
they will execute in parallel).</p><p><a name="durations"></a></p><h4> Durations </h4><p>Many ScalaTest events include a duration that indicates how long the event being reported took to execute. For
example, a <code>TestSucceeded</code> event provides a duration indicating how long it took for that test
to execute. A <code>SuiteCompleted</code> event provides a duration indicating how long it took for that entire
suite of tests to execute.</p><p>In the test completion events fired by a <code>path.FreeSpec</code> (<code>TestSucceeded</code>,
<code>TestFailed</code>, or <code>TestPending</code>), the durations reported refer
to the time it took for the tests to run. This time is registered with the test results and reported along
with the test results each time <code>run</code> is invoked.
By contrast, the suite completion events fired for a <code>path.FreeSpec</code> represent the amount of time
it took to report the registered results. (These events are not fired by <code>path.FreeSpec</code>, but instead
by the entity that invokes <code>run</code> on the <code>path.FreeSpec</code>.) As a result, the total time
for running the tests of a <code>path.FreeSpec</code>, calculated by summing the durations of all the individual
test completion events, may be greater than the duration reported for executing the entire suite.</p></div></div>
    </li><li name="org.scalatest.path.FreeSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecLikeextendsSuitewithOneInstancePerTestwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FreeSpecLike:FreeSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FreeSpecLike.html"><span class="name">FreeSpecLike</span></a><span class="result"> extends <a href="../Suite.html" class="extype" name="org.scalatest.Suite">Suite</a> with <a href="../OneInstancePerTest.html" class="extype" name="org.scalatest.OneInstancePerTest">OneInstancePerTest</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.path.package@FreeSpecLikeextendsSuitewithOneInstancePerTestwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>path.FreeSpec</code>, which is
a sister class to <code>org.scalatest.FreeSpec</code> that isolates
tests by running each test in its own instance of the test class, and
for each test, only executing the <em>path</em> leading to that test.</em></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>path.FreeSpec</code>, which is
a sister class to <code>org.scalatest.FreeSpec</code> that isolates
tests by running each test in its own instance of the test class, and
for each test, only executing the <em>path</em> leading to that test.</p><p><a href="FreeSpec.html"><code>path.FreeSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>path.FreeSpec</code> into some other class, you can use this
trait instead, because class <code>path.FreeSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FreeSpec.html">detailed
overview of <code>path.FreeSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.path.FunSpec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FunSpecextendsFunSpecLike"></a>
      <a id="FunSpec:FunSpec"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="FunSpec.html"><span class="name">FunSpec</span></a><span class="result"> extends <a href="FunSpecLike.html" class="extype" name="org.scalatest.path.FunSpecLike">FunSpecLike</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.path.package@FunSpecextendsFunSpecLike" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A sister class to <code>org.scalatest.FunSpec</code> that isolates tests by running each test in its own
instance of the test class, and for each test, only executing the <em>path</em> leading to that test.</em></code></p><div class="fullcomment"><div class="comment cmt"><p>A sister class to <code>org.scalatest.FunSpec</code> that isolates tests by running each test in its own
instance of the test class, and for each test, only executing the <em>path</em> leading to that test.</p><p>Class <code>path.FunSpec</code> behaves similarly to class <code>org.scalatest.FunSpec</code>, except that tests
are isolated based on their path. The purpose of <code>path.FunSpec</code> is to facilitate writing
specification-style tests for mutable objects in a clear, boilerpate-free way. To test mutable objects, you need to
mutate them. Using a path class, you can make a statement in text, then implement that statement in code (including
mutating state), and nest and combine these test/code pairs in any way you wish. Each test will only see
the side effects of code that is in blocks that enclose the test. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.path
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">path.FunSpec</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  describe(<span class="stQuotedString">"A ListBuffer"</span>) {
<br/>    <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>] <span class="stLineComment">// This implements "A ListBuffer"</span>
<br/>    it(<span class="stQuotedString">"should be empty when created"</span>) {
<br/>      <span class="stLineComment">// This test sees:</span>
      <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
      <span class="stLineComment">// So buf is: ListBuffer()</span>
<br/>      buf should be (<span class="stQuotedString">'empty</span>)
    }
<br/>    describe(<span class="stQuotedString">"when 1 is appended"</span>) {
<br/>      buf += <span class="stLiteral">1</span> <span class="stLineComment">// This implements "when 1 is appended", etc...</span>
<br/>      it(<span class="stQuotedString">"should contain 1"</span>) {
<br/>        <span class="stLineComment">// This test sees:</span>
        <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
        <span class="stLineComment">//   buf += 1</span>
        <span class="stLineComment">// So buf is: ListBuffer(1)</span>
<br/>        buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
        buf should be (<span class="stQuotedString">'empty</span>)
      }
<br/>      describe(<span class="stQuotedString">"when 2 is appended"</span>) {
<br/>        buf += <span class="stLiteral">2</span>
<br/>        it(<span class="stQuotedString">"should contain 1 and 2"</span>) {
<br/>          <span class="stLineComment">// This test sees:</span>
          <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
          <span class="stLineComment">//   buf += 1</span>
          <span class="stLineComment">//   buf += 2</span>
          <span class="stLineComment">// So buf is: ListBuffer(1, 2)</span>
<br/>          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        describe(<span class="stQuotedString">"when 2 is removed"</span>) {
<br/>          buf -= <span class="stLiteral">2</span>
<br/>          it(<span class="stQuotedString">"should contain only 1 again"</span>) {
<br/>            <span class="stLineComment">// This test sees:</span>
            <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
            <span class="stLineComment">//   buf += 1</span>
            <span class="stLineComment">//   buf += 2</span>
            <span class="stLineComment">//   buf -= 2</span>
            <span class="stLineComment">// So buf is: ListBuffer(1)</span>
<br/>            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
        }
<br/>        describe(<span class="stQuotedString">"when 3 is appended"</span>) {
<br/>          buf += <span class="stLiteral">3</span>
<br/>          it(<span class="stQuotedString">"should contain 1, 2, and 3"</span>) {
<br/>            <span class="stLineComment">// This test sees:</span>
            <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
            <span class="stLineComment">//   buf += 1</span>
            <span class="stLineComment">//   buf += 2</span>
            <span class="stLineComment">//   buf += 3</span>
            <span class="stLineComment">// So buf is: ListBuffer(1, 2, 3)</span>
<br/>            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
        }
      }
<br/>      describe(<span class="stQuotedString">"when 88 is appended"</span>) {
<br/>        buf += <span class="stLiteral">88</span>
<br/>        it(<span class="stQuotedString">"should contain 1 and 88"</span>) {
<br/>          <span class="stLineComment">// This test sees:</span>
          <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
          <span class="stLineComment">//   buf += 1</span>
          <span class="stLineComment">//   buf += 88</span>
          <span class="stLineComment">// So buf is: ListBuffer(1, 88)</span>
<br/>          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">88</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
      }
    }
<br/>    it(<span class="stQuotedString">"should have size 0 when created"</span>) {
<br/>      <span class="stLineComment">// This test sees:</span>
      <span class="stLineComment">//   val buf = ListBuffer.empty[Int]</span>
      <span class="stLineComment">// So buf is: ListBuffer()</span>
<br/>      buf should have size <span class="stLiteral">0</span>
    }
  }
}
</pre></p><p>Note that the above class is organized by writing a bit of specification text that opens a new block followed
by, at the top of the new block, some code that &quot;implements&quot; or &quot;performs&quot; what is described in the text. This is repeated as
the mutable object (here, a <code>ListBuffer</code>), is prepared for the enclosed tests. For example:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"A ListBuffer"</span>) {
  <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>]
</pre></p><p>Or:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"when 2 is appended"</span>) {
  buf += <span class="stLiteral">2</span>
</pre></p><p>Note also that although each test mutates the <code>ListBuffer</code>, none of the other tests observe those
side effects:</p><p><pre class="stHighlighted">
it(<span class="stQuotedString">"should contain 1"</span>) {
<br/>  buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
  <span class="stLineComment">// ...</span>
}
<br/>describe(<span class="stQuotedString">"when 2 is appended"</span>) {
<br/>  buf += <span class="stLiteral">2</span>
<br/>  it(<span class="stQuotedString">"should contain 1 and 2"</span>) {
<br/>    <span class="stLineComment">// This test does not see the buf.remove(0) from the previous test,</span>
    <span class="stLineComment">// so the first element in the ListBuffer is again 1</span>
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
</pre></p><p>This kind of isolation of tests from each other is a consequence of running each test in its own instance of the test
class, and can also be achieved by simply mixing <code>OneInstancePerTest</code> into a regular
<code>org.scalatest.FunSpec</code>. However, <code>path.FunSpec</code> takes isolation one step further: a test
in a <code>path.FunSpec</code> does not observe side effects performed outside tests in earlier blocks that do not
enclose it. Here's an example:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"when 2 is removed"</span>) {
<br/>  buf -= <span class="stLiteral">2</span>
<br/>  <span class="stLineComment">// ...</span>
}
<br/>describe(<span class="stQuotedString">"when 3 is appended"</span>) {
<br/>  buf += <span class="stLiteral">3</span>
<br/>  it(<span class="stQuotedString">"should contain 1, 2, and 3"</span>) {
<br/>    <span class="stLineComment">// This test does not see the buf -= 2 from the earlier "when 2 is removed" block,</span>
    <span class="stLineComment">// because that block does not enclose this test, so the second element in the</span>
    <span class="stLineComment">// ListBuffer is still 2</span>
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
    buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
</pre></p><p>Running the full <code>ExampleSpec</code>, shown above, in the Scala interpeter would give you:</p><p><pre class="stREPL">
scala> import org.scalatest._
import org.scalatest._

scala> run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
A ListBuffer
- should be empty when created
&nbsp; when 1 is appended
&nbsp; - should contain 1
&nbsp;   when 2 is appended
&nbsp;   - should contain 1 and 2
&nbsp;     when 2 is removed
&nbsp;     - should contain only 1 again
&nbsp;     when 3 is appended
&nbsp;     - should contain 1, 2, and 3
&nbsp;   when 88 is appended
&nbsp;   - should contain 1 and 88
- should have size 0 when created</span>
</pre></p><p><em>Note: class <code>path.FunSpec</code>'s approach to isolation was inspired in part by the
<a href="https://github.com/orfjackal/specsy">specsy</a> framework, written by Esko Luontola.</em></p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is objects or other artifacts (such as files, sockets, database
connections, <em>etc.</em>) used by tests to do their work.
If a fixture is used by only one test, then the definitions of the fixture objects can
be local to the method. If multiple tests need to share an immutable fixture, you can simply
assign them to instance variables. If multiple tests need to share mutable fixture objects or <code>var</code>s,
there's one and only one way to do it in a <code>path.FunSpec</code>: place the mutable objects lexically before
the test. Any mutations needed by the test must be placed lexically before and/or after the test.
As used here, &quot;Lexically before&quot; means that the code needs to be executed during construction of that test's
instance of the test class to <em>reach</em> the test (or put another way, the
code is along the &quot;path to the test.&quot;) &quot;Lexically after&quot; means that the code needs to be executed to exit the
constructor after the test has been executed.</p><p>The reason lexical placement is the one and only one way to share fixtures in a <code>path.FunSpec</code> is because
all of its lifecycle methods are overridden and declared <code>final</code>. Thus you can't mix in <code>BeforeAndAfter</code> or
<code>BeforeAndAfterEach</code>, because both override <code>runTest</code>, which is <code>final</code> in
a <code>path.FunSpec</code>. You also can't override <code>withFixture</code>, because <code>path.FreeSpec</code>
extends <a href="../Suite.html"><code>Suite</code></a> not <a href="../TestSuite.html"><code>TestSuite</code></a>,
where <code>withFixture</code> is defined. In short:</p><p><table style="border-collapse: collapse; border: 1px solid black; width: 70%; margin: auto">
<tr>
<th style="background-color: #CCCCCC; border-width: 1px; padding: 15px; text-align: left; border: 1px solid black; font-size: 125%; font-weight: bold">
In a <code>path.FunSpec</code>, if you need some code to execute before a test, place that code lexically before
the test. If you need some code to execute after a test, place that code lexically after the test.
</th>
</tr>
</table></p><p>The reason the life cycle methods are final, by the way, is to prevent users from attempting to combine
a <code>path.FunSpec</code>'s approach to isolation with other ways ScalaTest provides to share fixtures or
execute tests, because doing so could make the resulting test code hard to reason about. A
<code>path.FunSpec</code>'s execution model is a bit magical, but because it executes in one and only one
way, users should be able to reason about the code.
To help you visualize how a <code>path.FunSpec</code> is executed, consider the following variant of
<code>ExampleSpec</code> that includes print statements:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.path
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">path.FunSpec</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  println(<span class="stQuotedString">"Start of: ExampleSpec"</span>)
  describe(<span class="stQuotedString">"A ListBuffer"</span>) {
<br/>    println(<span class="stQuotedString">"Start of: A ListBuffer"</span>)
    <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">Int</span>]
<br/>    it(<span class="stQuotedString">"should be empty when created"</span>) {
<br/>      println(<span class="stQuotedString">"In test: should be empty when created; buf is: "</span> + buf)
      buf should be (<span class="stQuotedString">'empty</span>)
    }
<br/>    describe(<span class="stQuotedString">"when 1 is appended"</span>) {
<br/>      println(<span class="stQuotedString">"Start of: when 1 is appended"</span>)
      buf += <span class="stLiteral">1</span>
<br/>      it(<span class="stQuotedString">"should contain 1"</span>) {
<br/>        println(<span class="stQuotedString">"In test: should contain 1; buf is: "</span> + buf)
        buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
        buf should be (<span class="stQuotedString">'empty</span>)
      }
<br/>      describe(<span class="stQuotedString">"when 2 is appended"</span>) {
<br/>        println(<span class="stQuotedString">"Start of: when 2 is appended"</span>)
        buf += <span class="stLiteral">2</span>
<br/>        it(<span class="stQuotedString">"should contain 1 and 2"</span>) {
<br/>          println(<span class="stQuotedString">"In test: should contain 1 and 2; buf is: "</span> + buf)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        describe(<span class="stQuotedString">"when 2 is removed"</span>) {
<br/>          println(<span class="stQuotedString">"Start of: when 2 is removed"</span>)
          buf -= <span class="stLiteral">2</span>
<br/>          it(<span class="stQuotedString">"should contain only 1 again"</span>) {
<br/>            println(<span class="stQuotedString">"In test: should contain only 1 again; buf is: "</span> + buf)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
<br/>          println(<span class="stQuotedString">"End of: when 2 is removed"</span>)
        }
<br/>        describe(<span class="stQuotedString">"when 3 is appended"</span>) {
<br/>          println(<span class="stQuotedString">"Start of: when 3 is appended"</span>)
          buf += <span class="stLiteral">3</span>
<br/>          it(<span class="stQuotedString">"should contain 1, 2, and 3"</span>) {
<br/>            println(<span class="stQuotedString">"In test: should contain 1, 2, and 3; buf is: "</span> + buf)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">2</span>)
            buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">3</span>)
            buf should be (<span class="stQuotedString">'empty</span>)
          }
          println(<span class="stQuotedString">"End of: when 3 is appended"</span>)
        }
<br/>        println(<span class="stQuotedString">"End of: when 2 is appended"</span>)
      }
<br/>      describe(<span class="stQuotedString">"when 88 is appended"</span>) {
<br/>        println(<span class="stQuotedString">"Start of: when 88 is appended"</span>)
        buf += <span class="stLiteral">88</span>
<br/>        it(<span class="stQuotedString">"should contain 1 and 88"</span>) {
<br/>          println(<span class="stQuotedString">"In test: should contain 1 and 88; buf is: "</span> + buf)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">1</span>)
          buf.remove(<span class="stLiteral">0</span>) should equal (<span class="stLiteral">88</span>)
          buf should be (<span class="stQuotedString">'empty</span>)
        }
<br/>        println(<span class="stQuotedString">"End of: when 88 is appended"</span>)
      }
<br/>      println(<span class="stQuotedString">"End of: when 1 is appended"</span>)
    }
<br/>    it(<span class="stQuotedString">"should have size 0 when created"</span>) {
<br/>      println(<span class="stQuotedString">"In test: should have size 0 when created; buf is: "</span> + buf)
      buf should have size <span class="stLiteral">0</span>
    }
<br/>    println(<span class="stQuotedString">"End of: A ListBuffer"</span>)
  }
  println(<span class="stQuotedString">"End of: ExampleSpec"</span>)
  println()
}
</pre></p><p>Running the above version of <code>ExampleSpec</code> in the Scala interpreter will give you output similar to:</p><p><pre class="stREPL">
scala> import org.scalatest._
import org.scalatest._

scala> run(new ExampleSpec)
<span class="stGreen">ExampleSpec:</span>
Start of: ExampleSpec
Start of: A ListBuffer
In test: should be empty when created; buf is: ListBuffer()
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
In test: should contain 1; buf is: ListBuffer(1)
ExampleSpec:
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
In test: should contain 1 and 2; buf is: ListBuffer(1, 2)
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
Start of: when 2 is removed
In test: should contain only 1 again; buf is: ListBuffer(1)
End of: when 2 is removed
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 2 is appended
Start of: when 3 is appended
In test: should contain 1, 2, and 3; buf is: ListBuffer(1, 2, 3)
End of: when 3 is appended
End of: when 2 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
Start of: when 1 is appended
Start of: when 88 is appended
In test: should contain 1 and 88; buf is: ListBuffer(1, 88)
End of: when 88 is appended
End of: when 1 is appended
End of: A ListBuffer
End of: ExampleSpec

Start of: ExampleSpec
Start of: A ListBuffer
In test: should have size 0 when created; buf is: ListBuffer()
End of: A ListBuffer
End of: ExampleSpec

<span class="stGreen">A ListBuffer
- should be empty when created
  when 1 is appended
&nbsp; - should contain 1
&nbsp;   when 2 is appended
&nbsp;   - should contain 1 and 2
&nbsp;     when 2 is removed
&nbsp;     - should contain only 1 again
&nbsp;     when 3 is appended
&nbsp;     - should contain 1, 2, and 3
&nbsp;   when 88 is appended
&nbsp;   - should contain 1 and 88
- should have size 0 when created</span>
</pre></p><p>Note that each test is executed in order of appearance in the <code>path.FunSpec</code>, and that only
those <code>println</code> statements residing in blocks that enclose the test being run are executed. Any
<code>println</code> statements in blocks that do not form the &quot;path&quot; to a test are not executed in the
instance of the class that executes that test.</p><p><a name="howItExecutes"></a></p><h4> How it executes </h4><p>To provide its special brand of test isolation, <code>path.FunSpec</code> executes quite differently from its
sister class in <code>org.scalatest</code>. An <code>org.scalatest.FunSpec</code>
registers tests during construction and executes them when <code>run</code> is invoked. An
<code>org.scalatest.path.FunSpec</code>, by contrast, runs each test in its own instance <em>while that
instance is being constructed</em>. During construction, it registers not the tests to run, but the results of
running those tests. When <code>run</code> is invoked on a <code>path.FunSpec</code>, it reports the registered
results and does not run the tests again. If <code>run</code> is invoked a second or third time, in fact,
a <code>path.FunSpec</code> will each time report the same results registered during construction. If you want
to run the tests of a <code>path.FunSpec</code> anew, you'll need to create a new instance and invoke
<code>run</code> on that.</p><p>A <code>path.FunSpec</code> will create one instance for each &quot;leaf&quot; node it contains. The main kind of leaf node is
a test, such as:</p><p><pre class="stHighlighted">
<span class="stLineComment">// One instance will be created for each test</span>
it(<span class="stQuotedString">"should be empty when created"</span>) {
  buf should be (<span class="stQuotedString">'empty</span>)
}
</pre></p><p>However, an empty scope (a scope that contains no tests or nested scopes) is also a leaf node:</p><p><pre class="stHighlighted">
<span class="stLineComment">// One instance will be created for each empty scope</span>
describe(<span class="stQuotedString">"when 99 is added"</span>) {
  <span class="stLineComment">// A scope is "empty" and therefore a leaf node if it has no</span>
  <span class="stLineComment">// tests or nested scopes, though it may have other code (which</span>
  <span class="stLineComment">// will be executed in the instance created for that leaf node)</span>
  buf += <span class="stLiteral">99</span>
}
</pre></p><p>The tests will be executed sequentially, in the order of appearance. The first test (or empty scope,
if that is first) will be executed when a class that mixes in <code>path.FunSpec</code> is
instantiated. Only the first test will be executed during this initial instance, and of course, only
the path to that test. Then, the first time the client uses the initial instance (by invoking one of <code>run</code>,
<code>expectedTestsCount</code>, <code>tags</code>, or <code>testNames</code> on the instance), the initial instance will,
before doing anything else, ensure that any remaining tests are executed, each in its own instance.</p><p>To ensure that the correct path is taken in each instance, and to register its test results, the initial
<code>path.FunSpec</code> instance must communicate with the other instances it creates for running any subsequent
leaf nodes. It does so by setting a thread-local variable prior to creating each instance (a technique
suggested by Esko Luontola). Each instance
of <code>path.FunSpec</code> checks the thread-local variable. If the thread-local is not set, it knows it
is an initial instance and therefore executes every block it encounters until it discovers, and executes the
first test (or empty scope, if that's the first leaf node). It then discovers, but does not execute the next
leaf node, or discovers there are no other leaf nodes remaining to execute. It communicates the path to the next
leaf node, if any, and the result of running the test it did execute, if any, back to the initial instance. The
initial instance repeats this process until all leaf nodes have been executed and all test results registered.</p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>You mark a test as ignored in an <code>org.scalatest.path.FunSpec</code> in the same manner as in
an <code>org.scalatest.FunSpec</code>. Please see the <a href="../FunSpec.html#ignoredTests">Ignored tests</a> section
in its documentation for more information.</p><p>Note that a separate instance will be created for an ignored test,
and the path to the ignored test will be executed in that instance, but the test function itself will not
be executed. Instead, a <code>TestIgnored</code> event will be fired.</p><p><a name="informers"></a></p><h4> Informers </h4><p>You output information using <code>Informer</code>s in an <code>org.scalatest.path.FunSpec</code> in the same manner
as in an <code>org.scalatest.FunSpec</code>. Please see the <a href="../FunSpec.html#informers">Informers</a>
section in its documentation for more information.</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>You mark a test as pending in an <code>org.scalatest.path.FunSpec</code> in the same manner as in
an <code>org.scalatest.FunSpec</code>. Please see the <a href="../FunSpec.html#pendingTests">Pending tests</a>
section in its documentation for more information.</p><p>Note that a separate instance will be created for a pending test,
and the path to the ignored test will be executed in that instance, as well as the test function (up until it
completes abruptly with a <code>TestPendingException</code>).</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>You can place tests into groups by tagging them in an <code>org.scalatest.path.FunSpec</code> in the same manner
as in an <code>org.scalatest.FunSpec</code>. Please see the <a href="../FunSpec.html#taggingTests">Tagging tests</a>
section in its documentation for more information.</p><p>Note that one difference between this class and its sister class
<code>org.scalatest.FunSpec</code> is that because tests are executed at construction time, rather than each
time run is invoked, an <code>org.scalatest.path.FunSpec</code> will always execute all non-ignored tests. When
<code>run</code> is invoked on a <code>path.FunSpec</code>, if some tests are excluded based on tags, the registered
results of running those tests will not be reported. (But those tests will have already run and the results
registered.) By contrast, because an <code>org.scalatest.FunSpec</code> only executes tests after <code>run</code>
has been called, and at that time the tags to include and exclude are known, only tests selected by the tags
will be executed.</p><p>In short, in an <code>org.scalatest.FunSpec</code>, tests not selected by the tags to include
and exclude specified for the run (via the <code>Filter</code> passed to <code>run</code>) will not be executed.
In an <code>org.scalatest.path.FunSpec</code>, by contrast, all non-ignored tests will be executed, each
during the construction of its own instance, and tests not selected by the tags to include and exclude specified
for a run will not be reported. (One upshot of this is that if you have tests that you want to tag as being slow so
you can sometimes exclude them during a run, you probably don't want to put them in a <code>path.FunSpec</code>. Because
in a <code>path.Freespec</code> the slow tests will be run regardless, with only their registered results not being <em>reported</em>
if you exclude slow tests during a run.)</p><p><a name="SharedTests"></a></p><h4> Shared tests </h4><p>You can factor out shared tests in an <code>org.scalatest.path.FunSpec</code> in the same manner as in
an <code>org.scalatest.FunSpec</code>. Please see the <a href="../FunSpec.html#SharedTests">Shared tests</a>
section in its documentation for more information.</p><p><a name="nestedSuites"></a></p><h4> Nested suites </h4><p>Nested suites are not allowed in a <code>path.FunSpec</code>. Because
a <code>path.FunSpec</code> executes tests eagerly at construction time, registering the results of those test runs
and reporting them later when <code>run</code> is invoked, the order of nested suites versus test runs would be
different in a <code>org.scalatest.path.FunSpec</code> than in an <code>org.scalatest.FunSpec</code>. In
<code>org.scalatest.FunSpec</code>'s implementation of <code>run</code>, nested suites are executed then tests
are executed. A <code>org.scalatest.path.FunSpec</code> with nested suites would execute these in the opposite
order: first tests then nested suites. To help make <code>path.FunSpec</code> code easier to
reason about by giving readers of one less difference to think about, nested suites are not allowed. If you want
to add nested suites to a <code>path.FunSpec</code>, you can instead wrap them all in a
<a href="../Suites.html"><code>Suites</code></a> object. They will
be executed in the order of appearance (unless a <a href="../Distributor">Distributor</a> is passed, in which case
they will execute in parallel).</p><p><a name="durations"></a></p><h4> Durations </h4><p>Many ScalaTest events include a duration that indicates how long the event being reported took to execute. For
example, a <code>TestSucceeded</code> event provides a duration indicating how long it took for that test
to execute. A <code>SuiteCompleted</code> event provides a duration indicating how long it took for that entire
suite of tests to execute.</p><p>In the test completion events fired by a <code>path.FunSpec</code> (<code>TestSucceeded</code>,
<code>TestFailed</code>, or <code>TestPending</code>), the durations reported refer
to the time it took for the tests to run. This time is registered with the test results and reported along
with the test results each time <code>run</code> is invoked.
By contrast, the suite completion events fired for a <code>path.FunSpec</code> represent the amount of time
it took to report the registered results. (These events are not fired by <code>path.FunSpec</code>, but instead
by the entity that invokes <code>run</code> on the <code>path.FunSpec</code>.) As a result, the total time
for running the tests of a <code>path.FunSpec</code>, calculated by summing the durations of all the individual
test completion events, may be greater than the duration reported for executing the entire suite.</p></div></div>
    </li><li name="org.scalatest.path.FunSpecLike" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSpecLikeextendsSuitewithOneInstancePerTestwithInformingwithNotifyingwithAlertingwithDocumenting"></a>
      <a id="FunSpecLike:FunSpecLike"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="FunSpecLike.html"><span class="name">FunSpecLike</span></a><span class="result"> extends <a href="../Suite.html" class="extype" name="org.scalatest.Suite">Suite</a> with <a href="../OneInstancePerTest.html" class="extype" name="org.scalatest.OneInstancePerTest">OneInstancePerTest</a> with <a href="../Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="../Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="../Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="../Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#org.scalatest.path.package@FunSpecLikeextendsSuitewithOneInstancePerTestwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implementation trait for class <code>path.FunSpec</code>, which is
a sister class to <code>org.scalatest.FunSpec</code> that isolates
tests by running each test in its own instance of the test class,
and for each test, only executing the <em>path</em> leading to that test.</em></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>path.FunSpec</code>, which is
a sister class to <code>org.scalatest.FunSpec</code> that isolates
tests by running each test in its own instance of the test class,
and for each test, only executing the <em>path</em> leading to that test.</p><p><a href="FunSpec.html"><code>path.FunSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>path.FunSpec</code> into some other class, you can use this
trait instead, because class <code>path.FunSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FunSpec.html">detailed
overview of <code>path.FunSpec</code></a>.</p></div></div>
    </li></ol>
            </div>

        

        

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
