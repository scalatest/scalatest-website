<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>ScalaTest 3.0.8  - org.scalatest</title>
          <meta name="description" content="ScalaTest 3.0.8 - org.scalatest" />
          <meta name="keywords" content="ScalaTest 3.0.8 org.scalatest" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NJWCS90VG5"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-NJWCS90VG5');

</script>
        </head>
        <body>
      <div id="search">
        <span id="doc-title">ScalaTest 3.0.8<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.org" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="org"></a><a id="org:org"></a>
      <span class="permalink">
      <a href="index.html#org" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">org</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="org.scalatest" visbl="pub" class="indented2 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scalatest"></a><a id="scalatest:scalatest"></a>
      <span class="permalink">
      <a href="../org/index.html#scalatest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">scalatest</span>
      </span>
      
      <p class="shortcomment cmt">ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.</p><div class="fullcomment"><div class="comment cmt"><p>ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li><li name="org.scalatest.compatible" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="compatible"></a><a id="compatible:compatible"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#compatible" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="compatible/index.html"><span class="name">compatible</span></a>
      </span>
      
      
    </li><li name="org.scalatest.concurrent" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="concurrent"></a><a id="concurrent:concurrent"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#concurrent" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter." href="concurrent/index.html"><span class="name">concurrent</span></a>
      </span>
      
      <p class="shortcomment cmt">ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.</p>
    </li><li name="org.scalatest.easymock" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="easymock"></a><a id="easymock:easymock"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#easymock" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="easymock/index.html"><span class="name">easymock</span></a>
      </span>
      
      
    </li><li name="org.scalatest.enablers" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="enablers"></a><a id="enablers:enablers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#enablers" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="enablers/index.html"><span class="name">enablers</span></a>
      </span>
      
      
    </li><li name="org.scalatest.events" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="events"></a><a id="events:events"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#events" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="events/index.html"><span class="name">events</span></a>
      </span>
      
      
    </li><li name="org.scalatest.exceptions" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="exceptions"></a><a id="exceptions:exceptions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#exceptions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="exceptions/index.html"><span class="name">exceptions</span></a>
      </span>
      
      
    </li><li name="org.scalatest.fixture" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="fixture"></a><a id="fixture:fixture"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#fixture" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="fixture/index.html"><span class="name">fixture</span></a>
      </span>
      
      
    </li><li name="org.scalatest.jmock" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="jmock"></a><a id="jmock:jmock"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#jmock" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="jmock/index.html"><span class="name">jmock</span></a>
      </span>
      
      
    </li><li name="org.scalatest.junit" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="junit"></a><a id="junit:junit"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#junit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="junit/index.html"><span class="name">junit</span></a>
      </span>
      
      
    </li><li name="org.scalatest.matchers" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="matchers"></a><a id="matchers:matchers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#matchers" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="matchers/index.html"><span class="name">matchers</span></a>
      </span>
      
      
    </li><li name="org.scalatest.mockito" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="mockito"></a><a id="mockito:mockito"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#mockito" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="mockito/index.html"><span class="name">mockito</span></a>
      </span>
      
      
    </li><li name="org.scalatest.path" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="path"></a><a id="path:path"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#path" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="path/index.html"><span class="name">path</span></a>
      </span>
      
      
    </li><li name="org.scalatest.prop" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="prop"></a><a id="prop:prop"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#prop" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter." href="prop/index.html"><span class="name">prop</span></a>
      </span>
      
      <p class="shortcomment cmt">ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.</p>
    </li><li name="org.scalatest.refspec" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="refspec"></a><a id="refspec:refspec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#refspec" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="refspec/index.html"><span class="name">refspec</span></a>
      </span>
      
      
    </li><li name="org.scalatest.selenium" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="selenium"></a><a id="selenium:selenium"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#selenium" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="selenium/index.html"><span class="name">selenium</span></a>
      </span>
      
      
    </li><li name="org.scalatest.tagobjects" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="tagobjects"></a><a id="tagobjects:tagobjects"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#tagobjects" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="tagobjects/index.html"><span class="name">tagobjects</span></a>
      </span>
      
      
    </li><li name="org.scalatest.tags" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="tags"></a><a id="tags:tags"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#tags" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="tags/index.html"><span class="name">tags</span></a>
      </span>
      
      
    </li><li name="org.scalatest.testng" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="testng"></a><a id="testng:testng"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#testng" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="testng/index.html"><span class="name">testng</span></a>
      </span>
      
      
    </li><li name="org.scalatest.time" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="time"></a><a id="time:time"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#time" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="time/index.html"><span class="name">time</span></a>
      </span>
      
      
    </li><li name="org.scalatest.tools" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="tools"></a><a id="tools:tools"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#tools" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="tools/index.html"><span class="name">tools</span></a>
      </span>
      
      
    </li><li name="org.scalatest.words" visbl="pub" class="indented3 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="words"></a><a id="words:words"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#words" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="words/index.html"><span class="name">words</span></a>
      </span>
      
      
    </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Alerter.html" title="Trait providing an apply method to which alert messages about a running suite of tests can be reported."></a>
                        <a href="Alerter.html" title="Trait providing an apply method to which alert messages about a running suite of tests can be reported.">Alerter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Alerting.html" title="Trait that contains the alert method, which can be used to send an alert to the reporter."></a>
                        <a href="Alerting.html" title="Trait that contains the alert method, which can be used to send an alert to the reporter.">Alerting</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="AppendedClues$.html" title="Companion object that facilitates the importing of AppendedClues members as an alternative to mixing it in."></a>
                        <a class="trait" href="AppendedClues.html" title="Trait providing an implicit conversion that allows clues to be placed after a block of code."></a>
                        <a href="AppendedClues.html" title="Trait providing an implicit conversion that allows clues to be placed after a block of code.">AppendedClues</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Args.html" title="Arguments bundle passed to four of ScalaTest's lifecycle methods: run, runNestedSuites, runTests, and runTest."></a>
                        <a href="Args.html" title="Arguments bundle passed to four of ScalaTest's lifecycle methods: run, runNestedSuites, runTests, and runTest.">Args</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Assertions$.html" title="Companion object that facilitates the importing of Assertions members as an alternative to mixing it in."></a>
                        <a class="trait" href="Assertions.html" title="Trait that contains ScalaTest's basic assertion methods."></a>
                        <a href="Assertions.html" title="Trait that contains ScalaTest's basic assertion methods.">Assertions</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncFeatureSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FeatureSpec tests."></a>
                        <a href="AsyncFeatureSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FeatureSpec tests.">AsyncFeatureSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncFeatureSpecLike.html" title="Implementation trait for class AsyncFeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature."></a>
                        <a href="AsyncFeatureSpecLike.html" title="Implementation trait for class AsyncFeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature.">AsyncFeatureSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncFlatSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FlatSpec tests."></a>
                        <a href="AsyncFlatSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FlatSpec tests.">AsyncFlatSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncFlatSpecLike.html" title="Implementation trait for class AsyncFlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="AsyncFlatSpecLike.html" title="Implementation trait for class AsyncFlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">AsyncFlatSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncFreeSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FreeSpec tests."></a>
                        <a href="AsyncFreeSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FreeSpec tests.">AsyncFreeSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncFreeSpecLike.html" title="Implementation trait for class AsyncFreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)."></a>
                        <a href="AsyncFreeSpecLike.html" title="Implementation trait for class AsyncFreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-).">AsyncFreeSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncFunSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSpec tests."></a>
                        <a href="AsyncFunSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSpec tests.">AsyncFunSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncFunSpecLike.html" title="Implementation trait for class AsyncFunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="AsyncFunSpecLike.html" title="Implementation trait for class AsyncFunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">AsyncFunSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncFunSuite.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSuite tests."></a>
                        <a href="AsyncFunSuite.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSuite tests.">AsyncFunSuite</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncFunSuiteLike.html" title="Implementation trait for class AsyncFunSuite, which represents a suite of tests in which each test is represented as a function value."></a>
                        <a href="AsyncFunSuiteLike.html" title="Implementation trait for class AsyncFunSuite, which represents a suite of tests in which each test is represented as a function value.">AsyncFunSuiteLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncTestRegistration.html" title="Trait declaring methods that can be used to register by-name test functions that have result type Future[Assertion]."></a>
                        <a href="AsyncTestRegistration.html" title="Trait declaring methods that can be used to register by-name test functions that have result type Future[Assertion].">AsyncTestRegistration</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncTestSuite.html" title="The base trait of ScalaTest's asynchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns a FutureOutcome."></a>
                        <a href="AsyncTestSuite.html" title="The base trait of ScalaTest's asynchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns a FutureOutcome.">AsyncTestSuite</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncTestSuiteMixin.html" title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in AsyncTestSuite and can be overridden in stackable modification traits."></a>
                        <a href="AsyncTestSuiteMixin.html" title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in AsyncTestSuite and can be overridden in stackable modification traits.">AsyncTestSuiteMixin</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="AsyncWordSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional WordSpec tests."></a>
                        <a href="AsyncWordSpec.html" title="Enables testing of asynchronous code without blocking, using a style consistent with traditional WordSpec tests.">AsyncWordSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="AsyncWordSpecLike.html" title="Implementation trait for class AsyncWordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="AsyncWordSpecLike.html" title="Implementation trait for class AsyncWordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">AsyncWordSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="BeforeAndAfter.html" title="Trait that can be mixed into suites that need code executed before and after running each test."></a>
                        <a href="BeforeAndAfter.html" title="Trait that can be mixed into suites that need code executed before and after running each test.">BeforeAndAfter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="BeforeAndAfterAll.html" title="Stackable trait that can be mixed into suites that need methods invoked before and after executing the suite."></a>
                        <a href="BeforeAndAfterAll.html" title="Stackable trait that can be mixed into suites that need methods invoked before and after executing the suite.">BeforeAndAfterAll</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="BeforeAndAfterAllConfigMap.html" title="Trait that can be mixed into suites that need methods that make use of the config map invoked before and/or after executing the suite."></a>
                        <a href="BeforeAndAfterAllConfigMap.html" title="Trait that can be mixed into suites that need methods that make use of the config map invoked before and/or after executing the suite.">BeforeAndAfterAllConfigMap</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="BeforeAndAfterEach.html" title="Stackable trait that can be mixed into suites that need code executed before and/or after running each test."></a>
                        <a href="BeforeAndAfterEach.html" title="Stackable trait that can be mixed into suites that need code executed before and/or after running each test.">BeforeAndAfterEach</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="BeforeAndAfterEachTestData.html" title="Stackable trait that can be mixed into suites that need code that makes use of test data (test name, tags, config map, etc.) executed before and/or after running each test."></a>
                        <a href="BeforeAndAfterEachTestData.html" title="Stackable trait that can be mixed into suites that need code that makes use of test data (test name, tags, config map, etc.) executed before and/or after running each test.">BeforeAndAfterEachTestData</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="CancelAfterFailure.html" title="Trait that when mixed into a TestSuite cancels any remaining tests in that TestSuite instance after a test fails."></a>
                        <a href="CancelAfterFailure.html" title="Trait that when mixed into a TestSuite cancels any remaining tests in that TestSuite instance after a test fails.">CancelAfterFailure</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Canceled$.html" title="Companion object to class Canceled that provides, in addition to the extractor and factory method provided by the compiler given its companion is a case class, a second factory method that produces a Canceled outcome given a string message."></a>
                        <a class="class" href="Canceled.html" title="Outcome for a test that was canceled, containing an exception describing the cause of the cancelation."></a>
                        <a href="Canceled.html" title="Outcome for a test that was canceled, containing an exception describing the cause of the cancelation.">Canceled</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Checkpoints$.html" title="Companion object that facilitates the importing the members of trait Checkpoints as an alternative to mixing it in."></a>
                        <a class="trait" href="Checkpoints.html" title="Trait providing class Checkpoint, which enables multiple assertions to be performed within a test, with any failures accumulated and reported together at the end of the test."></a>
                        <a href="Checkpoints.html" title="Trait providing class Checkpoint, which enables multiple assertions to be performed within a test, with any failures accumulated and reported together at the end of the test.">Checkpoints</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="CompleteLastly$.html" title="Companion object that facilitates the importing of CompleteLastly members as an alternative to mixing it in."></a>
                        <a class="trait" href="CompleteLastly.html" title="Trait that provides a complete-lastly construct, which ensures cleanup code in lastly is executed whether the code passed to complete completes abruptly with an exception or successfully results in a Future, FutureOutcome, or other type with an implicit Futuristic instance."></a>
                        <a href="CompleteLastly.html" title="Trait that provides a complete-lastly construct, which ensures cleanup code in lastly is executed whether the code passed to complete completes abruptly with an exception or successfully results in a Future, FutureOutcome, or other type with an implicit Futuristic instance.">CompleteLastly</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="CompositeStatus.html" title="Composite Status that aggregates its completion and failed states of set of other Statuses passed to its constructor."></a>
                        <a href="CompositeStatus.html" title="Composite Status that aggregates its completion and failed states of set of other Statuses passed to its constructor.">CompositeStatus</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="ConfigMap$.html" title="Companion object to class ConfigMap containing factory methods."></a>
                        <a class="class" href="ConfigMap.html" title="A map of configuration data."></a>
                        <a href="ConfigMap.html" title="A map of configuration data.">ConfigMap</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="ConfigMapWrapperSuite.html" title="Wrapper Suite that passes an instance of the config map to the constructor of the wrapped Suite when run is invoked."></a>
                        <a href="ConfigMapWrapperSuite.html" title="Wrapper Suite that passes an instance of the config map to the constructor of the wrapped Suite when run is invoked.">ConfigMapWrapperSuite</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="DiagrammedAssertions$.html" title="Companion object that facilitates the importing of DiagrammedAssertions members as an alternative to mixing it in."></a>
                        <a class="trait" href="DiagrammedAssertions.html" title="Sub-trait of Assertions that override assert and assume methods to include a diagram showing the values of expression in the error message when the assertion or assumption fails."></a>
                        <a href="DiagrammedAssertions.html" title="Sub-trait of Assertions that override assert and assume methods to include a diagram showing the values of expression in the error message when the assertion or assumption fails.">DiagrammedAssertions</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="DiagrammedExpr$.html" title="DiagrammedExpr companion object that provides factory methods to create different sub types of DiagrammedExpr"></a>
                        <a class="trait" href="DiagrammedExpr.html" title="A trait that represent an expression recorded by DiagrammedExprMacro, which includes the following members:"></a>
                        <a href="DiagrammedExpr.html" title="A trait that represent an expression recorded by DiagrammedExprMacro, which includes the following members:">DiagrammedExpr</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="DistributedSuiteSorter.html" title="A sorter for the events of a run's distributed suites."></a>
                        <a href="DistributedSuiteSorter.html" title="A sorter for the events of a run's distributed suites.">DistributedSuiteSorter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="DistributedTestSorter.html" title="A sorter for the events of a suite's distributed tests."></a>
                        <a href="DistributedTestSorter.html" title="A sorter for the events of a suite's distributed tests.">DistributedTestSorter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Distributor.html" title="Trait whose instances facilitate parallel execution of Suites."></a>
                        <a href="Distributor.html" title="Trait whose instances facilitate parallel execution of Suites.">Distributor</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="DoNotDiscover.html" title="Annotation used to indicate that an otherwise discoverable test class should not be discovered."></a>
                        <a href="DoNotDiscover.html" title="Annotation used to indicate that an otherwise discoverable test class should not be discovered.">DoNotDiscover</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Documenter.html" title="Trait to which markup text tests can be reported."></a>
                        <a href="Documenter.html" title="Trait to which markup text tests can be reported.">Documenter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Documenting.html" title="Trait that contains a markup method, which can be used to send markup to the Reporter."></a>
                        <a href="Documenting.html" title="Trait that contains a markup method, which can be used to send markup to the Reporter.">Documenting</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="DynaTags.html" title="Dynamic tags for a run."></a>
                        <a href="DynaTags.html" title="Dynamic tags for a run.">DynaTags</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="EitherValues$.html" title="Companion object that facilitates the importing of ValueEither members as an alternative to mixing it in."></a>
                        <a class="trait" href="EitherValues.html" title="Trait that provides an implicit conversion that adds left.value and right.value methods to Either, which will return the selected value of the Either if defined, or throw TestFailedException if not."></a>
                        <a href="EitherValues.html" title="Trait that provides an implicit conversion that adds left.value and right.value methods to Either, which will return the selected value of the Either if defined, or throw TestFailedException if not.">EitherValues</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Entry.html" title="A case class implementation of java.util.Map.Entry to make it easier to test Java Maps with ScalaTest Matchers."></a>
                        <a href="Entry.html" title="A case class implementation of java.util.Map.Entry to make it easier to test Java Maps with ScalaTest Matchers.">Entry</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Exceptional$.html" title="Companion object to class Exceptional that provides a factory method and an extractor that enables patterns that match both Failed and Canceled outcomes and extracts the contained exception and a factory method."></a>
                        <a class="class" href="Exceptional.html" title="Superclass for the two outcomes of running a test that contain an exception: Failed and Canceled."></a>
                        <a href="Exceptional.html" title="Superclass for the two outcomes of running a test that contain an exception: Failed and Canceled.">Exceptional</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Failed$.html" title=""></a>
                        <a class="class" href="Failed.html" title="Outcome for a test that failed, containing an exception describing the cause of the failure."></a>
                        <a href="Failed.html" title="Outcome for a test that failed, containing an exception describing the cause of the failure.">Failed</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="FailedStatus$.html" title="Singleton status that represents an already completed run with at least one failed test or aborted suite."></a>
                        <a href="FailedStatus$.html" title="Singleton status that represents an already completed run with at least one failed test or aborted suite.">FailedStatus</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="FeatureSpec.html" title="A suite of tests in which each test represents one scenario of a feature."></a>
                        <a href="FeatureSpec.html" title="A suite of tests in which each test represents one scenario of a feature.">FeatureSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FeatureSpecLike.html" title="Implementation trait for class FeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature."></a>
                        <a href="FeatureSpecLike.html" title="Implementation trait for class FeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature.">FeatureSpecLike</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Filter$.html" title=""></a>
                        <a class="class" href="Filter.html" title="Filter whose apply method determines which of the passed tests to run and ignore based on tags to include and exclude passed as as class parameters."></a>
                        <a href="Filter.html" title="Filter whose apply method determines which of the passed tests to run and ignore based on tags to include and exclude passed as as class parameters.">Filter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Finders.html" title="Annotation used to mark a trait or class as defining a testing style that has a org.scalatest.finders.Finder implementation, which IDEs and other tools can use to discover tests and scopes."></a>
                        <a href="Finders.html" title="Annotation used to mark a trait or class as defining a testing style that has a org.scalatest.finders.Finder implementation, which IDEs and other tools can use to discover tests and scopes.">Finders</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FixtureContext.html" title="Marker trait for fixture-context objects, that enables them to be used in testing styles that require type Assertion"></a>
                        <a href="FixtureContext.html" title="Marker trait for fixture-context objects, that enables them to be used in testing styles that require type Assertion">FixtureContext</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="FlatSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="FlatSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">FlatSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FlatSpecLike.html" title="Implementation trait for class FlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="FlatSpecLike.html" title="Implementation trait for class FlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">FlatSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="FreeSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)."></a>
                        <a href="FreeSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-).">FreeSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FreeSpecLike.html" title="Implementation trait for class FreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)."></a>
                        <a href="FreeSpecLike.html" title="Implementation trait for class FreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-).">FreeSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="FunSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="FunSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">FunSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FunSpecLike.html" title="Implementation trait for class FunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="FunSpecLike.html" title="Implementation trait for class FunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">FunSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="FunSuite.html" title="A suite of tests in which each test is represented as a function value."></a>
                        <a href="FunSuite.html" title="A suite of tests in which each test is represented as a function value.">FunSuite</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="FunSuiteLike.html" title="Implementation trait for class FunSuite, which represents a suite of tests in which each test is represented as a function value."></a>
                        <a href="FunSuiteLike.html" title="Implementation trait for class FunSuite, which represents a suite of tests in which each test is represented as a function value.">FunSuiteLike</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="FutureOutcome$.html" title="Companion object to FutureOutcomes that contains factory methods for creating already-completed FutureOutcomes."></a>
                        <a class="class" href="FutureOutcome.html" title="Wrapper class for Future[Outcome] that presents a more convenient API for manipulation in withFixture methods in async styles."></a>
                        <a href="FutureOutcome.html" title="Wrapper class for Future[Outcome] that presents a more convenient API for manipulation in withFixture methods in async styles.">FutureOutcome</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="GivenWhenThen.html" title="Trait that contains methods named given, when, then, and and, which take a string message and implicit Informer, and forward the message to the informer."></a>
                        <a href="GivenWhenThen.html" title="Trait that contains methods named given, when, then, and and, which take a string message and implicit Informer, and forward the message to the informer.">GivenWhenThen</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Ignore.html" title="Annotation used to tag a test, or suite of tests, as ignored."></a>
                        <a href="Ignore.html" title="Annotation used to tag a test, or suite of tests, as ignored.">Ignore</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Informer.html" title="Trait to which custom information about a running suite of tests can be reported."></a>
                        <a href="Informer.html" title="Trait to which custom information about a running suite of tests can be reported.">Informer</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Informing.html" title="Trait that contains the info method, which can be used to send info to the reporter."></a>
                        <a href="Informing.html" title="Trait that contains the info method, which can be used to send info to the reporter.">Informing</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Inside$.html" title="Companion object that facilitates the importing of the inside construct as an alternative to mixing it in."></a>
                        <a class="trait" href="Inside.html" title="Trait containing the inside construct, which allows you to make statements about nested object graphs using pattern matching."></a>
                        <a href="Inside.html" title="Trait containing the inside construct, which allows you to make statements about nested object graphs using pattern matching.">Inside</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Inspectors$.html" title="Companion object that facilitates the importing of Inspectors members as an alternative to mixing it in."></a>
                        <a class="trait" href="Inspectors.html" title="Provides nestable inspector methods (or just inspectors) that enable assertions to be made about collections."></a>
                        <a href="Inspectors.html" title="Provides nestable inspector methods (or just inspectors) that enable assertions to be made about collections.">Inspectors</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="LoneElement$.html" title="Companion object that facilitates the importing of LoneElement members as an alternative to mixing it in."></a>
                        <a class="trait" href="LoneElement.html" title="Trait that provides an implicit conversion that adds to collection types a loneElement method, which will return the value of the lone element if the collection does indeed contain one and only one element, or throw TestFailedException if not."></a>
                        <a href="LoneElement.html" title="Trait that provides an implicit conversion that adds to collection types a loneElement method, which will return the value of the lone element if the collection does indeed contain one and only one element, or throw TestFailedException if not.">LoneElement</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Matchers$.html" title="Companion object that facilitates the importing of Matchers members as an alternative to mixing it the trait."></a>
                        <a class="trait" href="Matchers.html" title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word should."></a>
                        <a href="Matchers.html" title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word should.">Matchers</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="MustMatchers$.html" title="Companion object that facilitates the importing of Matchers members as an alternative to mixing it the trait."></a>
                        <a class="trait" href="MustMatchers.html" title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word must."></a>
                        <a href="MustMatchers.html" title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word must.">MustMatchers</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="NonImplicitAssertions$.html" title="Companion object that facilitates the importing of the members of trait Assertions without importing the implicit conversions it provides by default."></a>
                        <a class="trait" href="NonImplicitAssertions.html" title="Trait that can be mixed into a Suite to disable the implicit conversions provided by default in trait Assertions, which trait Suite extends."></a>
                        <a href="NonImplicitAssertions.html" title="Trait that can be mixed into a Suite to disable the implicit conversions provided by default in trait Assertions, which trait Suite extends.">NonImplicitAssertions</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Notifier.html" title="Trait providing an apply method to which status updates about a running suite of tests can be reported."></a>
                        <a href="Notifier.html" title="Trait providing an apply method to which status updates about a running suite of tests can be reported.">Notifier</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Notifying.html" title="Trait that contains the note method, which can be used to send a status notification to the reporter."></a>
                        <a href="Notifying.html" title="Trait that contains the note method, which can be used to send a status notification to the reporter.">Notifying</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="OneInstancePerTest.html" title="Trait that facilitates a style of testing in which each test is run in its own instance of the suite class to isolate each test from the side effects of the other tests in the suite."></a>
                        <a href="OneInstancePerTest.html" title="Trait that facilitates a style of testing in which each test is run in its own instance of the suite class to isolate each test from the side effects of the other tests in the suite.">OneInstancePerTest</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="OptionValues$.html" title="Companion object that facilitates the importing of OptionValues members as an alternative to mixing it in."></a>
                        <a class="trait" href="OptionValues.html" title="Trait that provides an implicit conversion that adds a value method to Option, which will return the value of the option if it is defined, or throw TestFailedException if not."></a>
                        <a href="OptionValues.html" title="Trait that provides an implicit conversion that adds a value method to Option, which will return the value of the option if it is defined, or throw TestFailedException if not.">OptionValues</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Outcome$.html" title="Companion object for trait Outcome that contains an implicit method that enables collections of Outcomes to be flattened into a collections of contained exceptions."></a>
                        <a class="class" href="Outcome.html" title="Superclass for the possible outcomes of running a test."></a>
                        <a href="Outcome.html" title="Superclass for the possible outcomes of running a test.">Outcome</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="OutcomeOf$.html" title="Companion object that facilitates the importing of OutcomeOf's method as an alternative to mixing it in."></a>
                        <a class="trait" href="OutcomeOf.html" title="Trait that contains the outcomeOf method, which executes a passed code block and transforms the outcome into an Outcome, using the same mechanism used by ScalaTest to produce an Outcome when executing a test."></a>
                        <a href="OutcomeOf.html" title="Trait that contains the outcomeOf method, which executes a passed code block and transforms the outcome into an Outcome, using the same mechanism used by ScalaTest to produce an Outcome when executing a test.">OutcomeOf</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="ParallelTestExecution.html" title="Trait that causes that the tests of any suite it is mixed into to be run in parallel if a Distributor is passed to runTests."></a>
                        <a href="ParallelTestExecution.html" title="Trait that causes that the tests of any suite it is mixed into to be run in parallel if a Distributor is passed to runTests.">ParallelTestExecution</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="PartialFunctionValues$.html" title="Companion object that facilitates the importing of PartialFunctionValues members as an alternative to mixing it in."></a>
                        <a class="trait" href="PartialFunctionValues.html" title="Trait that provides an implicit conversion that adds a valueAt method to PartialFunction, which will return the value (result) of the function applied to the argument passed to valueAt, or throw TestFailedException if the partial function is not defined at the argument."></a>
                        <a href="PartialFunctionValues.html" title="Trait that provides an implicit conversion that adds a valueAt method to PartialFunction, which will return the value (result) of the function applied to the argument passed to valueAt, or throw TestFailedException if the partial function is not defined at the argument.">PartialFunctionValues</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Payloads$.html" title="Companion object that facilitates the importing of Payloads members as an alternative to mixing it in."></a>
                        <a class="trait" href="Payloads.html" title="Trait facilitating the inclusion of a payload in a thrown ScalaTest exception."></a>
                        <a href="Payloads.html" title="Trait facilitating the inclusion of a payload in a thrown ScalaTest exception.">Payloads</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="Pending$.html" title="Outcome for a test that was pending, which contains an optional string giving more information on what exactly is needed for the test to become non-pending."></a>
                        <a href="Pending$.html" title="Outcome for a test that was pending, which contains an optional string giving more information on what exactly is needed for the test to become non-pending.">Pending</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="PendingStatement.html" title="Trait mixed into the result type of the pending statement of trait Assertions, which always throws TestPendingException."></a>
                        <a href="PendingStatement.html" title="Trait mixed into the result type of the pending statement of trait Assertions, which always throws TestPendingException.">PendingStatement</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="PrivateMethodTester$.html" title="Companion object that facilitates the importing of PrivateMethodTester members as an alternative to mixing it in."></a>
                        <a class="trait" href="PrivateMethodTester.html" title="Trait that facilitates the testing of private methods."></a>
                        <a href="PrivateMethodTester.html" title="Trait that facilitates the testing of private methods.">PrivateMethodTester</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="PropSpec.html" title="A suite of property-based tests."></a>
                        <a href="PropSpec.html" title="A suite of property-based tests.">PropSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="PropSpecLike.html" title="Implementation trait for class PropSpec, which represents a suite of property-based tests."></a>
                        <a href="PropSpecLike.html" title="Implementation trait for class PropSpec, which represents a suite of property-based tests.">PropSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="RandomTestOrder.html" title="Trait that causes tests to be run in pseudo-random order."></a>
                        <a href="RandomTestOrder.html" title="Trait that causes tests to be run in pseudo-random order.">RandomTestOrder</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="RecoverMethods$.html" title="Companion object that facilitates the importing of RecoverMethods's method as an alternative to mixing it in."></a>
                        <a class="trait" href="RecoverMethods.html" title="Offers two methods for transforming futures when exceptions are expected."></a>
                        <a href="RecoverMethods.html" title="Offers two methods for transforming futures when exceptions are expected.">RecoverMethods</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Reporter.html" title="Trait whose instances collect the results of a running suite of tests and presents those results in some way to the user."></a>
                        <a href="Reporter.html" title="Trait whose instances collect the results of a running suite of tests and presents those results in some way to the user.">Reporter</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Rerunner.html" title="Trait whose instances can rerun tests or other entities (such as suites)."></a>
                        <a href="Rerunner.html" title="Trait whose instances can rerun tests or other entities (such as suites).">Rerunner</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="ResourcefulReporter.html" title="Subtrait of Reporter that contains a dispose method for releasing any finite, non-memory resources, such as file handles, held by the Reporter."></a>
                        <a href="ResourcefulReporter.html" title="Subtrait of Reporter that contains a dispose method for releasing any finite, non-memory resources, such as file handles, held by the Reporter.">ResourcefulReporter</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Retries$.html" title="Companion object to trait Retries that enables its members to be imported as an alternative to mixing them in."></a>
                        <a class="trait" href="Retries.html" title="Provides methods that can be used in withFixture implementations to retry tests in various scenarios."></a>
                        <a href="Retries.html" title="Provides methods that can be used in withFixture implementations to retry tests in various scenarios.">Retries</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Sequential$.html" title="Companion object to class Sequential that offers an apply factory method for creating a Sequential instance."></a>
                        <a class="class" href="Sequential.html" title="A Suite class mixing in SequentialNestedSuiteExecution that takes zero to many Suites, which will be returned from its nestedSuites method."></a>
                        <a href="Sequential.html" title="A Suite class mixing in SequentialNestedSuiteExecution that takes zero to many Suites, which will be returned from its nestedSuites method.">Sequential</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="SequentialNestedSuiteExecution.html" title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites."></a>
                        <a href="SequentialNestedSuiteExecution.html" title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites.">SequentialNestedSuiteExecution</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="SeveredStackTraces.html" title="Trait that causes StackDepth exceptions thrown by a running test (such as TestFailedExceptions) to have the exception's stack trace severed at the stack depth."></a>
                        <a href="SeveredStackTraces.html" title="Trait that causes StackDepth exceptions thrown by a running test (such as TestFailedExceptions) to have the exception's stack trace severed at the stack depth.">SeveredStackTraces</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Shell.html" title="Trait whose instances provide a run method and configuration fields that implement the ScalaTest shell: its DSL for the Scala interpreter."></a>
                        <a href="Shell.html" title="Trait whose instances provide a run method and configuration fields that implement the ScalaTest shell: its DSL for the Scala interpreter.">Shell</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="StatefulStatus.html" title="Status implementation that can change its state over time."></a>
                        <a href="StatefulStatus.html" title="Status implementation that can change its state over time.">StatefulStatus</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Status.html" title="The result status of running a test or a suite, which is used to support parallel and asynchronous execution of tests."></a>
                        <a href="Status.html" title="The result status of running a test or a suite, which is used to support parallel and asynchronous execution of tests.">Status</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Stepwise$.html" title="Companion object to class Stepwise that offers an apply factory method for creating a Stepwise instance."></a>
                        <a class="class" href="Stepwise.html" title="A Suite class that takes zero to many Suites, which will be returned from its nestedSuites method and executed in &amp;ldquo;stepwise&amp;rdquo; fashion by its runNestedSuites method."></a>
                        <a href="Stepwise.html" title="A Suite class that takes zero to many Suites, which will be returned from its nestedSuites method and executed in &amp;ldquo;stepwise&amp;rdquo; fashion by its runNestedSuites method.">Stepwise</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="StepwiseNestedSuiteExecution.html" title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites."></a>
                        <a href="StepwiseNestedSuiteExecution.html" title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites.">StepwiseNestedSuiteExecution</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Stopper$.html" title="Companion object to Stopper that holds a factory method that produces a new Stopper whose stopRequested method returns false until after its requestStop has been invoked."></a>
                        <a class="trait" href="Stopper.html" title="Trait whose instances can accept a stop request and indicate whether a stop has already been requested."></a>
                        <a href="Stopper.html" title="Trait whose instances can accept a stop request and indicate whether a stop has already been requested.">Stopper</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="StreamlinedXml$.html" title="Companion object that facilitates the importing of StreamlinedXml members as an alternative to mixing it the trait."></a>
                        <a class="trait" href="StreamlinedXml.html" title="Trait providing a streamlined method that returns a Uniformity[T] instance for any subtype of scala.xml.NodeSeq that will normalize the XML by removing empty text nodes and trimming non-empty text nodes."></a>
                        <a href="StreamlinedXml.html" title="Trait providing a streamlined method that returns a Uniformity[T] instance for any subtype of scala.xml.NodeSeq that will normalize the XML by removing empty text nodes and trimming non-empty text nodes.">StreamlinedXml</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="StreamlinedXmlEquality$.html" title="Companion object that facilitates the importing of StreamlinedXmlEquality members as an alternative to mixing it the trait."></a>
                        <a class="trait" href="StreamlinedXmlEquality.html" title="Trait providing an implicit Equality[T] for subtypes of scala.xml.NodeSeq that before testing for equality, will normalize left and right sides by removing empty XML text nodes and trimming non-empty text nodes."></a>
                        <a href="StreamlinedXmlEquality.html" title="Trait providing an implicit Equality[T] for subtypes of scala.xml.NodeSeq that before testing for equality, will normalize left and right sides by removing empty XML text nodes and trimming non-empty text nodes.">StreamlinedXmlEquality</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="StreamlinedXmlNormMethods$.html" title="Companion object that facilitates the importing of StreamlinedXmlNormMethods members as an alternative to mixing it the trait."></a>
                        <a class="trait" href="StreamlinedXmlNormMethods.html" title="Subtrait of NormMethods that provides an implicit Uniformity[T] for subtypes of scala.xml.NodeSeq that enables you to streamline XML by invoking .norm on it."></a>
                        <a href="StreamlinedXmlNormMethods.html" title="Subtrait of NormMethods that provides an implicit Uniformity[T] for subtypes of scala.xml.NodeSeq that enables you to streamline XML by invoking .norm on it.">StreamlinedXmlNormMethods</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="Succeeded$.html" title="Outcome for a test that succeeded."></a>
                        <a href="Succeeded$.html" title="Outcome for a test that succeeded.">Succeeded</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="SucceededStatus$.html" title="Singleton status that represents an already completed run with no tests failed and no suites aborted."></a>
                        <a href="SucceededStatus$.html" title="Singleton status that represents an already completed run with no tests failed and no suites aborted.">SucceededStatus</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Suite.html" title="A suite of tests."></a>
                        <a href="Suite.html" title="A suite of tests.">Suite</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="SuiteMixin.html" title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in Suite and can be overridden in stackable modification traits."></a>
                        <a href="SuiteMixin.html" title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in Suite and can be overridden in stackable modification traits.">SuiteMixin</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Suites$.html" title="Companion object to class Suites that offers an apply factory method for creating a Suites instance."></a>
                        <a class="class" href="Suites.html" title="A Suite class that takes zero to many Suites in its constructor, which will be returned from its nestedSuites method."></a>
                        <a href="Suites.html" title="A Suite class that takes zero to many Suites in its constructor, which will be returned from its nestedSuites method.">Suites</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Tag$.html" title="Companion object for Tag, which offers a factory method."></a>
                        <a class="class" href="Tag.html" title="Class whose subclasses can be used to tag tests in style traits in which tests are defined as functions."></a>
                        <a href="Tag.html" title="Class whose subclasses can be used to tag tests in style traits in which tests are defined as functions.">Tag</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TagAnnotation.html" title="Annotation used to annotate annotation interfaces that define tags for ScalaTest tests."></a>
                        <a href="TagAnnotation.html" title="Annotation used to annotate annotation interfaces that define tags for ScalaTest tests.">TagAnnotation</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TestData.html" title="A bundle of information about the current test."></a>
                        <a href="TestData.html" title="A bundle of information about the current test.">TestData</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TestRegistration.html" title="Trait declaring methods that can be used to register by-name test functions that have any result type."></a>
                        <a href="TestRegistration.html" title="Trait declaring methods that can be used to register by-name test functions that have any result type.">TestRegistration</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TestSuite.html" title="The base trait of ScalaTest's synchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns an Outcome."></a>
                        <a href="TestSuite.html" title="The base trait of ScalaTest's synchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns an Outcome.">TestSuite</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TestSuiteMixin.html" title=""></a>
                        <a href="TestSuiteMixin.html" title="">TestSuiteMixin</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Tracker$.html" title=""></a>
                        <a class="class" href="Tracker.html" title="Class that tracks the progress of a series of Ordinals produced by invoking next and nextNewOldPair on the current Ordinal."></a>
                        <a href="Tracker.html" title="Class that tracks the progress of a series of Ordinals produced by invoking next and nextNewOldPair on the current Ordinal.">Tracker</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="TryValues$.html" title="Companion object that facilitates the importing of TryValues members as an alternative to mixing it in."></a>
                        <a class="trait" href="TryValues.html" title="Trait that provides an implicit conversion that adds success and failure methods to scala.util.Try, enabling you to make assertions about the value of a Success or the exception of a Failure."></a>
                        <a href="TryValues.html" title="Trait that provides an implicit conversion that adds success and failure methods to scala.util.Try, enabling you to make assertions about the value of a Success or the exception of a Failure.">TryValues</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="WordSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="WordSpec.html" title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">WordSpec</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="WordSpecLike.html" title="Implementation trait for class WordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify."></a>
                        <a href="WordSpecLike.html" title="Implementation trait for class WordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify.">WordSpecLike</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="WrapWith.html" title="Annotation to associate a wrapper suite with a non-Suite class, so it can be run via ScalaTest."></a>
                        <a href="WrapWith.html" title="Annotation to associate a wrapper suite with a non-Suite class, so it can be run via ScalaTest.">WrapWith</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="run$.html" title="Singleton object providing an apply method for the ScalaTest shell and a main method for ScalaTest's simple runner."></a>
                        <a href="run$.html" title="Singleton object providing an apply method for the ScalaTest shell and a main method for ScalaTest's simple runner.">run</a>
                      </li><li name="org.scalatestplus" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scalatestplus"></a><a id="scalatestplus:scalatestplus"></a>
      <span class="permalink">
      <a href="../org/index.html#scalatestplus" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../scalatestplus/index.html"><span class="name">scalatestplus</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">

<!-- Top of doc.scalatest.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/3cbad67e7fa9539151489fd25cf64fdd-ads.js?product=ScalaTest"></script>

      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../index.html" class="extype" name="org">org</a></p>
        <h1>scalatest<span class="permalink">
      <a href="../../org/scalatest/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">scalatest</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.
</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/scalatest/scalatest/tree/release-3.0.8/scalatest//src/main/scala/org/scalatest/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="org.scalatest"><span>scalatest</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.scalatest.Alerter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AlerterextendsAnyRef"></a><a id="Alerter:Alerter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AlerterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing an apply method to which alert messages about a running suite of tests can be reported." href="Alerter.html"><span class="name">Alerter</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing an <code>apply</code> method to which alert messages about a running suite of tests can be reported.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an <code>apply</code> method to which alert messages about a running suite of tests can be reported.</p><p>An <code>Alerter</code> is essentially
used to wrap a <code>Reporter</code> and provide easy ways to send alert messages
to that <code>Reporter</code> via an <code>AlertProvided</code> event.
<code>Alerter</code> contains an <code>apply</code> method that takes a string and
an optional payload object of type <code>Any</code>.
The <code>Alerter</code> will forward the passed alert <code>message</code> string to the
<a href="Reporter.html"><code>Reporter</code></a> as the <code>message</code> parameter, and the optional
payload object as the <code>payload</code> parameter, of an <a href="AlertProvided.html"><code>AlertProvided</code></a> event.</p><p>For insight into the differences between <code>Alerter</code>, <code>Notifier</code>, and <code>Informer</code>, see the
main documentation for trait <a href="Alerting.html"><code>Alerting</code></a>.</p></div></div>
    </li><li name="org.scalatest.Alerting" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AlertingextendsAnyRef"></a><a id="Alerting:Alerting"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AlertingextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains the alert method, which can be used to send an alert to the reporter." href="Alerting.html"><span class="name">Alerting</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains the <code>alert</code> method, which can be used to send an alert to the reporter.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains the <code>alert</code> method, which can be used to send an alert to the reporter.</p><p>One difference between <code>alert</code> and the <code>info</code> method of <code>Informer</code> is that
<code>info</code> messages provided during a test are recorded and sent as part of test completion event, whereas
<code>alert</code> messages are sent right away as <code>AlertProvided</code> messages. For long-running tests,
<code>alert</code> allows you to send &quot;alert notifications&quot; to the reporter right away, so users can be made aware
of potential problems being experienced by long-running tests. By contrast, <code>info</code> messages will only be seen by the user after the
test has completed, and are more geared towards specification (such as Given/When/Then messages) than notification.</p><p>The difference between <code>alert</code> and the <code>update</code> method of <a href="Updating.html"><code>Updating</code></a> is
that <code>alert</code> is intended to be used
for warnings or notifications of potential problems, whereas <code>update</code> is just for status updates.
In string reporters for which ANSI color is enabled, <code>update</code> notifications are shown in green and <code>alert</code> notifications
in yellow.</p></div></div>
    </li><li name="org.scalatest.AppendedClues" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AppendedCluesextendsAnyRef"></a><a id="AppendedClues:AppendedClues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AppendedCluesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing an implicit conversion that allows clues to be placed after a block of code." href="AppendedClues.html"><span class="name">AppendedClues</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing an implicit conversion that allows clues to be placed after a block of code.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit conversion that allows clues to be placed after a block of code.</p><p>You can use the <code>withClue</code> construct provided by <a href="Assertions.html"><code>Assertions</code></a>, which is
extended by every style trait in ScalaTest, to add extra information to reports of failed or canceled tests.
The <code>withClue</code> from <code>Assertions</code> places the &quot;clue string&quot; at the front, both
in the code and in the resulting message:</p><p><pre class="stHighlighted">
withClue(<span class="stQuotedString">"This is a prepended clue;"</span>) {
  <span class="stLiteral">1</span> + <span class="stLiteral">1</span> should equal (<span class="stLiteral">3</span>)
}
</pre></p><p>The above expression will yield the failure message:</p><p><code>This is a prepended clue; 2 did not equal 3</code></p><p>If you mix in this trait, or import its members via its companion object, you can alternatively place
the clue string at the end, like this:</p><p><pre class="stHighlighted">
{ <span class="stLiteral">1</span> + <span class="stLiteral">1</span> should equal (<span class="stLiteral">3</span>) } withClue <span class="stQuotedString">"now the clue comes after"</span>
</pre></p><p>The above expression will yield the failure message:</p><p><code>2 did not equal 3 now the clue comes after</code></p><p>If no space is already present, either at the beginning of the clue string or at the end
of the current message, a space will be placed between the two, unless the clue string
starts with one of the punctuation characters: comma (<code>,</code>), period (<code>.</code>),
or semicolon (<code>;</code>). For example, the failure message in the above example
includes an extra space inserted between <em>3</em> and <em>now</em>.</p><p>By contrast this code, which has a clue string starting with comma:</p><p><pre class="stHighlighted">
{ <span class="stLiteral">1</span> + <span class="stLiteral">1</span> should equal (<span class="stLiteral">3</span>) } withClue <span class="stQuotedString">", now the clue comes after"</span>
</pre></p><p>Will yield a failure message with no extra inserted space:</p><p><code>2 did not equal 3, now the clue comes after</code></p><p>The <code>withClue</code> method will only append the clue string to the detail
message of exception types that mix in the <code>ModifiableMessage</code> trait.
See the documentation for <a href="exceptions/ModifiableMessage.html"><code>ModifiableMessage</code></a> for more
information.</p><p>Note: the reason this functionality is not provided by <code>Assertions</code> directly, like the
prepended <code>withClue</code> construct, is because appended clues require an implicit conversion.
ScalaTest only gives you one implicit conversion by default in any test class to minimize the
potential for conflicts with other implicit conversions you may be using. All other implicit conversions,
including the one provided by this trait, you must explicitly invite into your code through inheritance
or an import.</p></div></div>
    </li><li name="org.scalatest.Args" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ArgsextendsProductwithSerializable"></a><a id="Args:Args"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ArgsextendsProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Arguments bundle passed to four of ScalaTest's lifecycle methods: run, runNestedSuites, runTests, and runTest." href="Args.html"><span class="name">Args</span></a><span class="params">(<span name="reporter">reporter: <a href="Reporter.html" class="extype" name="org.scalatest.Reporter">Reporter</a></span>, <span name="stopper">stopper: <a href="Stopper.html" class="extype" name="org.scalatest.Stopper">Stopper</a> = <span class="symbol"><span class="name"><a href="Stopper$.html">Stopper.default</a></span></span></span>, <span name="filter">filter: <a href="Filter.html" class="extype" name="org.scalatest.Filter">Filter</a> = <span class="symbol"><span class="name"><a href="Filter$.html">Filter.default</a></span></span></span>, <span name="configMap">configMap: <a href="ConfigMap.html" class="extype" name="org.scalatest.ConfigMap">ConfigMap</a> = <span class="symbol"><span class="name"><a href="ConfigMap$.html">ConfigMap.empty</a></span></span></span>, <span name="distributor">distributor: <span class="extype" name="scala.Option">Option</span>[<a href="Distributor.html" class="extype" name="org.scalatest.Distributor">Distributor</a>] = <span class="symbol">None</span></span>, <span name="tracker">tracker: <a href="Tracker.html" class="extype" name="org.scalatest.Tracker">Tracker</a> = <span class="symbol"><span class="name"><a href="Tracker$.html">Tracker.default</a></span></span></span>, <span name="chosenStyles">chosenStyles: <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">Set.empty</span></span>, <span name="runTestInNewInstance">runTestInNewInstance: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="distributedTestSorter">distributedTestSorter: <span class="extype" name="scala.Option">Option</span>[<a href="DistributedTestSorter.html" class="extype" name="org.scalatest.DistributedTestSorter">DistributedTestSorter</a>] = <span class="symbol">None</span></span>, <span name="distributedSuiteSorter">distributedSuiteSorter: <span class="extype" name="scala.Option">Option</span>[<a href="DistributedSuiteSorter.html" class="extype" name="org.scalatest.DistributedSuiteSorter">DistributedSuiteSorter</a>] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Arguments bundle passed to four of ScalaTest's lifecycle methods: <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, and <code>runTest</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Arguments bundle passed to four of ScalaTest's lifecycle methods: <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, and <code>runTest</code>.</p><p>The signatures of these methods, defined in trait <a href="Suite.html"><code>Suite</code></a>, are:</p><p><pre>
def run(testName: Option[String], args: Args)
def runNestedSuites(args: Args)
def runTests(testName: Option[String], args: Args)
def runTest(testName: String, args: Args)
</pre></p><p>The purpose of bundling these arguments into an <code>Args</code> object instead of passing them in individually is to make the signature
of these four lifecycle methods easier to read, write, and remember, as well as to make the methods more pleasant to override in user code.</p></div><dl class="paramcmts block"><dt class="param">reporter</dt><dd class="cmt"><p>the <code>Reporter</code> to which results will be reported</p></dd><dt class="param">stopper</dt><dd class="cmt"><p>the <code>Stopper</code> that will be consulted to determine whether to stop execution early.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>a <code>Filter</code> with which to filter tests based on their tags</p></dd><dt class="param">configMap</dt><dd class="cmt"><p>a <code>ConfigMap</code> of key-value pairs that can be used by the executing <code>Suite</code> of tests.</p></dd><dt class="param">distributor</dt><dd class="cmt"><p>an optional <code>Distributor</code>, into which to put nested <code>Suite</code>s to be executed
             by another entity, such as concurrently by a pool of threads. If <code>None</code>, nested <code>Suite</code>s will be executed sequentially.</p></dd><dt class="param">tracker</dt><dd class="cmt"><p>a <code>Tracker</code> tracking <code>Ordinal</code>s being fired by the current thread.</p></dd><dt class="param">chosenStyles</dt><dd class="cmt"><p>a (possibly empty) <code>Set</code> of <code>String</code>s specifying the run's <a href="tools/Runner$.html#specifyingChosenStyles"><em>chosen styles</em></a></p></dd><dt class="param">runTestInNewInstance</dt><dd class="cmt"><p>a flag used to pass information between run methods
          in <a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a> and <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a>.</p></dd><dt class="param">distributedTestSorter</dt><dd class="cmt"><p>an optional <a href="DistributedTestSorter.html"><code>DistributedTestSorter</code></a> used by <code>ParallelTestExecution</code> to sort the events
                             for the parallel-executed tests of one suite back into sequential order on the fly, with a timeout in case a test takes too long to complete</p></dd><dt class="param">distributedSuiteSorter</dt><dd class="cmt"><p>an optional <a href="DistributedSuiteSorter.html"><code>DistributedSuiteSorter</code></a> used by <code>ParallelTestExecution</code> to ensure the events
                             for the parallel-executed suites are sorted back into sequential order, with a timeout in case a suite takes to long to complete, even when tests are executed in parallel</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NullArgumentException"><code>NullArgumentException</code></span> if any passed parameter is <code>null</code>.</p></span></dd></dl></div>
    </li><li name="org.scalatest.Assertion" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Assertion=org.scalatest.compatible.Assertion"></a><a id="Assertion:Assertion"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Assertion=org.scalatest.compatible.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Assertion</span><span class="result alias"> = <a href="compatible/Assertion.html" class="extype" name="org.scalatest.compatible.Assertion">scalatest.compatible.Assertion</a></span>
      </span>
      
      
    </li><li name="org.scalatest.Assertions" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AssertionsextendsTripleEquals"></a><a id="Assertions:Assertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AssertionsextendsTripleEquals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains ScalaTest's basic assertion methods." href="Assertions.html"><span class="name">Assertions</span></a><span class="result"> extends <span class="extype" name="org.scalactic.TripleEquals">TripleEquals</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains ScalaTest's basic assertion methods.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains ScalaTest's basic assertion methods.</p><p>You can use the assertions provided by this trait in any ScalaTest <code>Suite</code>,
because <a href="Suite.html"><code>Suite</code></a>
mixes in this trait. This trait is designed to be used independently of anything else in ScalaTest, though, so you
can mix it into anything. (You can alternatively import the methods defined in this trait. For details, see the documentation
for the <a href="Assertions$.html"><code>Assertions</code> companion object</a>.</p><p>In any Scala program, you can write assertions by invoking <code>assert</code> and passing in a <code>Boolean</code> expression,
such as:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> left = <span class="stLiteral">2</span>
<span class="stReserved">val</span> right = <span class="stLiteral">1</span>
assert(left == right)
</pre></p><p>If the passed expression is <code>true</code>, <code>assert</code> will return normally. If <code>false</code>,
Scala's <code>assert</code> will complete abruptly with an <code>AssertionError</code>. This behavior is provided by
the <code>assert</code> method defined in object <code>Predef</code>, whose members are implicitly imported into every
Scala source file. This <code>Assertions</code> trait defines another <code>assert</code> method that hides the
one in <code>Predef</code>. It behaves the same, except that if <code>false</code> is passed it throws
<a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a> instead of <code>AssertionError</code>.
Why? Because unlike <code>AssertionError</code>, <code>TestFailedException</code> carries information about exactly
which item in the stack trace represents
the line of test code that failed, which can help users more quickly find an offending line of code in a failing test.
In addition, ScalaTest's <code>assert</code> provides better error messages than Scala's <code>assert</code>.</p><p>If you pass the previous <code>Boolean</code> expression, <code>left == right</code> to <code>assert</code> in a ScalaTest test,
a failure will be reported that, because <code>assert</code> is implemented as a macro,
includes reporting the left and right values.
For example, given the same code as above but using ScalaTest assertions:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.Assertions._
<span class="stReserved">val</span> left = <span class="stLiteral">2</span>
<span class="stReserved">val</span> right = <span class="stLiteral">1</span>
assert(left == right)
</pre></p><p>The detail message in the thrown <code>TestFailedException</code> from this <code>assert</code>
will be: &quot;2 did not equal 1&quot;.</p><p>ScalaTest's <code>assert</code> macro works by recognizing patterns in the AST of the expression passed to <code>assert</code> and,
for a finite set of common expressions, giving an error message that an equivalent ScalaTest matcher
expression would give. Here are some examples, where <code>a</code> is 1, <code>b</code> is 2, <code>c</code> is 3, <code>d</code>
is 4, <code>xs</code> is <code>List(a, b, c)</code>, and <code>num</code> is 1.0:</p><p><pre class="stHighlighted">
assert(a == b || c &gt;= d)
<span class="stLineComment">// Error message: 1 did not equal 2, and 3 was not greater than or equal to 4</span>
<br/>assert(xs.exists(_ == <span class="stLiteral">4</span>))
<span class="stLineComment">// Error message: List(1, 2, 3) did not contain 4</span>
<br/>assert(<span class="stQuotedString">"hello"</span>.startsWith(<span class="stQuotedString">"h"</span>) &amp;&amp; <span class="stQuotedString">"goodbye"</span>.endsWith(<span class="stQuotedString">"y"</span>))
<span class="stLineComment">// Error message: "hello" started with "h", but "goodbye" did not end with "y"</span>
<br/>assert(num.isInstanceOf[<span class="stType">Int</span>])
<span class="stLineComment">// Error message: 1.0 was not instance of scala.Int</span>
<br/>assert(<span class="stType">Some</span>(<span class="stLiteral">2</span>).isEmpty)
<span class="stLineComment">// Error message: Some(2) was not empty</span>
</pre></p><p>For expressions that are not recognized, the macro currently prints out a string
representation of the (desugared) AST and adds <code>"was false"</code>. Here are some examples of
error messages for unrecognized expressions:</p><p><pre class="stHighlighted">
assert(None.isDefined)
<span class="stLineComment">// Error message: scala.None.isDefined was false</span>
<br/>assert(xs.exists(i =&gt; i &gt; <span class="stLiteral">10</span>))
<span class="stLineComment">// Error message: xs.exists(((i: Int) =&gt; i.&gt;(10))) was false</span>
</pre></p><p>You can augment the standard error message by providing a <code>String</code> as a second argument
to <code>assert</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> attempted = <span class="stLiteral">2</span>
assert(attempted == <span class="stLiteral">1</span>, <span class="stQuotedString">"Execution was attempted "</span> + left + <span class="stQuotedString">" times instead of 1 time"</span>)
</pre></p><p>Using this form of <code>assert</code>, the failure report will be more specific to your problem domain, thereby
helping you debug the problem. This <code>Assertions</code> trait also mixes in the
<a href="../scalactic/TripleEquals.html"><code>TripleEquals</code></a>, which gives you a <code>===</code> operator
that allows you to customize <a href="../scalactic/Equality.html"><code>Equality</code></a>, perform equality checks with numeric
<a href="../scalactic/Tolerance.html"><code>Tolerance</code></a>, and enforce type constraints at compile time with
sibling traits <a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a> and
<a href="ConversionCheckedTripleEquals.html"><code>ConversionCheckedTripleEquals</code></a>.</p><p><a name="expectedResults"></a></p><h4> Expected results </h4><p>Although the <code>assert</code> macro provides a natural, readable extension to Scala's <code>assert</code> mechanism that
provides good error messages, as the operands become lengthy, the code becomes less readable. In addition, the error messages
generated for <code>==</code> and <code>===</code> comparisons
don't distinguish between actual and expected values. The operands are just called <code>left</code> and <code>right</code>,
because if one were named <code>expected</code> and the other <code>actual</code>, it would be difficult for people to
remember which was which. To help with these limitations of assertions, <code>Suite</code> includes a method called <code>assertResult</code> that
can be used as an alternative to <code>assert</code>. To use <code>assertResult</code>, you place
the expected value in parentheses after <code>assertResult</code>, followed by curly braces containing code
that should result in the expected value. For example:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> a = <span class="stLiteral">5</span>
<span class="stReserved">val</span> b = <span class="stLiteral">2</span>
assertResult(<span class="stLiteral">2</span>) {
  a - b
}
</pre></p><p>In this case, the expected value is <code>2</code>, and the code being tested is <code>a - b</code>. This assertion will fail, and
the detail message in the <code>TestFailedException</code> will read, &quot;Expected 2, but got 3.&quot;</p><p><a name="forcingFailures"></a></p><h4> Forcing failures </h4><p>If you just need the test to fail, you can write:</p><p><pre class="stHighlighted">
fail()
</pre></p><p>Or, if you want the test to fail with a message, write:</p><p><pre class="stHighlighted">
fail(<span class="stQuotedString">"I've got a bad feeling about this"</span>)
</pre></p><p><a name="achievingSuccess"></a></p><h4> Achieving success </h4><p>In async style tests, you must end your test body with either <code>Future[Assertion]</code> or
<code>Assertion</code>. ScalaTest's assertions (including matcher expressions) have result type
<code>Assertion</code>, so ending with an assertion will satisfy the compiler.
If a test body or function body passed to <code>Future.map</code> does
<em>not</em> end with type <code>Assertion</code>, however, you can fix the type error by placing
<code>succeed</code> at the end of the
test or function body:</p><p><pre class="stHighlighted">
succeed <span class="stLineComment">// Has type Assertion</span>
</pre></p><p><a name="interceptedExceptions"></a>
<a name="expectedExceptions"></a></p><h4> Expected exceptions </h4><p>Sometimes you need to test whether a method throws an expected exception under certain circumstances, such
as when invalid arguments are passed to the method. You can do this in the JUnit 3 style, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> s = <span class="stQuotedString">"hi"</span>
<span class="stReserved">try</span> {
  s.charAt(-<span class="stLiteral">1</span>)
  fail()
}
<span class="stReserved">catch</span> {
  <span class="stReserved">case</span> _: <span class="stType">IndexOutOfBoundsException</span> =&gt; <span class="stLineComment">// Expected, so continue</span>
}
</pre></p><p>If <code>charAt</code> throws <code>IndexOutOfBoundsException</code> as expected, control will transfer
to the catch case, which does nothing. If, however, <code>charAt</code> fails to throw an exception,
the next statement, <code>fail()</code>, will be run. The <code>fail</code> method always completes abruptly with
a <code>TestFailedException</code>, thereby signaling a failed test.</p><p>To make this common use case easier to express and read, ScalaTest provides two methods:
<code>assertThrows</code> and <code>intercept</code>.
Here's how you use <code>assertThrows</code>:</p><p><a name="assertThrowsMethod"></a>
<pre class="stHighlighted">
<span class="stReserved">val</span> s = <span class="stQuotedString">"hi"</span>
assertThrows[<span class="stType">IndexOutOfBoundsException</span>] { <span class="stLineComment">// Result type: Assertion</span>
  s.charAt(-<span class="stLiteral">1</span>)
}
</pre></p><p>This code behaves much like the previous example. If <code>charAt</code> throws an instance of <code>IndexOutOfBoundsException</code>,
<code>assertThrows</code> will return <code>Succeeded</code>. But if <code>charAt</code> completes normally, or throws a different
exception, <code>assertThrows</code> will complete abruptly with a <code>TestFailedException</code>.</p><p>The <code>intercept</code> method behaves the same as <code>assertThrows</code>, except that instead of returning <code>Succeeded</code>,
<code>intercept</code> returns the caught exception so that you can inspect it further if you wish. For example, you may need
to ensure that data contained inside the exception have expected values. Here's an example:</p><p><a name="interceptMethod"></a>
<pre class="stHighlighted">
<span class="stReserved">val</span> s = <span class="stQuotedString">"hi"</span>
<span class="stReserved">val</span> caught =
  intercept[<span class="stType">IndexOutOfBoundsException</span>] { <span class="stLineComment">// Result type: IndexOutOfBoundsException</span>
    s.charAt(-<span class="stLiteral">1</span>)
  }
assert(caught.getMessage.indexOf(<span class="stQuotedString">"-1"</span>) != -<span class="stLiteral">1</span>)
</pre></p><p><a name="checkingThatCodeDoesNotCompile"></a></p><h4> Checking that a snippet of code does or does not compile </h4><p>Often when creating libraries you may wish to ensure that certain arrangements of code that
represent potential &ldquo;user errors&rdquo; do not compile, so that your library is more error resistant.
ScalaTest's <code>Assertions</code> trait includes the following syntax for that purpose:</p><p><pre class="stHighlighted">
assertDoesNotCompile(<span class="stQuotedString">"val a: String = 1"</span>)
</pre></p><p>If you want to ensure that a snippet of code does not compile because of a type error (as opposed
to a syntax error), use:</p><p><pre class="stHighlighted">
assertTypeError(<span class="stQuotedString">"val a: String = 1"</span>)
</pre></p><p>Note that the <code>assertTypeError</code> call will only succeed if the given snippet of code does not
compile because of a type error. A syntax error will still result on a thrown <code>TestFailedException</code>.</p><p>If you want to state that a snippet of code <em>does</em> compile, you can make that
more obvious with:</p><p><pre class="stHighlighted">
assertCompiles(<span class="stQuotedString">"val a: Int = 1"</span>)
</pre></p><p>Although the previous three constructs are implemented with macros that determine at compile time whether
the snippet of code represented by the string does or does not compile, errors
are reported as test failures at runtime.</p><p><a name="assumptions"></a></p><h4> Assumptions </h4><p>Trait <code>Assertions</code> also provides methods that allow you to <em>cancel</em> a test.
You would cancel a test if a resource required by the test was unavailable. For example, if a test
requires an external database to be online, and it isn't, the test could be canceled to indicate
it was unable to run because of the missing database. Such a test <em>assumes</em> a database is
available, and you can use the <code>assume</code> method to indicate this at the beginning of
the test, like this:</p><p><pre class="stHighlighted">
assume(database.isAvailable)
</pre></p><p>For each overloaded <code>assert</code> method, trait <code>Assertions</code> provides an
overloaded <code>assume</code> method with an identical signature and behavior, except the
<code>assume</code> methods throw <a href="exceptions/TestCanceledException.html"><code>TestCanceledException</code></a> whereas the
<code>assert</code> methods throw <code>TestFailedException</code>. As with <code>assert</code>,
<code>assume</code> hides a Scala method in <code>Predef</code> that performs a similar
function, but throws <code>AssertionError</code>. And just as you can with <code>assert</code>,
you will get an error message extracted by a macro from the AST passed to <code>assume</code>, and can
optionally provide a clue string to augment this error message. Here are some examples:</p><p><pre class="stHighlighted">
assume(database.isAvailable, <span class="stQuotedString">"The database was down again"</span>)
assume(database.getAllUsers.count === <span class="stLiteral">9</span>)
</pre></p><p><a name="forcingCancelations"></a></p><h4> Forcing cancelations </h4><p>For each overloaded <code>fail</code> method, there's a corresponding <code>cancel</code> method
with an identical signature and behavior, except the <code>cancel</code> methods throw
<code>TestCanceledException</code> whereas the <code>fail</code> methods throw
<code>TestFailedException</code>. Thus if you just need to cancel a test, you can write:</p><p><pre class="stHighlighted">
cancel()
</pre></p><p>If you want to cancel the test with a message, just place the message in the parentheses:</p><p><pre class="stHighlighted">
cancel(<span class="stQuotedString">"Can't run the test because no internet connection was found"</span>)
</pre></p><p><a name="gettingAClue"></a></p><h4> Getting a clue </h4><p>If you want more information that is provided by default by the methods if this trait,
you can supply a &quot;clue&quot; string in one of several ways.
The extra information (or &quot;clues&quot;) you provide will
be included in the detail message of the thrown exception. Both
<code>assert</code> and <code>assertResult</code> provide a way for a clue to be
included directly, <code>intercept</code> does not.
Here's an example of clues provided directly in <code>assert</code>:</p><p><pre class="stHighlighted">
assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>, <span class="stQuotedString">"this is a clue"</span>)
</pre></p><p>and in <code>assertResult</code>:</p><p><pre class="stHighlighted">
assertResult(<span class="stLiteral">3</span>, <span class="stQuotedString">"this is a clue"</span>) { <span class="stLiteral">1</span> + <span class="stLiteral">1</span> }
</pre></p><p>The exceptions thrown by the previous two statements will include the clue
string, <code>"this is a clue"</code>, in the exception's detail message.
To get the same clue in the detail message of an exception thrown
by a failed <code>intercept</code> call requires using <code>withClue</code>:</p><p><pre class="stHighlighted">
withClue(<span class="stQuotedString">"this is a clue"</span>) {
  intercept[<span class="stType">IndexOutOfBoundsException</span>] {
    <span class="stQuotedString">"hi"</span>.charAt(-<span class="stLiteral">1</span>)
  }
}
</pre></p><p>The <code>withClue</code> method will only prepend the clue string to the detail
message of exception types that mix in the <code>ModifiableMessage</code> trait.
See the documentation for <a href="ModifiableMessage.html"><code>ModifiableMessage</code></a> for more information.
If you wish to place a clue string after a block of code, see the documentation for
<a href="AppendedClues.html"><code>AppendedClues</code></a>.</p><p><em>Note: ScalaTest's <code>assertTypeError</code> construct is in part inspired by the <code>illTyped</code> macro
of <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a>.</em></p></div></div>
    </li><li name="org.scalatest.AsyncFeatureSpec" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFeatureSpecextendsAsyncFeatureSpecLike"></a><a id="AsyncFeatureSpec:AsyncFeatureSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFeatureSpecextendsAsyncFeatureSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FeatureSpec tests." href="AsyncFeatureSpec.html"><span class="name">AsyncFeatureSpec</span></a><span class="result"> extends <a href="AsyncFeatureSpecLike.html" class="extype" name="org.scalatest.AsyncFeatureSpecLike">AsyncFeatureSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FeatureSpec</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FeatureSpec</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFeatureSpec</code> is intended to enable users of <a href="FeatureSpec.html"><code>FeatureSpec</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FeatureSpec</code> tests.
<em>Note: <code>AsyncFeatureSpec</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FeatureSpec</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Although not required, <code>FeatureSpec</code> is often used together with <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> to express acceptance requirements
in more detail.
Here's an example <code>AsyncFeatureSpec</code>:</p><p><a name="initialExample"></a>
<pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">IsOn</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">PressPowerButton</span>
<br/><span class="stReserved">class</span> <span class="stType">TVSetActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
  <span class="stReserved">def</span> !(msg: PressPowerButton.type): <span class="stType">Unit</span> =
    synchronized {
      on = !on
    }
  <span class="stReserved">def</span> ?(msg: IsOn.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[Boolean]</span> =
    <span class="stType">Future</span> {
      synchronized { on }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetActorSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
<br/>  info(<span class="stQuotedString">"As a TV set owner"</span>)
  info(<span class="stQuotedString">"I want to be able to turn the TV on and off"</span>)
  info(<span class="stQuotedString">"So I can watch TV when I want"</span>)
  info(<span class="stQuotedString">"And save energy when I'm not watching TV"</span>)
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
    scenario(<span class="stQuotedString">"User presses power button when TV is off"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a TV set that is switched off"</span>)
      <span class="stReserved">val</span> tvSetActor = <span class="stReserved">new</span> <span class="stType">TVSetActor</span>
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      tvSetActor ! <span class="stType">PressPowerButton</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch on"</span>)
      <span class="stReserved">val</span> futureBoolean = tvSetActor ? <span class="stType">IsOn</span>
      futureBoolean map { isOn =&gt; assert(isOn) }
    }
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a TV set that is switched on"</span>)
      <span class="stReserved">val</span> tvSetActor = <span class="stReserved">new</span> <span class="stType">TVSetActor</span>
      tvSetActor ! <span class="stType">PressPowerButton</span>
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      tvSetActor ! <span class="stType">PressPowerButton</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch off"</span>)
      <span class="stReserved">val</span> futureBoolean = tvSetActor ? <span class="stType">IsOn</span>
      futureBoolean map { isOn =&gt; assert(!isOn) }
    }
  }
}
</pre></p><p>Note: for more information on the calls to <code>Given</code>, <code>When</code>, and <code>Then</code>, see the documentation
for trait <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> and the <a href="#informers"><code>Informers</code> section</a> below.</p><p>An <code>AsyncFeatureSpec</code> contains <em>feature clauses</em> and <em>scenarios</em>. You define a feature clause
with <code>feature</code>, and a scenario with <code>scenario</code>. Both
<code>feature</code> and <code>scenario</code> are methods, defined in
<code>AsyncFeatureSpec</code>, which will be invoked
by the primary constructor of <code>TVSetActorSpec</code>.
A feature clause describes a feature of the <em>subject</em> (class or other entity) you are specifying
and testing. In the previous example,
the subject under specification and test is a TV set. The feature being specified and tested is
the behavior of a TV set when its power button is pressed. With each scenario you provide a
string (the <em>spec text</em>) that specifies the behavior of the subject for
one scenario in which the feature may be used, and a block of code that tests that behavior.
You place the spec text between the parentheses, followed by the test code between curly
braces.  The test code will be wrapped up as a function passed as a by-name parameter to
<code>scenario</code>, which will register the test for later execution.
The result type of the by-name in an <code>AsyncFeatureSpec</code> must
be <code>Future[Assertion]</code>.</p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
When an <code>AsyncFeatureSpec</code> is constructed, any test that results in <code>Assertion</code> will
be implicitly converted to <code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code> only, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker.</p><p>An <code>AsyncFeatureSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Scenarios can only be registered with the <code>scenario</code> method while the <code>AsyncFeatureSpec</code> is
in its registration phase. Any attempt to register a scenario after the <code>AsyncFeatureSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncFeatureSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The
recommended style
of using <code>AsyncFeatureSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p>Each scenario represents one test. The name of the test is the spec text passed to the <code>scenario</code> method.
The feature name does not appear as part of the test name. In a <code>AsyncFeatureSpec</code>, therefore, you must take care
to ensure that each test has a unique name (in other words, that each <code>scenario</code> has unique spec text).</p><p>When you run a <code>AsyncFeatureSpec</code>, it will send <a href="events/Formatter.html"><code>Formatter</code></a>s in the events it sends to the
<a href="Reporter.html"><code>Reporter</code></a>. ScalaTest's built-in reporters will report these events in such a way
that the output is easy to read as an informal specification of the <em>subject</em> being tested.
For example, were you to run <code>TVSetSpec</code> from within the Scala interpreter:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetActorSpec)
</pre></p><p>You would see:</p><p><pre class="stREPL">
<span class="stGreen">TVSetActorSpec:
As a TV set owner
I want to be able to turn the TV on and off
So I can watch TV when I want
And save energy when I'm not watching TV
Feature: TV power button
  Scenario: User presses power button when TV is off
    Given a TV set that is switched off
    When the power button is pressed
    Then the TV should switch on
  Scenario: User presses power button when TV is on
    Given a TV set that is switched on
    When the power button is pressed
    Then the TV should switch off</span>
</pre></p><p>Or, to run just the &ldquo;<code>Feature: TV power button Scenario: User presses power button when TV is on</code>&rdquo; method, you could pass that test's name, or any unique substring of the
name, such as <code>"TV is on"</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetActorSpec, "TV is on")
<span class="stGreen">TVSetActorSpec:
As a TV set owner
I want to be able to turn the TV on and off
So I can watch TV when I want
And save energy when I'm not watching TV
Feature: TV power button
  Scenario: User presses power button when TV is on
    Given a TV set that is switched on
    When the power button is pressed
    Then the TV should switch off</span>
</pre></p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncFeatureSpec</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncFeatureSpec</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="FeatureSpec.html"><code>FeatureSpec</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncFeatureSpec</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncFeatureSpec</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="FeatureSpec.html"><code>FeatureSpec</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncFeatureSpec</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncFeatureSpec</code> provides registration
methods that start with <code>ignore</code> instead of <code>scenario</code>. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  feature(<span class="stQuotedString">"The add methods"</span>) {
<br/>    ignore(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
<br/>    scenario(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>If you run class <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">Feature: The add methods</span>
<span class="stYellow">- Scenario: addSoon will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">- Scenario: addNow will immediately compute a sum of passed Ints</span>

</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  feature(<span class="stQuotedString">"The add methods"</span>) {
<br/>    scenario(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
<br/>    scenario(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">Feature: The add methods</span>
<span class="stYellow">- Scenario: addSoon will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stYellow">- Scenario: addNow will immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>it</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncFeatureSpec</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <a href="Reporter.html"><code>Reporter</code></a> as the suite runs.
Most often the default reporting done by <code>AsyncFeatureSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a scenario to the reporter. For example,
the <code>GivenWhenThen</code> trait provides methods that use the implicit <code>info</code> provided by <code>AsyncFeatureSpec</code>
to pass such information to the reporter. You can see this in action in the <a href="#initialExample">initial example</a> of this trait's documentation.</p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncFeatureSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FlatSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
     <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  feature(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
    scenario(<span class="stQuotedString">"When an element is added to an empty mutable Set"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
      succeed
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/featureSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  feature(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
    scenario(<span class="stQuotedString">"When an element is added to an empty mutable Set"</span>) {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
Feature: An element can be added to an empty mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
  <span class="stGreen">Scenario: When an element is added to an empty mutable Set
    info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  feature(<span class="stQuotedString">"The add methods"</span>) {
<br/>    scenario(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) (pending)
<br/>    scenario(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">Feature: The add methods</span>
<span class="stYellow">- Scenario: addSoon will eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">- Scenario: addNow will immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFeatureSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFeatureSpec</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFeatureSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFeatureSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFeatureSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  feature(<span class="stQuotedString">"The add methods"</span>) {
<br/>    scenario(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>,
         <span class="stType">Slow</span>) {
<br/>      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
<br/>    scenario(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>,
        <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
<br/>      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFeatureSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is designed to "</span> }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"encourage clear code!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"be easy to reason about!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      }
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFeatureSpec</code>.</p><p>Trait <code>AsyncFeatureSpec</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  feature(<span class="stQuotedString">"addSoon"</span>) {
    scenario(<span class="stQuotedString">"succeed case"</span>) {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">2</span>) }
    }
<br/>    scenario(<span class="stQuotedString">"fail case"</span>) {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSpec</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
Feature: addSoon
- Scenario: succeed case</span>
<span class="stRed">- Scenario: fail case *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// perform setup</span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    <span class="stLineComment">// This test needs the actor fixture</span>
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      withActor { actor =&gt;
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        futureString map { s =&gt;
          assert(s === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
        }
      }
    }
    <span class="stLineComment">// This test needs the database fixture</span>
    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      withDatabase { futureDb =&gt;
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"be easy to reason about!"</span>)
          assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
        }
      }
    }
    <span class="stLineComment">// This test needs both the actor and the database</span>
    scenario(<span class="stQuotedString">"User needs to write tests"</span>) {
      withDatabase { futureDb =&gt;
        withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          actor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to remember how to write!"</span>)
          <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
          <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
            futureDb zip futureString
          futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
            db.append(<span class="stQuotedString">"be easy to learn!"</span>)
            assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to learn!"</span>)
            assert(s === <span class="stQuotedString">"ScalaTest is designed to be easy to remember how to write!"</span>)
          }
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFeatureSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to reason about!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      }
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFeatureSpec.html">documentation for <code>fixture.AsyncFeatureSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to reason about!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      }
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to reason about!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
<br/>    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"encourage clear code!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"be easy to reason about!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFeatureSpec</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFeatureSpec</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFeatureSpec</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfeaturespec.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt;= <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt;= size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFeatureSpec</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncFeatureSpec</code> that uses them. If they are shared
between different <code>AsyncFeatureSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFeatureSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFeatureSpec
<br/><span class="stReserved">trait</span> <span class="stType">AsyncFeatureSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncFeatureSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: =&gt; <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    scenario(<span class="stQuotedString">"Size is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    scenario(<span class="stQuotedString">"Peek is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek &lt;- stackActor ? <span class="stType">Size</span>
          afterPeek &lt;- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =&gt;
        assert(afterPeek.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size == beforePeek.size)
      }
    }
<br/>    scenario(<span class="stQuotedString">"Pop is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop &lt;- stackActor ? <span class="stType">Size</span>
          afterPop &lt;- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =&gt;
        assert(afterPop.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size == beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: =&gt; <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    scenario(<span class="stQuotedString">"Size is fired at non-full stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isFull)
      }
    }
<br/>    scenario(<span class="stQuotedString">"Push is fired at non-full stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush &lt;- stackActor ? <span class="stType">Size</span>
          afterPush &lt;- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =&gt;
        assert(afterPush.size == beforePush.size + <span class="stLiteral">1</span>)
        assert(afterPush.top == <span class="stType">Some</span>(<span class="stLiteral">7</span>))
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncFeatureSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName))
scenariosFor(nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName))
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFeatureSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncFeatureSpecStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  feature(<span class="stQuotedString">"A Stack is pushed and popped"</span>) {
<br/>    scenario(<span class="stQuotedString">"Size is fired at empty stack actor"</span>) {
      <span class="stReserved">val</span> stackActor = emptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(stackInfo.isEmpty)
      }
    }
<br/>    scenario(<span class="stQuotedString">"Peek is fired at empty stack actor"</span>) {
      recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
        emptyStackActor ? <span class="stType">Peek</span>
      }
    }
<br/>    scenario(<span class="stQuotedString">"Pop is fired at empty stack actor"</span>) {
      recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
        emptyStackActor ? <span class="stType">Pop</span>
      }
    }
<br/>    scenariosFor(nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName))
    scenariosFor(nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName))
<br/>    scenariosFor(nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName))
    scenariosFor(nonFullStackActor(almostFullStackActor, almostFullStackActorName))
<br/>    scenario(<span class="stQuotedString">"full is invoked on a full stack"</span>) {
      <span class="stReserved">val</span> stackActor = fullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(stackInfo.isFull)
      }
    }
<br/>    scenariosFor(nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName))
<br/>    scenario(<span class="stQuotedString">"push is invoked on a full stack"</span>) {
      <span class="stReserved">val</span> stackActor = fullStackActor
      assertThrows[<span class="stType">IllegalStateException</span>] {
        stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
Feature: A Stack actor
- Scenario: Size is fired at empty stack actor
- Scenario: Peek is fired at empty stack actor
- Scenario: Pop is fired at empty stack actor
- Scenario: Size is fired at non-empty stack actor: almost empty stack actor
- Scenario: Peek is fired at non-empty stack actor: almost empty stack actor
- Scenario: Pop is fired at non-empty stack actor: almost empty stack actor
- Scenario: Size is fired at non-full stack actor: almost empty stack actor
- Scenario: Push is fired at non-full stack actor: almost empty stack actor
- Scenario: Size is fired at non-empty stack actor: almost full stack actor
- Scenario: Peek is fired at non-empty stack actor: almost full stack actor
- Scenario: Pop is fired at non-empty stack actor: almost full stack actor
- Scenario: Size is fired at non-full stack actor: almost full stack actor
- Scenario: Push is fired at non-full stack actor: almost full stack actor
- Scenario: Size is fired at full stack actor
- Scenario: Size is fired at non-empty stack actor: full stack actor
- Scenario: Peek is fired at non-empty stack actor: full stack actor
- Scenario: Pop is fired at non-empty stack actor: full stack actor
- Scenario: Push is fired at full stack actor
</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Although in an <code>AsyncFeatureSpec</code>, the <code>feature</code> clause is a nesting construct analogous to
<code>AsyncFunSpec</code>'s <code>describe</code> clause, you many sometimes need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in an
<code>AsyncFeatureSpec</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFeatureSpecStackBehaviors</code> example.</p><p>Given this <code>AsyncFeatureSpecStackBehaviors</code> trait, calling it with the <code>almostEmptyStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName))
</pre></p><p>yields test names:</p><ul><li><code>Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>almostFullStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStack(almostFullStackActor, lastValuePushed, almostFullStackActorName))
</pre></p><p>yields different test names:</p><ul><li><code>Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncFeatureSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFeatureSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncFeatureSpecLike:AsyncFeatureSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFeatureSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncFeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature." href="AsyncFeatureSpecLike.html"><span class="name">AsyncFeatureSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncFeatureSpec</code>, which represents
a suite of tests in which each test represents one <em>scenario</em> of a
<em>feature</em>.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncFeatureSpec</code>, which represents
a suite of tests in which each test represents one <em>scenario</em> of a
<em>feature</em>.</p><p><a href="AsyncFeatureSpec.html"><code>AsyncFeatureSpec</code></a> is a class, not a
trait, to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>AsyncFeatureSpec</code> into some other class, you can use this
trait instead, because class <code>AsyncFeatureSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFeatureSpec.html">detailed
overview of <code>AsyncFeatureSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.AsyncFlatSpec" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFlatSpecextendsAsyncFlatSpecLike"></a><a id="AsyncFlatSpec:AsyncFlatSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFlatSpecextendsAsyncFlatSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FlatSpec tests." href="AsyncFlatSpec.html"><span class="name">AsyncFlatSpec</span></a><span class="result"> extends <a href="AsyncFlatSpecLike.html" class="extype" name="org.scalatest.AsyncFlatSpecLike">AsyncFlatSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FlatSpec</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FlatSpec</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFlatSpec</code> is intended to enable users of <a href="FlatSpec.html"><code>FlatSpec</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FlatSpec</code> tests.
<em>Note: <code>AsyncFlatSpec</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FlatSpec</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Trait <code>AsyncFlatSpec</code> is so named because
your specification text and tests line up flat against the left-side indentation level, with no nesting needed.
Here's an example <code>AsyncFlatSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  behavior of <span class="stQuotedString">"addSoon"</span>
<br/>  it should <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>The initial test in this example demonstrates the use of an explicit <code>behavior of</code> clause, which establishes
<code>addSoon</code> as the subject.  The second test demonstrates the alternate syntax of replacing the first <code>it</code>
with the subject string, in this case, <code>"addNow"</code>.
As with traditional <code>FlatSpec</code>s, you can use <code>must</code> or <code>can</code> as well as <code>should</code>.
For example, instead of <code>it should "eventually</code>..., you could write
<code>it must "eventually</code>... or <code>it can "eventually</code>....
You can also write <code>they</code> instead of <code>it</code>. See the documentation for <a href="FlatSpec.html"><code>FlatSpec</code></a> for
more detail.</p><p>Running the above <code>AddSpec</code> in the Scala interpreter would yield:</p><p><pre class="stREPL">
<span class="stGreen">addSoon
- should eventually compute a sum of passed Ints
- should immediately compute a sum of passed Ints</span>
</pre></p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
For clarity, here's the relevant code in a REPL session:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext

scala&gt; implicit val executionContext = ExecutionContext.Implicits.global
executionContext: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@26141c5b

scala&gt; def addSoon(addends: Int*): Future[Int] = Future { addends.sum }
addSoon: (addends: Int*)scala.concurrent.Future[Int]

scala&gt; val futureSum: Future[Int] = addSoon(1, 2)
futureSum: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@721f47b2

scala&gt; futureSum map { sum =&gt; assert(sum == 3) }
res0: scala.concurrent.Future[org.scalatest.Assertion] = scala.concurrent.impl.Promise$DefaultPromise@3955cfcb
</pre></p><p>The second test has result type <code>Assertion</code>:</p><p><pre class="stREPL">
scala&gt; def addNow(addends: Int*): Int = addends.sum
addNow: (addends: Int*)Int

scala&gt; val sum: Int = addNow(1, 2)
sum: Int = 3

scala&gt; assert(sum == 3)
res1: org.scalatest.Assertion = Succeeded
</pre></p><p>When <code>AddSpec</code> is constructed, the second test will be implicitly converted to
<code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code>, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
  <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
  assert(sum == <span class="stLiteral">3</span>)
  println(<span class="stQuotedString">"hi"</span>) <span class="stLineComment">// println has result type Unit</span>
  succeed       <span class="stLineComment">// succeed has result type Assertion</span>
}
</pre></p><p>An <code>AsyncFlatSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>it</code> method while the <code>AsyncFlatSpec</code> is
in its registration phase. Any attempt to register a test after the <code>AsyncFlatSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncFlatSpec</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>AsyncFlatSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncFlatSpec</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncFlatSpec</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="FlatSpec.html"><code>FlatSpec</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncFlatSpec</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncFlatSpec</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="FlatSpec.html"><code>FlatSpec</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncFlatSpec</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncFlatSpec</code> provides two ways
to <em>ignore</em> a test, both demonstrated in the following example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  behavior of <span class="stQuotedString">"addSoon"</span>
<br/>  ignore should <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> ignore {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>In the first test, <code>ignore</code> is used instead of <code>it</code>.
In the second test, which uses the shorthand notation, no <code>it</code> exists to change into <code>ignore</code>.
To ignore such tests, you must instead change <code>in</code> to <code>ignore</code>, as shown in the above example.
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will report both tests as ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stYellow">- should immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stYellow">- should immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>it</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncFlatSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>AsyncFlatSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>AsyncFlatSpec</code>
to pass such information to the reporter.  Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
    succeed
  }
}
</pre></p><p>If you run this <code>AsyncFlatSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncFlatSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>AsyncFlatSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    succeed
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/flatSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
<br/>    info(<span class="stQuotedString">"info is recorded"</span>)
    markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
    note(<span class="stQuotedString">"notes are sent immediately"</span>)
    alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
    set += <span class="stQuotedString">"clarity"</span>
    assert(set.size === <span class="stLiteral">1</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in (pending)
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- should immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFlatSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFlatSpec</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFlatSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFlatSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFlatSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>) in {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFlatSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is "</span> }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    <span class="stReserved">val</span> future = fixture
    <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"easy!"</span> }
    result map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    <span class="stReserved">val</span> future = fixture
    <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"fun!"</span> }
    result map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFlatSpec</code>.</p><p>Trait <code>AsyncFlatSpec</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"This test"</span> should <span class="stQuotedString">"succeed"</span> in {
    addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">2</span>) }
  }
<br/>  it should <span class="stQuotedString">"fail"</span> in {
    addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
}
</pre></p><p>Running this version of <code>ExampleSpec</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stLineComment">// This test needs the actor fixture</span>
  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be productive"</span> in {
    withActor { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"productive!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is productive!"</span>)
      }
    }
  }
<br/>  <span class="stLineComment">// This test needs the database fixture</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be readable"</span> in {
    withDatabase { futureDb =&gt;
      futureDb map { db =&gt;
        db.append(<span class="stQuotedString">"readable!"</span>)
        assert(db.toString == <span class="stQuotedString">"ScalaTest is readable!"</span>)
      }
    }
  }
<br/>  <span class="stLineComment">// This test needs both the actor and the database</span>
  it should <span class="stQuotedString">"be clear and concise"</span> in {
    withDatabase { futureDb =&gt;
      withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"concise!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
          futureDb zip futureString
        futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
          db.append(<span class="stQuotedString">"clear!"</span>)
          assert(db.toString == <span class="stQuotedString">"ScalaTest is clear!"</span>)
          assert(s == <span class="stQuotedString">"ScalaTest is concise!"</span>)
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFlatSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFlatSpec.html">documentation for <code>fixture.AsyncFlatSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
      succeed
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
      succeed
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
      succeed
    }
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
      succeed
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFlatSpec</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFlatSpec</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFlatSpec</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncflatspec.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt; <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt; size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFlatSpec</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncFlatSpec</code> that uses them. If they are shared
between different <code>AsyncFlatSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFlatSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFlatSpec
<br/><span class="stReserved">trait</span> <span class="stType">AsyncFlatSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncFlatSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: =&gt; <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    it should (<span class="stQuotedString">"return non-empty StackInfo when Size is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    it should (<span class="stQuotedString">"return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek &lt;- stackActor ? <span class="stType">Size</span>
          afterPeek &lt;- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =&gt;
        assert(afterPeek.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size == beforePeek.size)
      }
    }
<br/>    it should (<span class="stQuotedString">"return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop &lt;- stackActor ? <span class="stType">Size</span>
          afterPop &lt;- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =&gt;
        assert(afterPop.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size == beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: =&gt; <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    it should (<span class="stQuotedString">"return non-full StackInfo when Size is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isFull)
      }
    }
<br/>    it should (<span class="stQuotedString">"return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush &lt;- stackActor ? <span class="stType">Size</span>
          afterPush &lt;- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =&gt;
        assert(afterPush.top == <span class="stType">Some</span>(<span class="stLiteral">7</span>))
        assert(afterPush.size == beforePush.size + <span class="stLiteral">1</span>)
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncFlatSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
it should behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFlatSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncFlatSpecStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i <- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stQuotedString">"A Stack actor (when empty)"</span> should <span class="stQuotedString">"return empty StackInfo when Size is fired at it"</span> in {
    <span class="stReserved">val</span> stackActor = emptyStackActor
    <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
    futureStackInfo map { stackInfo =>
      assert(stackInfo.isEmpty)
    }
  }
<br/>  it should <span class="stQuotedString">"complain when Peek is fired at it"</span> in {
    recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
      emptyStackActor ? <span class="stType">Peek</span>
    }
  }
<br/>  it should <span class="stQuotedString">"complain when Pop is fired at it"</span> in {
    recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
      emptyStackActor ? <span class="stType">Pop</span>
    }
  }
<br/>  <span class="stQuotedString">"A Stack actor (when non-empty)"</span> should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
<br/>  it should behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
<br/>  it should behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
<br/>  it should behave like nonFullStackActor(almostFullStackActor, almostFullStackActorName)
<br/>  <span class="stQuotedString">"A Stack actor (when full)"</span> should <span class="stQuotedString">"return full StackInfo when Size is fired at it"</span> in {
    <span class="stReserved">val</span> stackActor = fullStackActor
    <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
    futureStackInfo map { stackInfo =>
      assert(stackInfo.isFull)
    }
  }
<br/>  it should behave like nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName)
<br/>  it should <span class="stQuotedString">"complain when Push is fired at it"</span> in {
    <span class="stReserved">val</span> stackActor = fullStackActor
    assertThrows[<span class="stType">IllegalStateException</span>] {
      stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack actor (when empty)
- should return empty StackInfo when Size is fired at it
- should complain when Peek is fired at it
- should complain when Pop is fired at it
A Stack actor (when non-empty)
- should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor
- should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor
- should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor
- should return non-full StackInfo when Size is fired at non-full stack actor: almost empty stack actor
- should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost empty stack actor
- should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor
- should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor
- should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor
- should return non-full StackInfo when Size is fired at non-full stack actor: almost full stack actor
- should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost full stack actor
A Stack actor (when full)
- should return full StackInfo when Size is fired at it
- should return non-empty StackInfo when Size is fired at non-empty stack actor: full stack actor
- should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: full stack actor
- should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: full stack actor
- should complain when Push is fired at it</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Although in an <code>AsyncFlatSpec</code>, the <code>behavior of</code> clause is a nesting construct analogous to
<code>AsyncFunSpec</code>'s <code>describe</code> clause, you many sometimes need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in an
<code>AsyncFlatSpec</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFlatSpecStackBehaviors</code> example.</p><p>Given this <code>AsyncFlatSpecStackBehaviors</code> trait, calling it with the <code>almostEmptyStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack actor (when non-empty)"</span> should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
</pre></p><p>yields test names:</p><ul><li><code>A Stack actor (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack actor (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack actor (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>almostFullStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
</pre></p><p>yields different test names:</p><ul><li><code>A Stack actor (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack actor (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack actor (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncFlatSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFlatSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncFlatSpecLike:AsyncFlatSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFlatSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncFlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="AsyncFlatSpecLike.html"><span class="name">AsyncFlatSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncFlatSpec</code>, which facilitates a
&ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncFlatSpec</code>, which facilitates a
&ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><a href="AsyncFlatSpec.html"><code>AsyncFlatSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>AsyncFlatSpec</code> into some other class, you can use this
trait instead, because class <code>AsyncFlatSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFlatSpec.html">detailed
overview of <code>AsyncFlatSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.AsyncFreeSpec" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFreeSpecextendsAsyncFreeSpecLike"></a><a id="AsyncFreeSpec:AsyncFreeSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFreeSpecextendsAsyncFreeSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FreeSpec tests." href="AsyncFreeSpec.html"><span class="name">AsyncFreeSpec</span></a><span class="result"> extends <a href="AsyncFreeSpecLike.html" class="extype" name="org.scalatest.AsyncFreeSpecLike">AsyncFreeSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FreeSpec</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FreeSpec</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFreeSpec</code> is intended to enable users of <a href="FreeSpec.html"><code>FreeSpec</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FreeSpec</code> tests.
<em>Note: <code>AsyncFreeSpec</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FreeSpec</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Here's an example <code>AsyncFreeSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> - {
    <span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> - {
    <span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>In an <code>AsyncFreeSpec</code> you write a test with a string followed by <code>in</code> and the body of the
test in curly braces, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> in {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can nest a test inside any number of description clauses, which you write with a string followed by a dash character
and a block, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"addSoon"</span> - {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can nest description clauses as deeply as you want. Because the description clause is denoted with an operator, not
a word like <code>should</code>, you are free to structure the text however you wish.
In short, you structure an <code>AsyncFreeSpec</code> exactly like a <code>FreeSpec</code>, but with
tests having result type <code>Assertion</code> or <code>Future[Assertion]</code>. For more examples
of structure, see the documentation for <a href="FreeSpec.html"><code>FreeSpec</code></a>.</p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
For clarity, here's the relevant code in a REPL session:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext

scala&gt; implicit val executionContext = ExecutionContext.Implicits.global
executionContext: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@26141c5b

scala&gt; def addSoon(addends: Int*): Future[Int] = Future { addends.sum }
addSoon: (addends: Int*)scala.concurrent.Future[Int]

scala&gt; val futureSum: Future[Int] = addSoon(1, 2)
futureSum: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@721f47b2

scala&gt; futureSum map { sum =&gt; assert(sum == 3) }
res0: scala.concurrent.Future[org.scalatest.Assertion] = scala.concurrent.impl.Promise$DefaultPromise@3955cfcb
</pre></p><p>The second test has result type <code>Assertion</code>:</p><p><pre class="stREPL">
scala&gt; def addNow(addends: Int*): Int = addends.sum
addNow: (addends: Int*)Int

scala&gt; val sum: Int = addNow(1, 2)
sum: Int = 3

scala&gt; assert(sum == 3)
res1: org.scalatest.Assertion = Succeeded
</pre></p><p>When <code>AddSpec</code> is constructed, the second test will be implicitly converted to
<code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code>, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> - {
  <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
  assert(sum == <span class="stLiteral">3</span>)
  println(<span class="stQuotedString">"hi"</span>) <span class="stLineComment">// println has result type Unit</span>
  succeed       <span class="stLineComment">// succeed has result type Assertion</span>
}
</pre></p><p>An <code>AsyncFreeSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>it</code> method while the <code>AsyncFreeSpec</code> is
in its registration phase. Any attempt to register a test after the <code>AsyncFreeSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncFreeSpec</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>AsyncFreeSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncFreeSpec</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncFreeSpec</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="FreeSpec.html"><code>FreeSpec</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncFreeSpec</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncFreeSpec</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="FreeSpec.html"><code>FreeSpec</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncFreeSpec</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncFreeSpec</code> adds a method
<code>ignore</code> to strings that can be used instead of <code>in</code> to register a test. For example, to temporarily
disable the test with the name <code>"addSoon will eventually compute a sum of passed Ints"</code>, just
change &ldquo;<code>in</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> - {
    <span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> ignore {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> - {
    <span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- will immediately compute a sum of passed Ints</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> - {
    <span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> - {
    <span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stYellow">- will immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>it</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncFreeSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>AsyncFreeSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>AsyncFreeSpec</code>
to pass such information to the reporter. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
      succeed
    }
  }
}
</pre></p><p>If you run this <code>AsyncFreeSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncFreeSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>AsyncFreeSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
      succeed
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/freeSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
 A mutable Set
   + notes are sent immediately</span>
   <span class="stYellow">+ alerts are also sent immediately</span>
 <span class="stGreen">- should allow an element to be added
   + info is recorded
   + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> - {
    <span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> in (pending)
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> - {
    <span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- will immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFreeSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFreeSpec</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFreeSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFreeSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFreeSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> - {
    <span class="stQuotedString">"will eventually compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>) in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> - {
    <span class="stQuotedString">"will immediately compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
<br/>      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFreeSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is "</span> }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"easy!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"fun!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFreeSpec</code>.</p><p>Trait <code>AsyncFreeSpec</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"This test"</span> - {
    <span class="stQuotedString">"should succeed"</span> in {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">2</span>) }
    }
<br/>    <span class="stQuotedString">"should fail"</span> in {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSpec</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stLineComment">// This test needs the actor fixture</span>
    <span class="stQuotedString">"should be productive"</span> in {
      withActor { actor =&gt;
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"productive!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        futureString map { s =&gt;
          assert(s == <span class="stQuotedString">"ScalaTest is productive!"</span>)
        }
      }
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> - {
    <span class="stLineComment">// This test needs the database fixture</span>
    <span class="stQuotedString">"should be readable"</span> in {
      withDatabase { futureDb =&gt;
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"readable!"</span>)
          assert(db.toString == <span class="stQuotedString">"ScalaTest is readable!"</span>)
        }
      }
    }
<br/>    <span class="stLineComment">// This test needs both the actor and the database</span>
    <span class="stQuotedString">"should be clear and concise"</span> in {
      withDatabase { futureDb =&gt;
        withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          actor ! <span class="stType">Append</span>(<span class="stQuotedString">"concise!"</span>)
          <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
          <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
            futureDb zip futureString
          futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
            db.append(<span class="stQuotedString">"clear!"</span>)
            assert(db.toString == <span class="stQuotedString">"ScalaTest is clear!"</span>)
            assert(s == <span class="stQuotedString">"ScalaTest is concise!"</span>)
          }
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFreeSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFreeSpec.html">documentation for <code>fixture.AsyncFreeSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> - {
<br/>    <span class="stQuotedString">"should be easy"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFreeSpec</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFreeSpec</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFreeSpec</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfreespec.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt; <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt;= size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFreeSpec</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncFreeSpec</code> that uses them. If they are shared
between different <code>AsyncFreeSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFreeSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFreeSpec
<br/><span class="stReserved">trait</span> <span class="stType">AsyncFreeSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncFreeSpec</span> =>
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: => <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    (<span class="stQuotedString">"return non-empty StackInfo when Size is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =>
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek <- stackActor ? <span class="stType">Size</span>
          afterPeek <- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =>
        assert(afterPeek.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size == beforePeek.size)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop <- stackActor ? <span class="stType">Size</span>
          afterPop <- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =>
        assert(afterPop.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size == beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: => <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    (<span class="stQuotedString">"return non-full StackInfo when Size is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =>
        assert(!stackInfo.isFull)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush <- stackActor ? <span class="stType">Size</span>
          afterPush <- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =>
        assert(afterPush.top == <span class="stType">Some</span>(<span class="stLiteral">7</span>))
        assert(afterPush.size == beforePush.size + <span class="stLiteral">1</span>)
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncFreeSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFreeSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncFreeSpecStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i <- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stQuotedString">"A Stack"</span> - {
    <span class="stQuotedString">"(when empty)"</span> - {
      <span class="stQuotedString">"should be empty"</span> in {
        <span class="stReserved">val</span> stackActor = emptyStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =>
          assert(stackInfo.isEmpty)
        }
      }
<br/>      <span class="stQuotedString">"should complain on peek"</span> in {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Peek</span>
        }
      }
<br/>      <span class="stQuotedString">"should complain on pop"</span> in {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Pop</span>
        }
      }
    }
<br/>    <span class="stQuotedString">"(with one item)"</span> - {
      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
        behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
      }
    }
<br/>    <span class="stQuotedString">"(with one item less than capacity)"</span> - {
      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
        behave like nonFullStackActor(almostFullStackActor, almostFullStackActorName)
      }
    }
<br/>    <span class="stQuotedString">"(full)"</span> - {
<br/>      <span class="stQuotedString">"should be full"</span> in {
        <span class="stReserved">val</span> stackActor = fullStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =>
          assert(stackInfo.isFull)
        }
      }
<br/>      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName)
      }
<br/>      <span class="stQuotedString">"should complain on a push"</span> in {
        <span class="stReserved">val</span> stackActor = fullStackActor
        assertThrows[<span class="stType">IllegalStateException</span>] {
          stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack
  (when empty)
  - should be empty
  - should complain on peek
  - should complain on pop
  (with one item)
    should
    - return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor
    - return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor
    - return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor
    - return non-full StackInfo when Size is fired at non-full stack actor: almost empty stack actor
    - return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost empty stack actor
  (with one item less than capacity)
    should
    - return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor
    - return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor
    - return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor
    - return non-full StackInfo when Size is fired at non-full stack actor: almost full stack actor
    - return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost full stack actor
  (full)
  - should be full
    should
    - return non-empty StackInfo when Size is fired at non-empty stack actor: full stack actor
    - return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: full stack actor
    - return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: full stack actor
  - should complain on a push
</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Although in an <code>AsyncFreeSpec</code>, the <code>-</code> clause is a nesting construct analogous to
<code>AsyncFunSpec</code>'s <code>describe</code> clause, you many sometimes need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in an
<code>AsyncFreeSpec</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFreeSpecStackBehaviors</code> example.</p><p>Given this <code>AsyncFreeSpecStackBehaviors</code> trait, calling it with the <code>almostEmptyStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
</pre></p><p>yields test names:</p><ul><li><code>A Stack (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>almostFullStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
</pre></p><p>yields different test names:</p><ul><li><code>A Stack (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncFreeSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFreeSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncFreeSpecLike:AsyncFreeSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFreeSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncFreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)." href="AsyncFreeSpecLike.html"><span class="name">AsyncFreeSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncFreeSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are nested inside text clauses denoted with the dash
operator (<code>-</code>).</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncFreeSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are nested inside text clauses denoted with the dash
operator (<code>-</code>).</p><p><a href="AsyncFreeSpec.html"><code>AsyncFreeSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>AsyncFreeSpec</code> into some other class, you can use this
trait instead, because class <code>AsyncFreeSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFreeSpec.html">detailed
overview of <code>AsyncFreeSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.AsyncFunSpec" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSpecextendsAsyncFunSpecLike"></a><a id="AsyncFunSpec:AsyncFunSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFunSpecextendsAsyncFunSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSpec tests." href="AsyncFunSpec.html"><span class="name">AsyncFunSpec</span></a><span class="result"> extends <a href="AsyncFunSpecLike.html" class="extype" name="org.scalatest.AsyncFunSpecLike">AsyncFunSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FunSpec</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FunSpec</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFunSpec</code> is intended to enable users of <a href="FunSpec.html"><code>FunSpec</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FunSpec</code> tests.
<em>Note: <code>AsyncFunSpec</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FunSpec</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Here's an example <code>AsyncFunSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"addSoon"</span>) {
    it(<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  describe(<span class="stQuotedString">"addNow"</span>) {
    it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>An <code>AsyncFunSpec</code> contains <em>describe clauses</em> and tests. You define a describe clause
with <code>describe</code>, and a test with either <code>it</code> or <code>they</code>.
<code>describe</code>,  <code>it</code>, and <code>they</code> are methods, defined in
<code>AsyncFunSpec</code>, which will be invoked
by the primary constructor of <code>AddSpec</code>.
A describe clause names, or gives more information about, the <em>subject</em> (class or other entity) you are specifying
and testing. In the previous example, <code>"addSoon"</code> and <code>"addNow"</code> are
the subjects under specification and test. With each test you provide a string (the <em>spec text</em>) that specifies
one bit of behavior of the subject, and a block of code that tests that behavior.
You place the spec text between the parentheses, followed by the test code between curly
braces.  The test code will be wrapped up as a function passed as a by-name parameter to
<code>it</code> (or <code>they</code>), which will register the test for later execution.</p><p>Note: the <code>they</code> method is intended for use when the subject is plural, for example:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"The combinators"</span>) {
  they(<span class="stQuotedString">"should be easy to learn"</span>) { succeed }
  they(<span class="stQuotedString">"should be efficient"</span>) { succeed }
  they(<span class="stQuotedString">"should do something cool"</span>) { succeed }
}
</pre></p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
For clarity, here's the relevant code in a REPL session:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext

scala&gt; implicit val executionContext = ExecutionContext.Implicits.global
executionContext: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@26141c5b

scala&gt; def addSoon(addends: Int*): Future[Int] = Future { addends.sum }
addSoon: (addends: Int*)scala.concurrent.Future[Int]

scala&gt; val futureSum: Future[Int] = addSoon(1, 2)
futureSum: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@721f47b2

scala&gt; futureSum map { sum =&gt; assert(sum == 3) }
res0: scala.concurrent.Future[org.scalatest.Assertion] = scala.concurrent.impl.Promise$DefaultPromise@3955cfcb
</pre></p><p>The second test has result type <code>Assertion</code>:</p><p><pre class="stREPL">
scala&gt; def addNow(addends: Int*): Int = addends.sum
addNow: (addends: Int*)Int

scala&gt; val sum: Int = addNow(1, 2)
sum: Int = 3

scala&gt; assert(sum == 3)
res1: org.scalatest.Assertion = Succeeded
</pre></p><p>When <code>AddSpec</code> is constructed, the second test will be implicitly converted to
<code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code>, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker:</p><p><pre class="stHighlighted">
it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>) {
  <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
  assert(sum == <span class="stLiteral">3</span>)
  println(<span class="stQuotedString">"hi"</span>) <span class="stLineComment">// println has result type Unit</span>
  succeed       <span class="stLineComment">// succeed has result type Assertion</span>
}
</pre></p><p>An <code>AsyncFunSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>it</code> method while the <code>AsyncFunSpec</code> is
in its registration phase. Any attempt to register a test after the <code>AsyncFunSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncFunSpec</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>AsyncFunSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncFunSpec</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncFunSpec</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="FunSpec.html"><code>FunSpec</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncFunSpec</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncFunSpec</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="FunSpec.html"><code>FunSpec</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncFunSpec</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncFunSpec</code> provides registration
methods that start with <code>ignore</code> instead of <code>it</code> or <code>they</code>. For example, to temporarily
disable the test with the text <code>"will eventually compute a sum of passed Ints"</code>, just
change &ldquo;<code>it</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"addSoon"</span>) {
    ignore(<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  describe(<span class="stQuotedString">"addNow"</span>) {
    it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- will immediately compute a sum of passed Ints</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"addSoon"</span>) {
    it(<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  describe(<span class="stQuotedString">"addNow"</span>) {
    it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stYellow">- will immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>it</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncFunSpec</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>AsyncFunSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <code>Informer</code> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via one of its <code>apply</code> methods.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <code>InfoProvided</code> event.
Here's an example in which the <code>Informer</code> returned by <code>info</code> is used implicitly by the
<code>Given</code>, <code>When</code>, and <code>Then</code> methods of trait <code>GivenWhenThen</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
      succeed
    }
  }
}
</pre></p><p>If you run this <code>AsyncFunSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncFunSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>AsyncFunSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
      succeed
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/funSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"addSoon"</span>) {
    it(<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span>)(pending)
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  describe(<span class="stQuotedString">"addNow"</span>) {
    it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>) {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- will eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- will immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFunSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFunSpec</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFunSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFunSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFunSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"addSoon"</span>) {
    it(<span class="stQuotedString">"will eventually compute a sum of passed Ints"</span>, <span class="stType">Slow</span>) {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  describe(<span class="stQuotedString">"addNow"</span>) {
    it(<span class="stQuotedString">"will immediately compute a sum of passed Ints"</span>,
      <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
<br/>      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFunSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is "</span> }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"easy!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"fun!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFunSpec</code>.</p><p>Trait <code>AsyncFunSpec</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  describe(<span class="stQuotedString">"This test"</span>) {
    it(<span class="stQuotedString">"should succeed"</span>) {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">2</span>) }
    }
<br/>  it(<span class="stQuotedString">"should fail"</span>) {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSpec</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    <span class="stLineComment">// This test needs the actor fixture</span>
    it(<span class="stQuotedString">"should be productive"</span>) {
      withActor { actor =&gt;
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"productive!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        futureString map { s =&gt;
          assert(s == <span class="stQuotedString">"ScalaTest is productive!"</span>)
        }
      }
    }
  }
<br/>describe(<span class="stQuotedString">"Test code"</span>) {
    <span class="stLineComment">// This test needs the database fixture</span>
    it(<span class="stQuotedString">"should be readable"</span>) {
      withDatabase { futureDb =&gt;
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"readable!"</span>)
          assert(db.toString == <span class="stQuotedString">"ScalaTest is readable!"</span>)
        }
      }
    }
<br/><span class="stLineComment">// This test needs both the actor and the database</span>
    it(<span class="stQuotedString">"should be clear and concise"</span>) {
      withDatabase { futureDb =&gt;
        withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          actor ! <span class="stType">Append</span>(<span class="stQuotedString">"concise!"</span>)
          <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
          <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
            futureDb zip futureString
          futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
            db.append(<span class="stQuotedString">"clear!"</span>)
            assert(db.toString == <span class="stQuotedString">"ScalaTest is clear!"</span>)
            assert(s == <span class="stQuotedString">"ScalaTest is concise!"</span>)
          }
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>  <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFunSpec.html">documentation for <code>fixture.AsyncFunSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/><span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
<br/>    it(<span class="stQuotedString">"should be easy"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFunSpec</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFunSpec</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFunSpec</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunspec.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt; <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt; size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFunSpec</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncFunSpec</code> that uses them. If they are shared
between different <code>AsyncFunSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFunSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFunSpec
<br/><span class="stReserved">trait</span> <span class="stType">AsyncFunSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncFunSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: =&gt; <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    it(<span class="stQuotedString">"should return non-empty StackInfo when Size is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    it(<span class="stQuotedString">"should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek &lt;- stackActor ? <span class="stType">Size</span>
          afterPeek &lt;- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =&gt;
        assert(afterPeek.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size == beforePeek.size)
      }
    }
<br/>    it(<span class="stQuotedString">"should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop &lt;- stackActor ? <span class="stType">Size</span>
          afterPop &lt;- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =&gt;
        assert(afterPop.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size == beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: =&gt; <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    it(<span class="stQuotedString">"should return non-full StackInfo when Size is fired at non-full stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isFull)
      }
    }
<br/>    it(<span class="stQuotedString">"should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush &lt;- stackActor ? <span class="stType">Size</span>
          afterPush &lt;- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =&gt;
        assert(afterPush.top == <span class="stType">Some</span>(<span class="stLiteral">7</span>))
        assert(afterPush.size == beforePush.size + <span class="stLiteral">1</span>)
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncFunSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
it should behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncFunSpecStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  describe(<span class="stQuotedString">"A Stack"</span>) {
    describe(<span class="stQuotedString">"(when empty)"</span>) {
      it(<span class="stQuotedString">"should be empty"</span>) {
        <span class="stReserved">val</span> stackActor = emptyStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =&gt;
          assert(stackInfo.isEmpty)
        }
      }
<br/>      it(<span class="stQuotedString">"should complain on peek"</span>) {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Peek</span>
        }
      }
<br/>      it(<span class="stQuotedString">"should complain on pop"</span>) {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Pop</span>
        }
      }
    }
<br/>    describe(<span class="stQuotedString">"(when non-empty)"</span>) {
      it should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
      it should behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
      it should behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
      it should behave like nonFullStackActor(almostFullStackActor, almostFullStackActorName)
    }
<br/>    describe(<span class="stQuotedString">"(when full)"</span>) {
<br/>      it(<span class="stQuotedString">"should be full"</span>) {
        <span class="stReserved">val</span> stackActor = fullStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =&gt;
          assert(stackInfo.isFull)
        }
      }
<br/>      it should behave like nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName)
<br/>      it(<span class="stQuotedString">"should complain on a push"</span>) {
        <span class="stReserved">val</span> stackActor = fullStackActor
        assertThrows[<span class="stType">IllegalStateException</span>] {
          stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack
  (when empty)
  - should be empty
  - should complain on peek
  - should complain on pop
  (when non-empty)
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor
  - should return non-full StackInfo when Size is fired at non-full stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost empty stack actor
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor
  - should return non-full StackInfo when Size is fired at non-full stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost full stack actor
  (when full)
  - should be full
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: full stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: full stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: full stack actor
  - should complain on a push
</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Therefore, you need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in an
<code>AsyncFunSpec</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFunSpecStackBehaviors</code> example.</p><p>Given this <code>AsyncFunSpecStackBehaviors</code> trait, calling it with the <code>stackWithOneItem</code> fixture, like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
</pre></p><p>yields test names:</p><ul><li><code>A Stack (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>stackWithOneItemLessThanCapacity</code> fixture, like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
</pre></p><p>yields different test names:</p><ul><li><code>A Stack (when non-empty) should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack (when non-empty) should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncFunSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncFunSpecLike:AsyncFunSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFunSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncFunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="AsyncFunSpecLike.html"><span class="name">AsyncFunSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncFunSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are combined with text that specifies the behavior the tests
verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncFunSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are combined with text that specifies the behavior the tests
verify.</p><p><a href="AsyncFunSpec.html"><code>AsyncFunSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>AsyncFunSpec</code> into some other class, you can use this
trait instead, because class <code>AsyncFunSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFunSpec.html">detailed
overview of <code>AsyncFunSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.AsyncFunSuite" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSuiteextendsAsyncFunSuiteLike"></a><a id="AsyncFunSuite:AsyncFunSuite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFunSuiteextendsAsyncFunSuiteLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional FunSuite tests." href="AsyncFunSuite.html"><span class="name">AsyncFunSuite</span></a><span class="result"> extends <a href="AsyncFunSuiteLike.html" class="extype" name="org.scalatest.AsyncFunSuiteLike">AsyncFunSuiteLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FunSuite</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>FunSuite</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFunSuite</code> is intended to enable users of <a href="FunSuite.html"><code>FunSuite</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FunSuite</code> tests.
<em>Note: <code>AsyncFunSuite</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FunSuite</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Here's an example <code>AsyncFunSuite</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  test(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests, which</span>
    <span class="stLineComment">// must result in type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>&ldquo;<code>test</code>&rdquo; is a method, defined in <code>AsyncFunSuite</code>, which will be invoked
by the primary constructor of <code>AddSuite</code>. You specify the name of the test as
a string between the parentheses, and the test code itself between curly braces.
The test code is a function passed as a by-name parameter to <code>test</code>, which registers
it for later execution. The result type of the by-name in an <code>AsyncFunSuite</code> must
be <code>Future[Assertion]</code>.</p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
For clarity, here's the relevant code in a REPL session:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext

scala&gt; implicit val executionContext = ExecutionContext.Implicits.global
executionContext: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@26141c5b

scala&gt; def addSoon(addends: Int*): Future[Int] = Future { addends.sum }
addSoon: (addends: Int*)scala.concurrent.Future[Int]

scala&gt; val futureSum: Future[Int] = addSoon(1, 2)
futureSum: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@721f47b2

scala&gt; futureSum map { sum =&gt; assert(sum == 3) }
res0: scala.concurrent.Future[org.scalatest.Assertion] = scala.concurrent.impl.Promise$DefaultPromise@3955cfcb
</pre></p><p>The second test has result type <code>Assertion</code>:</p><p><pre class="stREPL">
scala&gt; def addNow(addends: Int*): Int = addends.sum
addNow: (addends: Int*)Int

scala&gt; val sum: Int = addNow(1, 2)
sum: Int = 3

scala&gt; assert(sum == 3)
res1: org.scalatest.Assertion = Succeeded
</pre></p><p>When <code>AddSuite</code> is constructed, the second test will be implicitly converted to
<code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code>, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker:</p><p><pre class="stHighlighted">
test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
  <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
  assert(sum == <span class="stLiteral">3</span>)
  println(<span class="stQuotedString">"hi"</span>) <span class="stLineComment">// println has result type Unit</span>
  succeed       <span class="stLineComment">// succeed has result type Assertion</span>
}
</pre></p><p>An <code>AsyncFunSuite</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>test</code> method while the <code>AsyncFunSuite</code> is
in its registration phase. Any attempt to register a test after the <code>AsyncFunSuite</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncFunSuite</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>AsyncFunSuite</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncFunSuite</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncFunSuite</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="FunSuite.html"><code>FunSuite</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncFunSuite</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncFunSuite</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="FunSuite.html"><code>FunSuite</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncFunSuite</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncFunSuite</code> provides registration
methods that start with <code>ignore</code> instead of <code>test</code>. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  ignore(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>If you run this version of <code>AddSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSuite)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSuite:</span>
<span class="stYellow">- addSoon will eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">- addNow will immediately compute a sum of passed Ints</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  test(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSuite</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSuite</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSuite)
<span class="stGreen">AddSuite:</span>
<span class="stYellow">- addSoon will eventually compute a sum of passed Ints !!! IGNORED !!!
- addNow will immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>test</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncFunSuite</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>AsyncFunSuite</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information
to the current <code>Reporter</code> is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <code>InfoProvided</code> event.
Here's an example that shows both a direct use as well as an indirect use through the methods
of <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
    succeed
  }
}
</pre></p><p>If you run this <code>AsyncFunSuite</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
<span class="stGreen">SetSuite:
- an element can be added to an empty mutable Set
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks!</span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncFunSuite</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>AsyncFunSuite</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    succeed
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/funSuite.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    info(<span class="stQuotedString">"info is recorded"</span>)
    markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
    note(<span class="stQuotedString">"notes are sent immediately"</span>)
    alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
    set += <span class="stQuotedString">"clarity"</span>
    assert(set.size === <span class="stLiteral">1</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSuite:
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- An element can be added to an empty mutable Set
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  test(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>) (pending)
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>) {
    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSuite)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSuite:</span>
<span class="stYellow">- addSoon will eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">- addNow will immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFunSuite</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFunSuite</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFunSuite</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFunSuite</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFunSuite</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  test(<span class="stQuotedString">"addSoon will eventually compute a sum of passed Ints"</span>, <span class="stType">Slow</span>) {
    <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can map assertions onto a Future, then return</span>
    <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
    futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  test(<span class="stQuotedString">"addNow will immediately compute a sum of passed Ints"</span>,
      <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
<br/>    <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
    <span class="stLineComment">// You can also write synchronous tests. The body</span>
    <span class="stLineComment">// must have result type Assertion:</span>
    assert(sum == <span class="stLiteral">3</span>)
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFunSuite</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is "</span> }
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    <span class="stReserved">val</span> future = fixture
    <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"easy!"</span> }
    result map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    <span class="stReserved">val</span> future = fixture
    <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"fun!"</span> }
    result map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFunSuite</code>.</p><p>Trait <code>AsyncFunSuite</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  test(<span class="stQuotedString">"This test should succeed"</span>) {
    addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum === <span class="stLiteral">2</span>) }
  }
<br/>  test(<span class="stQuotedString">"This test should fail"</span>) {
    addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum === <span class="stLiteral">3</span>) }
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
- this test should succeed</span>
Dir snapshot: hello.txt, world.txt
<span class="stRed">- this test should fail *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup </span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stLineComment">// This test needs the actor fixture</span>
  test(<span class="stQuotedString">"Testing should be productive"</span>) {
    withActor { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"productive!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s === <span class="stQuotedString">"ScalaTest is productive!"</span>)
      }
    }
  }
<br/>  <span class="stLineComment">// This test needs the database fixture</span>
  test(<span class="stQuotedString">"Test code should be readable"</span>) {
    withDatabase { futureDb =&gt;
      futureDb map { db =&gt;
        db.append(<span class="stQuotedString">"readable!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
      }
    }
  }
<br/>  <span class="stLineComment">// This test needs both the actor and the database</span>
  test(<span class="stQuotedString">"Test code should be clear and concise"</span>) {
    withDatabase { futureDb =&gt;
      withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"concise!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
          futureDb zip futureString
        futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
          db.append(<span class="stQuotedString">"clear!"</span>)
          assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
          assert(s === <span class="stQuotedString">"ScalaTest is concise!"</span>)
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> java.io._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncFunSuite</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) { actor =&gt;
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFunSuite.html">documentation for <code>fixture.AsyncFunSuite</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  test(<span class="stQuotedString">"testing should be easy"</span>) {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    }
  }
<br/>  test(<span class="stQuotedString">"testing should be fun"</span>) {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
    futureString map { s =&gt;
      assert(s === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
      succeed
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
      succeed
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Suite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Suite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
      succeed
    }
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
    <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
    <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
    futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
      assert(str === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(lst.isEmpty)
      bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
      succeed
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFunSuite</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFunSuite</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFunSuite</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncfunsuite.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt;= <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt;= size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
            <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>) }
          <span class="stReserved">else</span>
            <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
            <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>) }
          <span class="stReserved">else</span>
            <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFunSuite</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncFunSuite</code> that uses them. If they are shared
between different <code>AsyncFunSuite</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFunSuite</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncFunSuite
<br/><span class="stReserved">trait</span> <span class="stType">AsyncFunSuiteStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncFunSuite</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: =&gt; <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    test(<span class="stQuotedString">"Size is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    test(<span class="stQuotedString">"Peek is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek &lt;- stackActor ? <span class="stType">Size</span>
          afterPeek &lt;- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =&gt;
        assert(afterPeek.top === <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size === beforePeek.size)
      }
    }
<br/>    test(<span class="stQuotedString">"Pop is fired at non-empty stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop &lt;- stackActor ? <span class="stType">Size</span>
          afterPop &lt;- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =&gt;
        assert(afterPop.top === <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size === beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: =&gt; <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    test(<span class="stQuotedString">"non-full stack actor is not full: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isFull)
      }
    }
<br/>    test(<span class="stQuotedString">"Push is fired at non-full stack actor: "</span> + name) {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush &lt;- stackActor ? <span class="stType">Size</span>
          afterPush &lt;- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =&gt;
        assert(afterPush.top === <span class="stType">Some</span>(<span class="stLiteral">7</span>))
        assert(afterPush.size === beforePush.size + <span class="stLiteral">1</span>)
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncFunSuite</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName))
testsFor(nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName))
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSuite</span> <span class="stReserved">extends</span> <span class="stType">AsyncFunSuite</span> <span class="stReserved">with</span> <span class="stType">AsyncFunSuiteStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  test(<span class="stQuotedString">"an empty stack actor is empty"</span>) {
    <span class="stReserved">val</span> stackActor = emptyStackActor
    <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
    futureStackInfo map { stackInfo =&gt;
      assert(stackInfo.isEmpty)
    }
  }
<br/>  test(<span class="stQuotedString">"Peek is fired at an empty stack actor"</span>) {
    recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
      emptyStackActor ? <span class="stType">Peek</span>
    }
  }
<br/>  test(<span class="stQuotedString">"Pop is fired at an empty stack actor"</span>) {
    recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
      emptyStackActor ? <span class="stType">Pop</span>
    }
  }
<br/>  testsFor(nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName))
  testsFor(nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName))
<br/>  testsFor(nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName))
  testsFor(nonFullStackActor(almostFullStackActor, almostFullStackActorName))
<br/>  test(<span class="stQuotedString">"a full stack actor is full"</span>) {
    <span class="stReserved">val</span> stackActor = fullStackActor
    <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
    futureStackInfo map { stackInfo =&gt;
      assert(stackInfo.isFull)
    }
  }
<br/>  testsFor(nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName))
<br/>  test(<span class="stQuotedString">"Push is fired at a full stack actor"</span>) {
    <span class="stReserved">val</span> stackActor = fullStackActor
    assertThrows[<span class="stType">IllegalStateException</span>] {
      stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSuite)
<span class="stGreen">StackSuite:
StackSuite:
- an empty stack actor is empty
- Peek is fired at an empty stack actor
- Pop is fired at an empty stack actor
- Size is fired at non-empty stack actor: almost empty stack actor
- Peek is fired at non-empty stack actor: almost empty stack actor
- Pop is fired at non-empty stack actor: almost empty stack actor
- non-full stack actor is not full: almost empty stack actor
- Push is fired at non-full stack actor: almost empty stack actor
- Size is fired at non-empty stack actor: almost full stack actor
- Peek is fired at non-empty stack actor: almost full stack actor
- Pop is fired at non-empty stack actor: almost full stack actor
- non-full stack actor is not full: almost full stack actor
- Push is fired at non-full stack actor: almost full stack actor
- a full stack actor is full
- Size is fired at non-empty stack actor: full stack actor
- Peek is fired at non-empty stack actor: full stack actor
- Pop is fired at non-empty stack actor: full stack actor
- Push is fired at a full stack actor</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
In a <code>AsyncFunSuite</code> there is no nesting construct analogous to
<code>AsyncFunSpec</code>'s <code>describe</code> clause.
Therefore, you need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in an
<code>AsyncFunSuite</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFunSuiteStackBehaviors</code> example.</p><p>Given this <code>AsyncFunSuiteStackBehaviors</code> trait, calling it with the <code>stackWithOneItem</code> fixture, like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName))
</pre></p><p>yields test names:</p><ul><li><code>Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>stackWithOneItemLessThanCapacity</code> fixture, like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed))
</pre></p><p>yields different test names:</p><ul><li><code>Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncFunSuiteLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncFunSuiteLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncFunSuiteLike:AsyncFunSuiteLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncFunSuiteLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncFunSuite, which represents a suite of tests in which each test is represented as a function value." href="AsyncFunSuiteLike.html"><span class="name">AsyncFunSuiteLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncFunSuite</code>, which represents
a suite of tests in which each test is represented as a function value.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncFunSuite</code>, which represents
a suite of tests in which each test is represented as a function value.</p><p><a href="AsyncFunSuite.html"><code>AsyncFunSuite</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>AsyncFunSuite</code> into some other class, you can use this
trait instead, because class <code>AsyncFunSuite</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncFunSuite.html">detailed
overview of <code>AsyncFunSuite</code></a>.</p></div></div>
    </li><li name="org.scalatest.AsyncTestRegistration" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="AsyncTestRegistrationextendsAnyRef"></a><a id="AsyncTestRegistration:AsyncTestRegistration"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncTestRegistrationextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait declaring methods that can be used to register by-name test functions that have result type Future[Assertion]." href="AsyncTestRegistration.html"><span class="name">AsyncTestRegistration</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait declaring methods that can be used to register by-name test functions that
have result type <code>Future[Assertion]</code>.</p>
    </li><li name="org.scalatest.AsyncTestSuite" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTestSuiteextendsSuitewithRecoverMethodswithCompleteLastly"></a><a id="AsyncTestSuite:AsyncTestSuite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncTestSuiteextendsSuitewithRecoverMethodswithCompleteLastly" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="The base trait of ScalaTest's asynchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns a FutureOutcome." href="AsyncTestSuite.html"><span class="name">AsyncTestSuite</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a> with <a href="RecoverMethods.html" class="extype" name="org.scalatest.RecoverMethods">RecoverMethods</a> with <a href="CompleteLastly.html" class="extype" name="org.scalatest.CompleteLastly">CompleteLastly</a></span>
      </span>
      
      <p class="shortcomment cmt">The base trait of ScalaTest's <em>asynchronous testing styles</em>, which defines a
<code>withFixture</code> lifecycle method that accepts as its parameter a test function
that returns a <a href="FutureOutcome.html"><code>FutureOutcome</code></a>.</p><div class="fullcomment"><div class="comment cmt"><p>The base trait of ScalaTest's <em>asynchronous testing styles</em>, which defines a
<code>withFixture</code> lifecycle method that accepts as its parameter a test function
that returns a <a href="FutureOutcome.html"><code>FutureOutcome</code></a>.</p><p>The <code>withFixture</code> method add by this trait has the
following signature and implementation:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>This trait enables testing of asynchronous code without blocking.  Instead of returning
<code>Outcome</code> like <a href="TestSuite.html"><code>TestSuite</code></a>'s
<code>withFixture</code>, this trait's <code>withFixture</code> method returns a
<code>FutureOutcome</code>. Similarly, the <code>apply</code> method of test function interface,
<code>NoArgAsyncTest</code>, returns <code>FutureOutcome</code>:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In trait NoArgAsyncTest:</span>
<span class="stReserved">def</span> apply(): <span class="stType">FutureOutcome</span>
</pre></p><p>The <code>withFixture</code> method supports async testing, because when the test function returns,
the test body has not necessarily finished execution.</p><p>The recommended way to ensure cleanup is performed after a test body finishes execution is
to use a <code>complete</code>-<code>lastly</code> clause, syntax that is defined in trait
<a href="CompleteLastly.html"><code>CompleteLastly</code></a>, which this trait extends.
Using <code>cleanup</code>-<code>lastly</code> will ensure that cleanup will occur whether
<code>FutureOutcome</code>-producing code completes abruptly by throwing an exception, or returns
normally yielding a <code>FutureOutcome</code>. In the latter case,
<code>complete</code>-<code>lastly</code> will
register the cleanup code to execute asynchronously when the <code>FutureOutcome</code> completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;. Thus, the recommended
structure of a <code>withFixture</code> implementation that performs cleanup looks like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
  <span class="stLineComment">// Perform setup here</span>
  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>The test function and <code>withFixture</code> method returns a
<a href="FutureOutcome.html"><code>FutureOutcome</code></a>,
a ScalaTest class that wraps a Scala <code>Future[Outcome]</code> and offers methods
more specific to asynchronous test outcomes. In a Scala <code>Future</code>, any exception
results in a <code>scala.util.Failure</code>. In a <code>FutureOutcome</code>, a
thrown <code>TestPendingException</code> always results in a <code>Pending</code>,
a thrown <code>TestCanceledException</code> always results in a <code>Canceled</code>,
and any other exception, so long as it isn't suite-aborting, results in a
<code>Failed</code>. This is true of the asynchronous test code itself that's represented by
the <code>FutureOutcome</code> and any transformation or callback registered on the
<code>FutureOutcome</code> in <code>withFixture</code>.</p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action on the <code>FutureOutcome</code> using
one of <code>FutureOutcome</code>'s callback registration methods:</p><ul><li><code>onSucceededThen</code> - executed if the <code>Outcome</code> is a <code>Succeeded</code>.</li><li><code>onFailedThen</code> - executed if the <code>Outcome</code> is a <code>Failed</code>.</li><li><code>onCanceledThen</code> - executed if the <code>Outcome</code> is a <code>Canceled</code>.</li><li><code>onPendingThen</code> - executed if the <code>Outcome</code> is a <code>Pending</code>.</li><li><code>onOutcomeThen</code> - executed on any <code>Outcome</code> (<em>i.e.</em>, no
       suite-aborting exception is thrown).</li><li><code>onAbortedThen</code> - executed if a suite-aborting exception is thrown.</li><li><code>onCompletedThen</code> - executed whether the result is an <code>Outcome</code>
       or a thrown suite-aborting exception.</li></ul><p>For example, if you want to perform an action if a test fails, you'd register the
callback using <code>onFailedThen</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome onFailedThen { ex =&gt;
    <span class="stLineComment">// perform action that you want to occur</span>
    <span class="stLineComment">// only if a test fails here</span>
  }
}
</pre></p><p>Note that all callback registration methods, such as <code>onFailedThen</code> used in the
previous example, return a new <code>FutureOutcome</code> that won't complete until the
the original <code>FutureOutcome</code> <em>and the callback</em> has completed. If the callback
throws an exception, the resulting <code>FutureOutcome</code> will represent that exception.
For example, if a <code>FutureOutcome</code> results in <code>Failed</code>, but a callback
registered on that <code>FutureOutcome</code> with <code>onFailedThen</code> throws <code>TestPendingException</code>, the
result of the <code>FutureOutcome</code> returned by <code>onFailedThen</code> will
be <code>Pending</code>.</p><p>Lastly, if you want to change the outcome in some way in <code>withFixture</code>, you'll need to use
the <code>change</code> method of <code>FutureOutcome</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.AsyncTestSuiteMixin" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncTestSuiteMixinextendsSuiteMixin"></a><a id="AsyncTestSuiteMixin:AsyncTestSuiteMixin"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncTestSuiteMixinextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in AsyncTestSuite and can be overridden in stackable modification traits." href="AsyncTestSuiteMixin.html"><span class="name">AsyncTestSuiteMixin</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait defining abstract &quot;lifecycle&quot; methods that are implemented in <a href="AsyncTestSuite.html#lifecycle-methods"><code>AsyncTestSuite</code></a>
and can be overridden in stackable modification traits.</p><div class="fullcomment"><div class="comment cmt"><p>Trait defining abstract &quot;lifecycle&quot; methods that are implemented in <a href="AsyncTestSuite.html#lifecycle-methods"><code>AsyncTestSuite</code></a>
and can be overridden in stackable modification traits.</p><p>The main use case for this trait is to override <code>withFixture</code> in a mixin trait.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">ThreadSafeStringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builder.clear()
    }
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.AsyncWordSpec" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncWordSpecextendsAsyncWordSpecLike"></a><a id="AsyncWordSpec:AsyncWordSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncWordSpecextendsAsyncWordSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Enables testing of asynchronous code without blocking, using a style consistent with traditional WordSpec tests." href="AsyncWordSpec.html"><span class="name">AsyncWordSpec</span></a><span class="result"> extends <a href="AsyncWordSpecLike.html" class="extype" name="org.scalatest.AsyncWordSpecLike">AsyncWordSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>WordSpec</code> tests.</p><div class="fullcomment"><div class="comment cmt"><p>Enables testing of asynchronous code without blocking,
using a style consistent with traditional <code>WordSpec</code> tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
<code>AsyncFunSpec</code> is intended to enable users of <a href="FunSpec.html"><code>FunSpec</code></a>
to write non-blocking asynchronous tests that are consistent with their traditional <code>FunSpec</code> tests.
<em>Note: <code>AsyncFunSpec</code> is intended for use in special situations where non-blocking asynchronous
testing is needed, with class <code>FunSpec</code> used for general needs.</em>
</td></tr></table></p><p>Given a <code>Future</code> returned by the code you are testing,
you need not block until the <code>Future</code> completes before
performing assertions against its value. You can instead map those
assertions onto the <code>Future</code> and return the resulting
<code>Future[Assertion]</code> to ScalaTest. The test will complete
asynchronously, when the <code>Future[Assertion]</code> completes.</p><p>Here's an example <code>AsyncWordSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should {
    <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should {
    <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>&ldquo;<code>it</code>&rdquo; is a method, defined in <code>AsyncWordSpec</code>, which will be invoked
by the primary constructor of <code>AddSpec</code>. You specify the name of the test as
a string between the parentheses, and the test code itself between curly braces.
The test code is a function passed as a by-name parameter to <code>it</code>, which registers
it for later execution. The result type of the by-name in an <code>AsyncWordSpec</code> must
be <code>Future[Assertion]</code>.</p><p>In an <code>AsyncWordSpec</code> you write a one (or more) sentence specification for each bit of behavior you wish to
specify and test. Each specification sentence has a
&quot;subject,&quot; which is sometimes called the <em>system under test</em> (or SUT). The
subject is entity being specified and tested and also serves as the subject of the sentences you write for each test. A subject
can be followed by one of three verbs, <code>should</code>, <code>must</code>, or <code>can</code>, and a block. Here are some
examples:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> should {
  <span class="stLineComment">// ...</span>
}
<span class="stQuotedString">"An Account"</span> must {
  <span class="stLineComment">// ...</span>
}
<span class="stQuotedString">"A ShippingManifest"</span> can {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can describe a subject in varying situations by using a <code>when</code> clause. A <code>when</code> clause
follows the subject and precedes a block. In the block after the <code>when</code>, you place strings that describe a situation or a state
the subject may be in using a string, each followed by a verb. Here's an example:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> when {
  <span class="stQuotedString">"empty"</span> should {
    <span class="stLineComment">// ...</span>
  }
  <span class="stQuotedString">"non-empty"</span> should {
    <span class="stLineComment">// ...</span>
  }
  <span class="stQuotedString">"full"</span> should {
    <span class="stLineComment">// ...</span>
  }
}
</pre></p><p>When you are ready to finish a sentence, you write a string followed by <code>in</code> and a block that
contains the code of the test.
In short, you structure an <code>AsyncWordSpec</code> exactly like a <code>WordSpec</code>, but with
tests having result type <code>Assertion</code> or <code>Future[Assertion]</code>. For more examples
of structure, see the documentation for <a href="WordSpec.html"><code>WordSpec</code></a>.</p><p>Starting with version 3.0.0, ScalaTest assertions and matchers have result type <code>Assertion</code>.
The result type of the first test in the example above, therefore, is <code>Future[Assertion]</code>.
For clarity, here's the relevant code in a REPL session:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext

scala&gt; implicit val executionContext = ExecutionContext.Implicits.global
executionContext: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@26141c5b

scala&gt; def addSoon(addends: Int*): Future[Int] = Future { addends.sum }
addSoon: (addends: Int*)scala.concurrent.Future[Int]

scala&gt; val futureSum: Future[Int] = addSoon(1, 2)
futureSum: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@721f47b2

scala&gt; futureSum map { sum =&gt; assert(sum == 3) }
res0: scala.concurrent.Future[org.scalatest.Assertion] = scala.concurrent.impl.Promise$DefaultPromise@3955cfcb
</pre></p><p>The second test has result type <code>Assertion</code>:</p><p><pre class="stREPL">
scala&gt; def addNow(addends: Int*): Int = addends.sum
addNow: (addends: Int*)Int

scala&gt; val sum: Int = addNow(1, 2)
sum: Int = 3

scala&gt; assert(sum == 3)
res1: org.scalatest.Assertion = Succeeded
</pre></p><p>When <code>AddSpec</code> is constructed, the second test will be implicitly converted to
<code>Future[Assertion]</code> and registered. The implicit conversion is from <code>Assertion</code>
to <code>Future[Assertion]</code>, so you must end synchronous tests in some ScalaTest assertion
or matcher expression. If a test would not otherwise end in type <code>Assertion</code>, you can
place <code>succeed</code> at the end of the test. <code>succeed</code>, a field in trait <code>Assertions</code>,
returns the <code>Succeeded</code> singleton:</p><p><pre class="stREPL">
scala&gt; succeed
res2: org.scalatest.Assertion = Succeeded
</pre></p><p>Thus placing <code>succeed</code> at the end of a test body will satisfy the type checker:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
  <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
  assert(sum == <span class="stLiteral">3</span>)
  println(<span class="stQuotedString">"hi"</span>) <span class="stLineComment">// println has result type Unit</span>
  succeed       <span class="stLineComment">// succeed has result type Assertion</span>
}
</pre></p><p>An <code>AsyncWordSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>it</code> method while the <code>AsyncWordSpec</code> is
in its registration phase. Any attempt to register a test after the <code>AsyncWordSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>AsyncWordSpec</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>AsyncWordSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="asyncExecutionModel"></a></p><h4> Asynchronous execution model </h4><p><code>AsyncWordSpec</code> extends <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, which provides an
implicit <code>scala.concurrent.ExecutionContext</code>
named <code>executionContext</code>. This
execution context is used by <code>AsyncWordSpec</code> to
transform the <code>Future[Assertion]</code>s returned by each test
into the <a href="FutureOutcome.html"><code>FutureOutcome</code></a> returned by the <code>test</code> function
passed to <code>withFixture</code>.
This <code>ExecutionContext</code> is also intended to be used in the tests,
including when you map assertions onto futures.</p><p>On both the JVM and Scala.js, the default execution context provided by ScalaTest's asynchronous
testing styles confines execution to a single thread per test. On JavaScript, where single-threaded
execution is the only possibility, the default execution context is
<code>scala.scalajs.concurrent.JSExecutionContext.Implicits.queue</code>. On the JVM,
the default execution context is a <em>serial execution context</em> provided by ScalaTest itself.</p><p>When ScalaTest's serial execution context is called upon to execute a task, that task is recorded
in a queue for later execution. For example, one task that will be placed in this queue is the
task that transforms the <code>Future[Assertion]</code> returned by an asynchronous test body
to the <code>FutureOutcome</code> returned from the <code>test</code> function.
Other tasks that will be queued are any transformations of, or callbacks registered on, <code>Future</code>s that occur
in your test body, including any assertions you map onto <code>Future</code>s. Once the test body returns,
the thread that executed the test body will execute the tasks in that queue one after another, in the order they
were enqueued.</p><p>ScalaTest provides its serial execution context as the default on the JVM for three reasons. First, most often
running both tests and suites in parallel does not give a significant performance boost compared to
just running suites in parallel. Thus parallel execution of <code>Future</code> transformations within
individual tests is not generally needed for performance reasons.</p><p>Second, if multiple threads are operating in the same suite
concurrently, you'll need to make sure access to any mutable fixture objects by multiple threads is synchronized.
Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
this does not hold true for callbacks, and in general it is easy to make a mistake. Simply put: synchronizing access to
shared mutable state is difficult and error prone.
Because ScalaTest's default execution context on the JVM confines execution of <code>Future</code> transformations
and call backs to a single thread, you need not (by default) worry about synchronizing access to mutable state
in your asynchronous-style tests.</p><p>Third, asynchronous-style tests need not be complete when the test body returns, because the test body returns
a <code>Future[Assertion]</code>. This <code>Future[Assertion]</code> will often represent a test that has not yet
completed. As a result, when using a more traditional execution context backed by a thread-pool, you could
potentially start many more tests executing concurrently than there are threads in the thread pool. The more
concurrently execute tests you have competing for threads from the same limited thread pool, the more likely it
will be that tests will intermitently fail due to timeouts.</p><p>Using ScalaTest's serial execution context on the JVM will ensure the same thread that produced the <code>Future[Assertion]</code>
returned from a test body is also used to execute any tasks given to the execution context while executing the test
body&#8212;<em>and that thread will not be allowed to do anything else until the test completes.</em>
If the serial execution context's task queue ever becomes empty while the <code>Future[Assertion]</code> returned by
that test's body has not yet completed, the thread will <em>block</em> until another task for that test is enqueued. Although
it may seem counter-intuitive, this blocking behavior means the total number of tests allowed to run concurrently will be limited
to the total number of threads executing suites. This fact means you can tune the thread pool such that maximum performance
is reached while avoiding (or at least, reducing the likelihood of) tests that fail due to timeouts because of thread competition.</p><p>This thread confinement strategy does mean, however, that when you are using the default execution context on the JVM, you
must be sure to <em>never block</em> in the test body waiting for a task to be completed by the
execution context. If you block, your test will never complete. This kind of problem will be obvious, because the test will
consistently hang every time you run it. (If a test is hanging, and you're not sure which one it is,
enable <a href="Runner.scala#slowpokeNotifications">slowpoke notifications</a>.) If you really do
want to block in your tests, you may wish to just use a
traditional <a href="WordSpec.html"><code>WordSpec</code></a> with
<a href="concurrent/ScalaFutures.html"><code>ScalaFutures</code></a> instead. Alternatively, you could override
the <code>executionContext</code> and use a traditional <code>ExecutionContext</code> backed by a thread pool. This
will enable you to block in an asynchronous-style test on the JVM, but you'll need to worry about synchronizing access to
shared mutable state.</p><p>To use a different execution context, just override <code>executionContext</code>. For example, if you prefer to use
the <code>runNow</code> execution context on Scala.js instead of the default <code>queue</code>, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on Scala.js</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    org.scalatest.concurrent.TestExecutionContext.runNow
</pre></p><p>If you prefer on the JVM to use the global execution context, which is backed by a thread pool, instead of ScalaTest's default
serial execution contex, which confines execution to a single thread, you would write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// on the JVM (and also compiles on Scala.js, giving</span>
<span class="stLineComment">// you the queue execution context)</span>
<span class="stReserved">implicit</span> <span class="stReserved">override</span> <span class="stReserved">def</span> executionContext =
    scala.concurrent.ExecutionContext.Implicits.global
</pre></p><p><a name="serialAndParallel"></a></p><h4> Serial and parallel test execution </h4><p>By default (unless you mix in <code>ParallelTestExecution</code>), tests in an <code>AsyncWordSpec</code> will be executed one after
another, <em>i.e.</em>, serially. This is true whether those tests return <code>Assertion</code> or <code>Future[Assertion]</code>,
no matter what threads are involved. This default behavior allows
you to re-use a shared fixture, such as an external database that needs to be cleaned
after each test, in multiple tests in async-style suites. This is implemented by registering each test, other than the first test, to run
as a <em>continuation</em> after the previous test completes.</p><p>If you want the tests of an <code>AsyncWordSpec</code> to be executed in parallel, you
must mix in <code>ParallelTestExecution</code> and enable parallel execution of tests in your build.
You enable parallel execution in <a href="tools/Runner$.html"><code>Runner</code></a> with the <code>-P</code> command line flag.
In the ScalaTest Maven Plugin, set <code>parallel</code> to <code>true</code>.
In <code>sbt</code>, parallel execution is the default, but to be explicit you can write:</p><p><pre>
parallelExecution in Test := true // the default in sbt
</pre></p><p>On the JVM, if both <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in and
parallel execution is enabled in the build, tests in an async-style suite will be started in parallel, using threads from
the <a href="Distributor"><code>Distributor</code></a>, and allowed to complete in parallel, using threads from the
<code>executionContext</code>. If you are using ScalaTest's serial execution context, the JVM default, asynchronous tests will
run in parallel very much like traditional (such as <a href="WordSpec.html"><code>WordSpec</code></a>) tests run in
parallel: 1) Because <code>ParallelTestExecution</code> extends
<code>OneInstancePerTest</code>, each test will run in its own instance of the test class, you need not worry about synchronizing
access to mutable instance state shared by different tests in the same suite.
2) Because the serial execution context will confine the execution of each test to the single thread that executes the test body,
you need not worry about synchronizing access to shared mutable state accessed by transformations and callbacks of <code>Future</code>s
inside the test.</p><p>If <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> is mixed in but
parallel execution of suites is <em>not</em> enabled, asynchronous tests on the JVM will be started sequentially, by the single thread
that invoked <code>run</code>, but without waiting for one test to complete before the next test is started. As a result,
asynchronous tests will be allowed to <em>complete</em> in parallel, using threads
from the <code>executionContext</code>. If you are using the serial execution context, however, you'll see
the same behavior you see when parallel execution is disabled and a traditional suite that mixes in <code>ParallelTestExecution</code>
is executed: the tests will run sequentially. If you use an execution context backed by a thread-pool, such as <code>global</code>,
however, even though tests will be started sequentially by one thread, they will be allowed to run concurrently using threads from the
execution context's thread pool.</p><p>The latter behavior is essentially what you'll see on Scala.js when you execute a suite that mixes in <code>ParallelTestExecution</code>.
Because only one thread exists when running under JavaScript, you can't &quot;enable parallel execution of suites.&quot; However, it may
still be useful to run tests in parallel on Scala.js, because tests can invoke API calls that are truly asynchronous by calling into
external APIs that take advantage of non-JavaScript threads. Thus on Scala.js, <code>ParallelTestExecution</code> allows asynchronous
tests to run in parallel, even though they must be started sequentially. This may give you better performance when you are using API
calls in your Scala.js tests that are truly asynchronous.</p><p><a name="futuresAndExpectedExceptions"></a></p><h4> Futures and expected exceptions </h4><p>If you need to test for expected exceptions in the context of futures, you can use the
<code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code> methods of trait
<a href="RecoverMethods.html"><code>RecoverMethods</code></a>. Because this trait is mixed into
supertrait <code>AsyncTestSuite</code>, both of these methods are
available by default in an <code>AsyncWordSpec</code>.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#interceptMethod"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <a href="Assertions.html#assertThrowsMethod"><code>assertThrows</code></a>. The first one allows you to
perform further assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>AsyncWordSpec</code> adds a method
<code>ignore</code> to strings that can be used instead of <code>in</code> to register a test. For example, to temporarily
disable the test with the name <code>"A Stack should pop values in last-in-first-out order"</code>, just
change &ldquo;<code>in</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should {
    <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> ignore {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should {
    <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- should immediately compute a sum of passed Ints</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should {
    <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should {
    <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>AddSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>AddSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints !!! IGNORED !!!</span>
<span class="stGreen">addNow</span>
<span class="stYellow">- should immediately compute a sum of passed Ints !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a>
annotation instead.</p><p>If you want to ignore all tests of a suite on Scala.js, where annotations can't be inspected at runtime, you'll need
to change <code>it</code> to <code>ignore</code> at each test site. To make a suite non-discoverable on Scala.js, ensure it
does not declare a public no-arg constructor.  You can either declare a public constructor that takes one or more
arguments, or make the no-arg constructor non-public.  Because this technique will also make the suite non-discoverable
on the JVM, it is a good approach for suites you want to run (but not be discoverable) on both Scala.js and the JVM.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>AsyncWordSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>AsyncWordSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>AsyncWordSpec</code>
to pass such information to the reporter. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
      succeed
    }
  }
}
</pre></p><p>If you run this <code>AsyncWordSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks!</span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>AsyncWordSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>AsyncWordSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
      succeed
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/wordSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.pending
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should {
    <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> in (pending)
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should {
    <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> in {
      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>AddSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AddSpec)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">AddSpec:</span>
<span class="stGreen">addSoon</span>
<span class="stYellow">- should eventually compute a sum of passed Ints (pending)</span>
<span class="stGreen">addNow</span>
<span class="stGreen">- should immediately compute a sum of passed Ints</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>An <code>AsyncFunSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing an <code>AsyncFunSpec</code>, groups of tests can
optionally be included and/or excluded. To tag an <code>AsyncFunSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>AsyncFunSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>AsyncFunSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">AddSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"addSoon"</span> should {
    <span class="stQuotedString">"eventually compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>) in {
      <span class="stReserved">val</span> futureSum: <span class="stType">Future[Int]</span> = addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can map assertions onto a Future, then return</span>
      <span class="stLineComment">// the resulting Future[Assertion] to ScalaTest:</span>
      futureSum map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
<br/>  <span class="stReserved">def</span> addNow(addends: <span class="stType">Int</span>*): <span class="stType">Int</span> = addends.sum
<br/>  <span class="stQuotedString">"addNow"</span> should {
    <span class="stQuotedString">"immediately compute a sum of passed Ints"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
<br/>      <span class="stReserved">val</span> sum: <span class="stType">Int</span> = addNow(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
      <span class="stLineComment">// You can also write synchronous tests. The body</span>
      <span class="stLineComment">// must have result type Assertion:</span>
      assert(sum == <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of an <code>AsyncFunSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication in async styles:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and eliminate the need to
synchronize access to shared mutable state on the JVM.</p><p>The following sections describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgAsyncTest">
      <code>withFixture(NoArgAsyncTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgAsyncTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgAsyncTest">
      <code>withFixture(OneArgAsyncTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> fixture: <span class="stType">Future[String]</span> = <span class="stType">Future</span> { <span class="stQuotedString">"ScalaTest is "</span> }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"easy!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      <span class="stReserved">val</span> future = fixture
      <span class="stReserved">val</span> result = future map { s =&gt; s + <span class="stQuotedString">"fun!"</span> }
      result map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method.
For example, you could pass in an initial value for a fixture object as a parameter to the get-fixture method.</p><p><a name="withFixtureNoArgAsyncTest"></a></p><h6> Overriding <code>withFixture(NoArgAsyncTest)</code> </h6><p>Although the get-fixture method approach takes care of setting up a fixture at the beginning of each
test, it doesn't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgAsyncTest)</code>, a
method defined in trait <a href="AsyncTestSuite.html"><code>AsyncTestSuite</code></a>, a supertrait of <code>AsyncFunSpec</code>.</p><p>Trait <code>AsyncFunSpec</code>'s <code>runTest</code> method passes a no-arg async test function to
<code>withFixture(NoArgAsyncTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. The default implementation of <code>withFixture</code> simply
invokes the function and returns the result, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait AsyncTestSuite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before invoking the test function,
and/or perform cleanup after the test completes. The recommended way to ensure cleanup is performed after a test completes is
to use the <code>complete</code>-<code>lastly</code> syntax, defined in supertrait <a href="CompleteLastly.html"><code>CompleteLastly</code></a>.
The <code>complete</code>-<code>lastly</code> syntax will ensure that
cleanup will occur whether future-producing code completes abruptly by throwing an exception, or returns
normally yielding a future. In the latter case, <code>complete</code>-<code>lastly</code> will register the cleanup code
to execute asynchronously when the future completes.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you'll need to
register code performing that action as a callback on the <code>Future</code> using
one of <code>Future</code>'s registration methods: <code>onComplete</code>, <code>onSuccess</code>,
or <code>onFailure</code>. Note that if a test fails, that will be treated as a
<code>scala.util.Success(org.scalatest.Failed)</code>. So if you want to perform an
action if a test fails, for example, you'd register the callback using <code>onSuccess</code>.</p><p>Here's an example in which <code>withFixture(NoArgAsyncTest)</code> is used to take a
snapshot of the working directory if a test fails, and
send that information to the standard output stream:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.noargasynctest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) onFailedThen { _ =&gt;
      <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
      <span class="stReserved">val</span> fileNames = currDir.list()
      info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
    }
  }
<br/>  <span class="stReserved">def</span> addSoon(addends: <span class="stType">Int</span>*): <span class="stType">Future[Int]</span> = <span class="stType">Future</span> { addends.sum }
<br/>  <span class="stQuotedString">"This test"</span> should {
    <span class="stQuotedString">"succeed"</span> in {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">2</span>) }
    }
<br/>    <span class="stQuotedString">"fail"</span> in {
      addSoon(<span class="stLiteral">1</span>, <span class="stLiteral">1</span>) map { sum =&gt; assert(sum == <span class="stLiteral">3</span>) }
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSpec</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)</span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgAsyncTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p>Lastly, if you want to transform the outcome in some way in <code>withFixture</code>, you'll need to use either the
<code>map</code> or <code>transform</code> methods of <code>Future</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> futureOutcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  futureOutcome change { outcome =&gt;
    <span class="stLineComment">// transform the outcome into a new outcome here</span>
  }
}
</pre></p><p>Note that a <code>NoArgAsyncTest</code>'s <code>apply</code> method will return a <code>scala.util.Failure</code> only if
the test completes abruptly with a &quot;test-fatal&quot; exception (such as <code>OutOfMemoryError</code>) that should
cause the suite to abort rather than the test to fail. Thus usually you would use <code>map</code>
to transform future outcomes, not <code>transform</code>, so that such test-fatal exceptions pass through
unchanged. The suite will abort asynchronously with any exception returned from <code>NoArgAsyncTest</code>'s
apply method in a <code>scala.util.Failure</code>.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span> <span class="stLineComment">// java.lang.StringBuffer is thread-safe</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
    databases.remove(name)
  }
}
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Future[Db]</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> dbName = randomUUID.toString <span class="stLineComment">// generate a unique db name</span>
    <span class="stReserved">val</span> futureDb = <span class="stType">Future</span> { createDb(dbName) } <span class="stLineComment">// create the fixture</span>
    complete {
      <span class="stReserved">val</span> futurePopulatedDb =
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
        }
      testCode(futurePopulatedDb) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      removeDb(dbName) <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stReserved">def</span> withActor(testCode: <span class="stType">StringActor</span> =&gt; <span class="stType">Future[Assertion]</span>) = {
    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(actor) <span class="stLineComment">// "loan" the fixture to the test code</span>
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stLineComment">// This test needs the actor fixture</span>
    <span class="stQuotedString">"be productive"</span> in {
      withActor { actor =&gt;
        actor ! <span class="stType">Append</span>(<span class="stQuotedString">"productive!"</span>)
        <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
        futureString map { s =&gt;
          assert(s == <span class="stQuotedString">"ScalaTest is productive!"</span>)
        }
      }
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> should {
    <span class="stLineComment">// This test needs the database fixture</span>
    <span class="stQuotedString">"be readable"</span> in {
      withDatabase { futureDb =&gt;
        futureDb map { db =&gt;
          db.append(<span class="stQuotedString">"readable!"</span>)
          assert(db.toString == <span class="stQuotedString">"ScalaTest is readable!"</span>)
        }
      }
    }
<br/>    <span class="stLineComment">// This test needs both the actor and the database</span>
    <span class="stQuotedString">"be clear and concise"</span> in {
      withDatabase { futureDb =&gt;
        withActor { actor =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          actor ! <span class="stType">Append</span>(<span class="stQuotedString">"concise!"</span>)
          <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
          <span class="stReserved">val</span> futurePair: <span class="stType">Future[(Db, String)]</span> =
            futureDb zip futureString
          futurePair map { <span class="stReserved">case</span> (db, s) =&gt;
            db.append(<span class="stQuotedString">"clear!"</span>)
            assert(db.toString == <span class="stQuotedString">"ScalaTest is clear!"</span>)
            assert(s == <span class="stQuotedString">"ScalaTest is concise!"</span>)
          }
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating databases, it is a good idea to give each database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgAsyncTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a
<code>fixture.AsyncTestSuite</code> and overriding <code>withFixture(OneArgAsyncTest)</code>.
Each test in a <code>fixture.AsyncTestSuite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgAsyncTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg async test function, so you can perform fixture set up before invoking and passing
the fixture into the test function, and ensure clean up is performed after the test completes.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgAsyncTest)</code>, it is a good idea to let
<code>withFixture(NoArgAsyncTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgAsyncTest</code> to a <code>NoArgAsyncTest</code>. You can do that by passing
the fixture object to the <code>toNoArgAsyncTest</code> method of <code>OneArgAsyncTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgAsyncTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgAsyncTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.oneargasynctest
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AsyncWordSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">StringActor</span>
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgAsyncTest</span>): <span class="stType">FutureOutcome</span> = {
<br/>    <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
    complete {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgAsyncTest(actor))
    } lastly {
      actor ! <span class="stType">Clear</span> <span class="stLineComment">// ensure the fixture will be cleaned up</span>
    }
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in { actor =&gt;
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>In this example, the tests required one fixture object, a <code>StringActor</code>. If your tests need multiple fixture objects, you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects or, alternatively, a case class containing
the objects.  For more information on the <code>withFixture(OneArgAsyncTest)</code> technique, see
the <a href="fixture/AsyncFunSpec.html">documentation for <code>fixture.AsyncFunSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> actor = <span class="stReserved">new</span> <span class="stType">StringActor</span>
<br/>  before {
    actor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
  }
<br/>  after {
    actor ! <span class="stType">Clear</span> <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is easy!"</span>)
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      actor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = actor ? <span class="stType">GetValue</span>
      futureString map { s =&gt;
        assert(s == <span class="stQuotedString">"ScalaTest is fun!"</span>)
      }
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some
side-effecting mechanism, commonly by reassigning instance <code>var</code>s or by changing the state of mutable
objects held from instance <code>val</code>s (as in this example). If using instance <code>var</code>s or
mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state.</p><p>Note that on the JVM, if you override ScalaTest's default
<a href="#asyncExecutionModel"><em>serial execution context</em></a>, you will likely need to
worry about synchronizing access to shared mutable fixture state, because the execution
context may assign different threads to process
different <code>Future</code> transformations. Although access to mutable state along
the same linear chain of <code>Future</code> transformations need not be synchronized,
it can be difficult to spot cases where these constraints are violated. The best approach
is to use only immutable objects when transforming <code>Future</code>s. When that's not
practical, involve only thread-safe mutable objects, as is done in the above example.
On Scala.js, by contrast, you need not worry about thread synchronization, because
in effect only one thread exists.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilderActor</code> and <code>StringBufferActor</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.composingwithasyncfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.SuiteMixin
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      builderActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AsyncTestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">AsyncTestSuite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
    complete {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    } lastly {
      bufferActor ! <span class="stType">Clear</span>
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>If you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Defining actor messages</span>
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Clear</span> <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Append</span>(value: <span class="stType">String</span>) <span class="stReserved">extends</span> <span class="stType">StringOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">GetValue</span>
<br/><span class="stReserved">class</span> <span class="stType">StringBuilderActor</span> { <span class="stLineComment">// Simulating an actor</span>
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> sb = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; sb.append(value)
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; sb.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[String]</span> =
    <span class="stType">Future</span> {
      synchronized { sb.toString }
    }
}
<br/><span class="stReserved">class</span> <span class="stType">StringBufferActor</span> {
  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = ListBuffer.empty[<span class="stType">String</span>]
  <span class="stReserved">def</span> !(op: <span class="stType">StringOp</span>): <span class="stType">Unit</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Append</span>(value) =&gt; buf += value
        <span class="stReserved">case</span> <span class="stType">Clear</span> =&gt; buf.clear()
      }
    }
  <span class="stReserved">def</span> ?(get: GetValue.type)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[List[String]]</span> =
    <span class="stType">Future</span> {
      synchronized { buf.toList }
    }
}
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> builderActor = <span class="stReserved">new</span> <span class="stType">StringBuilderActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builderActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">final</span> <span class="stReserved">val</span> bufferActor = <span class="stReserved">new</span> <span class="stType">StringBufferActor</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> bufferActor ! <span class="stType">Clear</span>
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should {
<br/>    <span class="stQuotedString">"be easy"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"easy!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is easy!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"sweet"</span>)
        succeed
      }
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      builderActor ! <span class="stType">Append</span>(<span class="stQuotedString">"fun!"</span>)
      <span class="stReserved">val</span> futureString = builderActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futureList = bufferActor ? <span class="stType">GetValue</span>
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(String, List[String])]</span> = futureString zip futureList
      futurePair map { <span class="stReserved">case</span> (str, lst) =&gt;
        assert(str == <span class="stQuotedString">"ScalaTest is fun!"</span>)
        assert(lst.isEmpty)
        bufferActor ! <span class="stType">Append</span>(<span class="stQuotedString">"awesome"</span>)
        succeed
      }
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in an <code>AsyncFunSpec</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>AsyncFunSpec</code> that uses them, so that the tests they contain will
be registered as tests in that <code>AsyncFunSpec</code>.
For example, given this <code>StackActor</code> class:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.asyncwordspec.sharedtests
<br/><span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<span class="stReserved">import</span> scala.concurrent.Future
<span class="stReserved">import</span> scala.concurrent.ExecutionContext
<br/><span class="stLineComment">// Stack operations</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Push[T]</span>(value: T)
<span class="stReserved">sealed</span> <span class="stReserved">abstract</span> <span class="stReserved">class</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Pop</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Peek</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<span class="stReserved">case</span> <span class="stReserved">object</span> <span class="stType">Size</span> <span class="stReserved">extends</span> <span class="stType">StackOp</span>
<br/><span class="stLineComment">// Stack info</span>
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">StackInfo[T]</span>(top: <span class="stType">Option[T]</span>, size: <span class="stType">Int</span>, max: <span class="stType">Int</span>) {
  require(size &gt; <span class="stLiteral">0</span>, <span class="stQuotedString">"size was less than zero"</span>)
  require(max &gt; size, <span class="stQuotedString">"max was less than size"</span>)
  <span class="stReserved">val</span> isFull: <span class="stType">Boolean</span> = size == max
  <span class="stReserved">val</span> isEmpty: <span class="stType">Boolean</span> = size == <span class="stLiteral">0</span>
}
<br/><span class="stReserved">class</span> <span class="stType">StackActor[T]</span>(<span class="stType">Max</span>: <span class="stType">Int</span>, name: <span class="stType">String</span>) {
<br/>  <span class="stReserved">private</span> <span class="stReserved">final</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> !(push: <span class="stType">Push[T]</span>): <span class="stType">Unit</span> =
    synchronized {
      <span class="stReserved">if</span> (buf.size != <span class="stType">Max</span>)
        buf.prepend(push.value)
      <span class="stReserved">else</span>
        <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
    }
<br/>  <span class="stReserved">def</span> ?(op: <span class="stType">StackOp</span>)(<span class="stReserved">implicit</span> c: <span class="stType">ExecutionContext</span>): <span class="stType">Future[StackInfo[T]]</span> =
    synchronized {
      op <span class="stReserved">match</span> {
        <span class="stReserved">case</span> <span class="stType">Pop</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf.remove(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Peek</span> =&gt;
          <span class="stType">Future</span> {
            <span class="stReserved">if</span> (buf.size != <span class="stLiteral">0</span>)
              <span class="stType">StackInfo</span>(<span class="stType">Some</span>(buf(<span class="stLiteral">0</span>)), buf.size, <span class="stType">Max</span>)
            <span class="stReserved">else</span>
              <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't peek an empty stack"</span>)
          }
        <span class="stReserved">case</span> <span class="stType">Size</span> =&gt;
          <span class="stType">Future</span> { <span class="stType">StackInfo</span>(<span class="stType">None</span>, buf.size, <span class="stType">Max</span>) }
      }
    }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = name
}
</pre></p><p>You may want to test the stack represented by the <code>StackActor</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>AsyncFunSpec</code> for <code>StackActor</code>, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>AsyncWordSpec</code> that uses them. If they are shared
between different <code>AsyncFunSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>AsyncFunSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStackActor</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.AsyncWordSpec
<br/><span class="stReserved">trait</span> <span class="stType">AsyncWordSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">AsyncWordSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStackActor(createNonEmptyStackActor: =&gt; <span class="stType">StackActor[Int]</span>,
        lastItemAdded: <span class="stType">Int</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    (<span class="stQuotedString">"return non-empty StackInfo when Size is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isEmpty)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePeek &lt;- stackActor ? <span class="stType">Size</span>
          afterPeek &lt;- stackActor ? <span class="stType">Peek</span>
        } <span class="stReserved">yield</span> (beforePeek, afterPeek)
      futurePair map { <span class="stReserved">case</span> (beforePeek, afterPeek) =&gt;
        assert(afterPeek.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPeek.size == beforePeek.size)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonEmptyStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePop &lt;- stackActor ? <span class="stType">Size</span>
          afterPop &lt;- stackActor ? <span class="stType">Pop</span>
        } <span class="stReserved">yield</span> (beforePop, afterPop)
      futurePair map { <span class="stReserved">case</span> (beforePop, afterPop) =&gt;
        assert(afterPop.top == <span class="stType">Some</span>(lastItemAdded))
        assert(afterPop.size == beforePop.size - <span class="stLiteral">1</span>)
      }
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStackActor(createNonFullStackActor: =&gt; <span class="stType">StackActor[Int]</span>, name: <span class="stType">String</span>): <span class="stType">Unit</span> = {
<br/>    (<span class="stQuotedString">"return non-full StackInfo when Size is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
      futureStackInfo map { stackInfo =&gt;
        assert(!stackInfo.isFull)
      }
    }
<br/>    (<span class="stQuotedString">"return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: "</span> + name) in {
      <span class="stReserved">val</span> stackActor = createNonFullStackActor
      <span class="stReserved">val</span> futurePair: <span class="stType">Future[(StackInfo[Int], StackInfo[Int])]</span> =
        <span class="stReserved">for</span> {
          beforePush &lt;- stackActor ? <span class="stType">Size</span>
          afterPush &lt;- { stackActor ! <span class="stType">Push</span>(<span class="stLiteral">7</span>); stackActor ? <span class="stType">Peek</span> }
        } <span class="stReserved">yield</span> (beforePush, afterPush)
      futurePair map { <span class="stReserved">case</span> (beforePush, afterPush) =&gt;
        assert(afterPush.top == <span class="stType">Some</span>(<span class="stLiteral">7</span>))
        assert(afterPush.size == beforePush.size + <span class="stLiteral">1</span>)
      }
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>AsyncWordSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
</pre></p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">AsyncWordSpec</span> <span class="stReserved">with</span> <span class="stType">AsyncWordSpecStackBehaviors</span> {
<br/>  <span class="stReserved">val</span> <span class="stType">Max</span> = <span class="stLiteral">10</span>
  <span class="stReserved">val</span> <span class="stType">LastValuePushed</span> = <span class="stType">Max</span> - <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">val</span> emptyStackActorName = <span class="stQuotedString">"empty stack actor"</span>
  <span class="stReserved">def</span> emptyStackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, emptyStackActorName )
<br/>  <span class="stReserved">val</span> fullStackActorName = <span class="stQuotedString">"full stack actor"</span>
  <span class="stReserved">def</span> fullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, fullStackActorName )
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">0</span> until <span class="stType">Max</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostEmptyStackActorName = <span class="stQuotedString">"almost empty stack actor"</span>
  <span class="stReserved">def</span> almostEmptyStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostEmptyStackActorName )
    stackActor ! <span class="stType">Push</span>(<span class="stType">LastValuePushed</span>)
    stackActor
  }
<br/>  <span class="stReserved">val</span> almostFullStackActorName = <span class="stQuotedString">"almost full stack actor"</span>
  <span class="stReserved">def</span> almostFullStackActor = {
    <span class="stReserved">val</span> stackActor = <span class="stReserved">new</span> <span class="stType">StackActor[Int]</span>(<span class="stType">Max</span>, almostFullStackActorName)
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stType">LastValuePushed</span>)
      stackActor ! <span class="stType">Push</span>(i)
    stackActor
  }
<br/>  <span class="stQuotedString">"A Stack"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"be empty"</span> in {
        <span class="stReserved">val</span> stackActor = emptyStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =&gt;
          assert(stackInfo.isEmpty)
        }
      }
<br/>      <span class="stQuotedString">"complain on peek"</span> in {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Peek</span>
        }
      }
<br/>      <span class="stQuotedString">"complain on pop"</span> in {
        recoverToSucceededIf[<span class="stType">IllegalStateException</span>] {
          emptyStackActor ? <span class="stType">Pop</span>
        }
      }
    }
    <span class="stQuotedString">"non-empty"</span> should {
      behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
      behave like nonFullStackActor(almostEmptyStackActor, almostEmptyStackActorName)
      behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
      behave like nonFullStackActor(almostFullStackActor, almostFullStackActorName)
    }
    <span class="stQuotedString">"full"</span> should {
      <span class="stQuotedString">"be full"</span> in {
        <span class="stReserved">val</span> stackActor = fullStackActor
        <span class="stReserved">val</span> futureStackInfo = stackActor ? <span class="stType">Size</span>
        futureStackInfo map { stackInfo =&gt;
          assert(stackInfo.isFull)
        }
      }
      behave like nonEmptyStackActor(fullStackActor, <span class="stType">LastValuePushed</span>, fullStackActorName)
      <span class="stQuotedString">"complain on a push"</span> in {
        <span class="stReserved">val</span> stackActor = fullStackActor
        assertThrows[<span class="stType">IllegalStateException</span>] {
          stackActor ! <span class="stType">Push</span>(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack
  when empty
  - should be empty
  - should complain on peek
  - should complain on pop
  when non-empty
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor
  - should return non-full StackInfo when Size is fired at non-full stack actor: almost empty stack actor
  - should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost empty stack actor
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor
  - should return non-full StackInfo when Size is fired at non-full stack actor: almost full stack actor
  - should return before and after StackInfo that has existing size + 1 and new item as top when Push is fired at non-full stack actor: almost full stack actor
  when full
  - should be full
  - should return non-empty StackInfo when Size is fired at non-empty stack actor: full stack actor
  - should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: full stack actor
  - should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: full stack actor
  - should complain on a push
</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Although in an <code>AsyncWordSpec</code>, the <code>when</code>, <code>should</code>, <code>can</code> and <code>must</code> clause is a nesting construct analogous to
<code>AsyncFunSpec</code>'s <code>describe</code> clause, you many sometimes need to do a bit of
extra work to ensure that the test names are unique.  If a duplicate test name problem shows up in an
<code>AsyncFunSpec</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can call
<code>toString</code> on the shared fixture object, or pass this string
the same way you pass any other data needed by the shared tests.
This is the approach taken by the previous <code>AsyncFunSpecStackBehaviors</code> example.</p><p>Given this <code>AsyncFunSpecStackBehaviors</code> trait, calling it with the <code>almostEmptyStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostEmptyStackActor, <span class="stType">LastValuePushed</span>, almostEmptyStackActorName)
</pre></p><p>yields test names:</p><ul><li><code>A Stack when non-empty should return non-empty StackInfo when Size is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack when non-empty should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost empty stack actor</code></li><li><code>A Stack when non-empty should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost empty stack actor</code></li></ul><p>Whereas calling it with the <code>almostFullStackActor</code> fixture, like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStackActor(almostFullStackActor, <span class="stType">LastValuePushed</span>, almostFullStackActorName)
</pre></p><p>yields different test names:</p><ul><li><code>A Stack when non-empty should return non-empty StackInfo when Size is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack when non-empty should return before and after StackInfo that has existing size and lastItemAdded as top when Peek is fired at non-empty stack actor: almost full stack actor</code></li><li><code>A Stack when non-empty should return before and after StackInfo that has existing size - 1 and lastItemAdded as top when Pop is fired at non-empty stack actor: almost full stack actor</code></li></ul></div></div>
    </li><li name="org.scalatest.AsyncWordSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AsyncWordSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="AsyncWordSpecLike:AsyncWordSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AsyncWordSpecLikeextendsAsyncTestSuitewithAsyncTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class AsyncWordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="AsyncWordSpecLike.html"><span class="name">AsyncWordSpecLike</span></a><span class="result"> extends <a href="AsyncTestSuite.html" class="extype" name="org.scalatest.AsyncTestSuite">AsyncTestSuite</a> with <a href="AsyncTestRegistration.html" class="extype" name="org.scalatest.AsyncTestRegistration">AsyncTestRegistration</a> with <a href="words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>AsyncWordSpec</code>, which facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>AsyncWordSpec</code>, which facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><a href="AsyncWordSpec.html"><code>AsyncWordSpec</code></a> is a class, not a trait, to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the behavior of <code>AsyncWordSpec</code>
into some other class, you can use this trait instead, because class <code>AsyncWordSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="AsyncWordSpec.html">detailed overview of <code>AsyncWordSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.BeforeAndAfter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BeforeAndAfterextendsSuiteMixin"></a><a id="BeforeAndAfter:BeforeAndAfter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#BeforeAndAfterextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that can be mixed into suites that need code executed before and after running each test." href="BeforeAndAfter.html"><span class="name">BeforeAndAfter</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that can be mixed into suites that need code executed before and after running each test.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that can be mixed into suites that need code executed before and after running each test.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use trait <code>BeforeAndAfter</code> when you need to perform the same side-effects before and/or after tests, rather than at the beginning
or end of tests. <em>Note: For more insight into where <code>BeforeAndAfter</code> fits into the big picture, see the </em>
<a href="FlatSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for your chosen style trait.</em>
</td></tr></table></p><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.
Trait <code>BeforeAndAfter</code> offers one way to eliminate such code duplication:
a <code>before</code> clause that will register code to be run before each test,
and an <code>after</code> clause that will register code to be run after.</p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p><p>The <code>before</code> and <code>after</code> methods can each only be called once per <code>Suite</code>,
and cannot be invoked after <code>run</code> has been invoked.  If either of the registered before or after functions
complete abruptly with an exception, it will be reported as an aborted suite and no more tests will be attempted in that suite.</p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class unless you synchronized access to the shared, mutable state. This is why ScalaTest's <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. Were you to mix <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a> instead.</p><p>The advantage this trait has over <code>BeforeAndAfterEach</code> is that its syntax is more concise.
The main disadvantage is that it is not stackable, whereas <code>BeforeAndAfterEach</code> is. <em>I.e.</em>,
you can write several traits that extend <code>BeforeAndAfterEach</code> and provide <code>beforeEach</code> methods
that include a call to <code>super.beforeEach</code>, and mix them together in various combinations. By contrast,
only one call to the <code>before</code> registration function is allowed in a suite or spec that mixes
in <code>BeforeAndAfter</code>. In addition, <code>BeforeAndAfterEach</code> allows you to access
the config map and test name via the <a href="TestData.html"><code>TestData</code></a> passed to its <code>beforeEach</code> and
<code>afterEach</code> methods, whereas <code>BeforeAndAfter</code>
gives you no access to the config map.</p></div></div>
    </li><li name="org.scalatest.BeforeAndAfterAll" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BeforeAndAfterAllextendsSuiteMixin"></a><a id="BeforeAndAfterAll:BeforeAndAfterAll"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#BeforeAndAfterAllextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Stackable trait that can be mixed into suites that need methods invoked before and after executing the suite." href="BeforeAndAfterAll.html"><span class="name">BeforeAndAfterAll</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Stackable trait that can be mixed into suites that need methods invoked before and after executing the
suite.</p><div class="fullcomment"><div class="comment cmt"><p>Stackable trait that can be mixed into suites that need methods invoked before and after executing the
suite.</p><p>This trait allows code to be executed before and/or after all the tests and nested suites of a
suite are run. This trait overrides <code>run</code> and calls the
<code>beforeAll</code> method, then calls <code>super.run</code>. After the <code>super.run</code>
invocation completes, whether it returns normally or completes abruptly with an exception,
this trait's <code>run</code> method will invoke <code>afterAll</code>.</p><p>Trait <code>BeforeAndAfterAll</code> defines <code>beforeAll</code>
and <code>afterAll</code> methods that take no parameters. This trait's implementation of these
methods do nothing.</p><p>For example, the following <code>ExampleSpec</code> mixes in <code>BeforeAndAfterAll</code> and
in <code>beforeAll</code>, creates and writes to a temp file.
Each test class, <code>ExampleSpec</code> and all its nested
suites--<code>OneSpec</code>, <code>TwoSpec</code>, <code>RedSpec</code>,
and <code>BlueSpec</code>--tests that the file exists. After all of the nested suites
have executed, <code>afterAll</code> is invoked, which
deletes the file.
(Note: if you're unfamiliar with the <code>withFixture(OneArgTest)</code> approach to shared fixtures, check out
the documentation for trait <a href="fixture/FlatSpec.html"><code>fixture.FlatSpec</code></a>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.beforeandafterall
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">trait</span> <span class="stType">TempFileExistsSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpecLike</span> {
<br/>  <span class="stReserved">protected</span> <span class="stReserved">val</span> tempFileName = <span class="stQuotedString">"tmp.txt"</span>
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">File</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> file = <span class="stReserved">new</span> <span class="stType">File</span>(tempFileName)
    withFixture(test.toNoArgTest(file)) <span class="stLineComment">// loan the fixture to the test</span>
  }
<br/>  <span class="stQuotedString">"The temp file"</span> should (<span class="stQuotedString">"exist in "</span> + suiteName) in { file =&gt;
    assert(file.exists)
  }
}
<br/><span class="stReserved">class</span> <span class="stType">OneSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">TwoSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">RedSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">BlueSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">Suites</span>(
  <span class="stReserved">new</span> <span class="stType">OneSpec</span>,
  <span class="stReserved">new</span> <span class="stType">TwoSpec</span>,
  <span class="stReserved">new</span> <span class="stType">RedSpec</span>,
  <span class="stReserved">new</span> <span class="stType">BlueSpec</span>
) <span class="stReserved">with</span> <span class="stType">TempFileExistsSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfterAll</span> {
<br/>  <span class="stLineComment">// Set up the temp file needed by the test, taking</span>
  <span class="stLineComment">// a file name from the config map</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeAll() {
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(tempFileName)
    <span class="stReserved">try</span> writer.write(<span class="stQuotedString">"Hello, suite of tests!"</span>)
    <span class="stReserved">finally</span> writer.close()
  }
<br/>  <span class="stLineComment">// Delete the temp file</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> afterAll() {
    <span class="stReserved">val</span> file = <span class="stReserved">new</span> <span class="stType">File</span>(tempFileName)
    file.delete()
  }
}
</pre></p><p>If you do supply a mapping for <code>"tempFileName"</code> in the config map, you'll see that the temp file is available to all the tests:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
OneSpec:
The temp file
- should exist in OneSpec
TwoSpec:
The temp file
- should exist in TwoSpec
RedSpec:
The temp file
- should exist in RedSpec
BlueSpec:
The temp file
- should exist in BlueSpec
The temp file
- should exist in ExampleSpec</span>
</pre></p><p><strong>Note: this trait uses the <code>Status</code> result of <code>Suite</code>'s "run" methods
to ensure that the code in <code>afterAll</code> is executed after
all the tests and nested suites are executed even if a <code>Distributor</code> is passed.</strong></p><p>Note that it is <em>not</em> guaranteed that <code>afterAll</code> is invoked from the same thread as <code>beforeAll</code>,
so if there's any shared state between <code>beforeAll</code> and <code>afterAll</code> you'll need to make sure they are
synchronized correctly.</p></div></div>
    </li><li name="org.scalatest.BeforeAndAfterAllConfigMap" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BeforeAndAfterAllConfigMapextendsSuiteMixin"></a><a id="BeforeAndAfterAllConfigMap:BeforeAndAfterAllConfigMap"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#BeforeAndAfterAllConfigMapextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that can be mixed into suites that need methods that make use of the config map invoked before and/or after executing the suite." href="BeforeAndAfterAllConfigMap.html"><span class="name">BeforeAndAfterAllConfigMap</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that can be mixed into suites that need methods that make use of the config map invoked before and/or after
executing the suite.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that can be mixed into suites that need methods that make use of the config map invoked before and/or after
executing the suite.</p><p>This trait allows code to be executed before and/or after all the tests and nested suites of a
suite are run. This trait overrides <code>run</code> and calls the
<code>beforeAll(ConfigMap)</code> method, then calls <code>super.run</code>. After the <code>super.run</code>
invocation completes, whether it returns normally or completes abruptly with an exception,
this trait's <code>run</code> method will invoke <code>afterAll(ConfigMap)</code>.</p><p>Note that this trait differs from <code>BeforeAndAfterAll</code> in that it gives
the <code>beforeAll</code> and <code>afterAll</code> code access to the config map. If you don't need
the config map, use <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> instead.</p><p>Trait <code>BeforeAndAfterAllConfigMap</code> defines <code>beforeAll</code>
and <code>afterAll</code> methods that take a <code>configMap</code>.
This trait's implemention of each method does nothing.</p><p>For example, the following <code>ExampleSpec</code> mixes in <code>BeforeAndAfterAllConfigMap</code> and
in <code>beforeAll</code>, creates and writes to a temp file, taking the name of the temp file
from the <code>configMap</code>. This same <code>configMap</code> is then passed to the <code>run</code>
methods of the nested suites, <code>OneSpec</code>, <code>TwoSpec</code>, <code>RedSpec</code>,
and <code>BlueSpec</code>, so those suites can access the filename and, therefore, the file's
contents. After all of the nested suites have executed, <code>afterAll</code> is invoked, which
again grabs the file name from the <code>configMap</code> and deletes the file. Each of these five
test classes extend trait <code>TempFileExistsSpec</code>, which defines a test that ensures the temp file exists.
(Note: if you're unfamiliar with the <code>withFixture(OneArgTest)</code> approach to shared fixtures, check out
the documentation for trait <a href="fixture/FlatSpec.html"><code>fixture.FlatSpec</code></a>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.beforeandafterallconfigmap
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">trait</span> <span class="stType">TempFileExistsSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> {
<br/>  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">File</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> fileName = test.configMap.getRequired[<span class="stType">String</span>](<span class="stQuotedString">"tempFileName"</span>)
    <span class="stReserved">val</span> file = <span class="stReserved">new</span> <span class="stType">File</span>(fileName)
    withFixture(test.toNoArgTest(file)) <span class="stLineComment">// loan the fixture to the test</span>
  }
<br/>  <span class="stQuotedString">"The temp file"</span> should (<span class="stQuotedString">"exist in "</span> + suiteName) in { file =&gt;
    assert(file.exists)
  }
}
<br/><span class="stReserved">class</span> <span class="stType">OneSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">TwoSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">RedSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<span class="stReserved">class</span> <span class="stType">BlueSpec</span> <span class="stReserved">extends</span> <span class="stType">TempFileExistsSpec</span>
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">Suites</span>(
  <span class="stReserved">new</span> <span class="stType">OneSpec</span>,
  <span class="stReserved">new</span> <span class="stType">TwoSpec</span>,
  <span class="stReserved">new</span> <span class="stType">RedSpec</span>,
  <span class="stReserved">new</span> <span class="stType">BlueSpec</span>
) <span class="stReserved">with</span> <span class="stType">TempFileExistsSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfterAllConfigMap</span> {
<br/>  <span class="stReserved">private</span> <span class="stReserved">val</span> tempFileName = <span class="stQuotedString">"tempFileName"</span>
<br/>  <span class="stLineComment">// Set up the temp file needed by the test, taking</span>
  <span class="stLineComment">// a file name from the config map</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeAll(cm: <span class="stType">ConfigMap</span>) {
    assume(
      cm.isDefinedAt(tempFileName),
      <span class="stQuotedString">"must place a temp file name in the config map under the key: "</span> + tempFileName
    )
    <span class="stReserved">val</span> fileName = cm.getRequired[<span class="stType">String</span>](tempFileName)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(fileName)
    <span class="stReserved">try</span> writer.write(<span class="stQuotedString">"Hello, suite of tests!"</span>)
    <span class="stReserved">finally</span> writer.close()
  }
<br/>  <span class="stLineComment">// Delete the temp file</span>
  <span class="stReserved">override</span> <span class="stReserved">def</span> afterAll(cm: <span class="stType">ConfigMap</span>) {
    <span class="stReserved">val</span> fileName = cm.getRequired[<span class="stType">String</span>](<span class="stQuotedString">"tempFileName"</span>)
    <span class="stReserved">val</span> file = <span class="stReserved">new</span> <span class="stType">File</span>(fileName)
    file.delete()
  }
}
</pre></p><p>Running the above class in the interpreter will give an error if you don't supply a mapping for <code>"tempFileName"</code> in the config map:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:</span>
<span class="stRed">Exception encountered when invoking run on a suite. *** ABORTED ***
  Exception encountered when invoking run on a suite. (<console>:30)
*** RUN ABORTED ***
  An exception or error caused a run to abort: must place a temp file name in the config map under the key: tempFileName (<console>:30)</span>
</pre></p><p>If you do supply a mapping for <code>"tempFileName"</code> in the config map, you'll see that the temp file is available to all the tests:</p><p><pre class="stREPL">
scala&gt; (new ExampleSpec).execute(configMap = ConfigMap("tempFileName" -&gt; "tmp.txt"))
<span class="stGreen">ExampleSpec:
OneSpec:
The temp file
- should exist in OneSpec
TwoSpec:
The temp file
- should exist in TwoSpec
RedSpec:
The temp file
- should exist in RedSpec
BlueSpec:
The temp file
- should exist in BlueSpec
The temp file
- should exist in ExampleSpec</span>
</pre></p><p><strong>Note: As of 2.0.M5, this trait uses the newly added <code>Status</code> result of <code>Suite</code>'s "run" methods
to ensure that the code in <code>afterAll</code> is executed after
all the tests and nested suites are executed even if a <code>Distributor</code> is passed.</strong></p><p>Note that it is <em>not</em> guaranteed that <code>afterAll</code> is invoked from the same thread as <code>beforeAll</code>,
so if there's any shared state between <code>beforeAll</code> and <code>afterAll</code> you'll need to make sure they are
synchronized correctly.</p></div></div>
    </li><li name="org.scalatest.BeforeAndAfterEach" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BeforeAndAfterEachextendsSuiteMixin"></a><a id="BeforeAndAfterEach:BeforeAndAfterEach"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#BeforeAndAfterEachextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Stackable trait that can be mixed into suites that need code executed before and/or after running each test." href="BeforeAndAfterEach.html"><span class="name">BeforeAndAfterEach</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Stackable trait that can be mixed into suites that need code executed before and/or after running each test.</p><div class="fullcomment"><div class="comment cmt"><p>Stackable trait that can be mixed into suites that need code executed before and/or after running each test.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use trait <code>BeforeAndAfterEach</code> when you want to stack traits that perform side-effects before and/or after tests, rather
than at the beginning or end of tests.
<em>Note: For more insight into where <code>BeforeAndAfterEach</code> fits into the big picture, see the </em>
<a href="FlatSpec.html#sharedFixtures">Shared fixtures</a></em> section in the documentation for your chosen style trait.
</td></tr></table></p><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code, and
the slower your compile will likely be.
Trait <code>BeforeAndAfterEach</code> offers one way to eliminate such code duplication:
a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).</p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> {
      builder.clear()
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> {
      buffer.clear()
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The main advantage of <code>BeforeAndAfterEach</code> over <code>BeforeAndAfter</code> is that <code>BeforeAndAfterEach</code>.
enables trait stacking.
The main disadvantage of <code>BeforeAndAfterEach</code> compared to <code>BeforeAndAfter</code> is that <code>BeforeAndAfterEach</code>
requires more boilerplate. If you don't need trait stacking, use <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a> instead
of <code>BeforeAndAfterEach</code>.
If you want to make use of test data (the test name, config map, <em>etc.</em>) in your <code>beforeEach</code>
or <code>afterEach</code> method, use trait <a href="BeforeAndAfterEachTestData.html"><code>BeforeAndAfterEachTestData</code></a> instead.</p></div></div>
    </li><li name="org.scalatest.BeforeAndAfterEachTestData" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BeforeAndAfterEachTestDataextendsSuiteMixin"></a><a id="BeforeAndAfterEachTestData:BeforeAndAfterEachTestData"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#BeforeAndAfterEachTestDataextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Stackable trait that can be mixed into suites that need code that makes use of test data (test name, tags, config map, etc.) executed before and/or after running each test." href="BeforeAndAfterEachTestData.html"><span class="name">BeforeAndAfterEachTestData</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Stackable trait that can be mixed into suites that need code that makes use of test data (test name, tags, config map, <em>etc.</em>) executed
before and/or after running each test.</p><div class="fullcomment"><div class="comment cmt"><p>Stackable trait that can be mixed into suites that need code that makes use of test data (test name, tags, config map, <em>etc.</em>) executed
before and/or after running each test.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Use trait <code>BeforeAndAfterEachTestData</code> when you want to stack traits that perform side-effects before and/or after tests, rather
than at the beginning or end of tests, when you need access to any test data (such as the config map) in the before and/or after code.
<em>Note: For more insight into where <code>BeforeAndAfterEachTestData</code> fits into the big picture, see the </em>
<a href="FlatSpec.html#sharedFixtures">Shared fixtures</a> section in the documentation for your chosen style trait.</em>
</td></tr></table></p><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.
Trait <code>BeforeAndAfterEachTestData</code> offers one way to eliminate such code duplication:
a <code>beforeEach(TestData)</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach(TestData)</code> method that will be run after (like JUnit's <code>tearDown</code>).</p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingbeforeandaftereachtestdata
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEachTestData</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach(td: <span class="stType">TestData</span>) {
    builder.append(td.name)
    <span class="stReserved">super</span>.beforeEach(td) <span class="stLineComment">// To be stackable, must call super.beforeEach(TestData)</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach(td: <span class="stType">TestData</span>) {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach(td) <span class="stLineComment">// To be stackable, must call super.afterEach(TestData)</span>
    }
    <span class="stReserved">finally</span> {
      builder.clear()
    }
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEachTestData</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach(td: <span class="stType">TestData</span>) {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach(td) <span class="stLineComment">// To be stackable, must call super.afterEach(TestData)</span>
    }
    <span class="stReserved">finally</span> {
      buffer.clear()
    }
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"!"</span>)
    assert(builder.toString === <span class="stQuotedString">"Testing should be easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"!"</span>)
    assert(builder.toString === <span class="stQuotedString">"Testing should be fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach(TestData)</code> call at the end of each
<code>beforeEach(TestData)</code> method, and the <code>super.afterEach(TestData)</code> call at the beginning of each <code>afterEach(TestData)</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach(TestData)</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach(TestData)</code> throws an exception.</p><p>Besides enabling trait stacking, the other main advantage of <code>BeforeAndAfterEachTestData</code> over <code>BeforeAndAfter</code>
is that <code>BeforeAndAfterEachTestData</code> allows you to make use of test data (such as the test name and config map) in your before
and/or after code, whereas <code>BeforeAndAfter</code> does not.</p><p>The main disadvantage of <code>BeforeAndAfterEachTestData</code> compared to <code>BeforeAndAfter</code> and <code>BeforeAndAfterEach</code> is
that <code>BeforeAndAfterEachTestData</code> requires more boilerplate. If you don't need trait stacking or access to the test data, use
<a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a> instead
of <code>BeforeAndAfterEachTestData</code>.
If you need trait stacking, but not access to the <code>TestData</code>, use
<a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a> instead.</p></div></div>
    </li><li name="org.scalatest.CancelAfterFailure" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="CancelAfterFailureextendsTestSuiteMixin"></a><a id="CancelAfterFailure:CancelAfterFailure"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CancelAfterFailureextendsTestSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that when mixed into a TestSuite cancels any remaining tests in that TestSuite instance after a test fails." href="CancelAfterFailure.html"><span class="name">CancelAfterFailure</span></a><span class="result"> extends <a href="TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that when mixed into a <a href="TestSuite.html"><code>TestSuite</code></a> cancels any remaining tests in that
<code>TestSuite</code> instance after a test fails.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that when mixed into a <a href="TestSuite.html"><code>TestSuite</code></a> cancels any remaining tests in that
<code>TestSuite</code> instance after a test fails.</p><p>The intended use case for this trait is if you have a suite of long-running tests that are
related such that if one fails, you aren't interested in running the others, you can use this
trait to simply cancel any remaining tests, so you need not wait long for them to complete.</p><p>Note that this trait only cancels tests in the same <code>TestSuite</code> instance, because
it uses a private volatile instance variable as a flag to indicate whether or not a test has failed.
If you are running each test in its own instance, therefore, it would not cancel the
remaining tests, because they would not see the same flag. For this reason, this trait contains
a final implementation of a method defined in <a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>,
to prevent it from being mixed into any class that also mixes in <code>OneInstancePerTest</code>,
including by mixing in <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> or a <a href="path/package.html">path trait</a>.</p></div></div>
    </li><li name="org.scalatest.Canceled" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CanceledextendsExceptionalwithProductwithSerializable"></a><a id="Canceled:Canceled"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CanceledextendsExceptionalwithProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Outcome for a test that was canceled, containing an exception describing the cause of the cancelation." href="Canceled.html"><span class="name">Canceled</span></a><span class="params">(<span name="exception">exception: <a href="exceptions/TestCanceledException.html" class="extype" name="org.scalatest.exceptions.TestCanceledException">TestCanceledException</a></span>)</span><span class="result"> extends <a href="Exceptional.html" class="extype" name="org.scalatest.Exceptional">Exceptional</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Outcome for a test that was canceled, containing an exception describing the cause of the cancelation.</p>
    </li><li name="org.scalatest.Checkpoints" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="CheckpointsextendsAnyRef"></a><a id="Checkpoints:Checkpoints"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CheckpointsextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing class Checkpoint, which enables multiple assertions to be performed within a test, with any failures accumulated and reported together at the end of the test." href="Checkpoints.html"><span class="name">Checkpoints</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing class <code>Checkpoint</code>, which enables multiple assertions
to be performed within a test, with any failures accumulated and reported
together at the end of the test.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing class <code>Checkpoint</code>, which enables multiple assertions
to be performed within a test, with any failures accumulated and reported
together at the end of the test.</p><p>Because ScalaTest uses exceptions to signal failed assertions, normally execution
of a test will stop as soon as the first failed assertion is encountered. Trait
<code>Checkpoints</code> provides an option when you want to continue executing
the remainder of the test body, or part of it, even if an assertion has already failed in that test.</p><p>To use a <code>Checkpoint</code> (once you've mixed in or imported the members of trait
<code>Checkpoints</code>), you first need to create one, like this:</p><p><pre>
val cp = new Checkpoint
</pre></p><p>Then give the <code>Checkpoint</code> assertions to execute by passing them (via a by-name parameter)
to its <code>apply</code> method, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> (x, y) = (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)
cp { x should be &lt; <span class="stLiteral">0</span> }
cp { y should be &gt; <span class="stLiteral">9</span> }
</pre></p><p>Both of the above assertions will fail, but it won't be reported yet. The <code>Checkpoint</code> will execute them
right away, each time its <code>apply</code> method is invoked. But it will catch the <code>TestFailedExceptions</code> and
save them, only reporting them later when <code>reportAll</code> is invoked. Thus, at the end of the test, you must call
<code>reportAll</code>, like this:</p><p><pre>
cp.reportAll()
</pre></p><p>This <code>reportAll</code> invocation will complete abruptly with a <code>TestFailedException</code> whose message
includes the message, source file, and line number of each of the checkpointed assertions that previously failed. For example:</p><p><pre>
1 was not less than 0 (in Checkpoint) at ExampleSpec.scala:12
2 was not greater than 9 (in Checkpoint) at ExampleSpec.scala:13
</pre></p><p>Make sure you invoke <code>reportAll</code> before the test completes, otherwise any failures that were detected by the
<code>Checkpoint</code> will not be reported.</p><p>Note that a <code>Checkpoint</code> will catch and record for later reporting (via <code>reportAll</code>) exceptions that mix in <code>StackDepth</code>
except for <code>TestCanceledException</code>, <code>TestRegistrationClosedException</code>, <code>NotAllowedException</code>,
and <code>DuplicateTestNameException</code>. If a block of code passed to a <code>Checkpoint</code>'s <code>apply</code> method completes
abruptly with any of the <code>StackDepth</code> exceptions in the previous list, or any non-<code>StackDepth</code> exception, that invocation
of the <code>apply</code> method will complete abruptly with the same exception immediately. Unless you put <code>reportAll</code> in a finally
clause and handle this case, such an unexpected exception will cause you to lose any information about assertions that failed earlier in the test and were
recorded by the <code>Checkpoint</code>.</p></div></div>
    </li><li name="org.scalatest.CompleteLastly" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="CompleteLastlyextendsAnyRef"></a><a id="CompleteLastly:CompleteLastly"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CompleteLastlyextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides a complete-lastly construct, which ensures cleanup code in lastly is executed whether the code passed to complete completes abruptly with an exception or successfully results in a Future, FutureOutcome, or other type with an implicit Futuristic instance." href="CompleteLastly.html"><span class="name">CompleteLastly</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides a <code>complete</code>-<code>lastly</code> construct, which ensures
cleanup code in <code>lastly</code> is executed whether the code passed to <code>complete</code>
completes abruptly with an exception or successfully results in a <code>Future</code>,
<a href="FutureOutcome.html"><code>FutureOutcome</code></a>, or other type with an
implicit <a href="enablers/Futuristic.html"><code>Futuristic</code></a> instance.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides a <code>complete</code>-<code>lastly</code> construct, which ensures
cleanup code in <code>lastly</code> is executed whether the code passed to <code>complete</code>
completes abruptly with an exception or successfully results in a <code>Future</code>,
<a href="FutureOutcome.html"><code>FutureOutcome</code></a>, or other type with an
implicit <a href="enablers/Futuristic.html"><code>Futuristic</code></a> instance.</p><p>This trait is mixed into ScalaTest's async testing styles, to make it easy to ensure
cleanup code will execute whether code that produces a &quot;futuristic&quot; value (any type <code>F</code>
for which a <code>Futuristic[F]</code> instance is implicitly available). ScalaTest provides
implicit <code>Futuristic</code> instances for <code>Future[T]</code> for any type <code>T</code>
and <code>FutureOutcome</code>.</p><p>If the future-producing code passed to <code>complete</code> throws an
exception, the cleanup code passed to <code>lastly</code> will be executed immediately, and the same exception will
be rethrown, unless the code passed to <code>lastly</code> also completes abruptly with an exception. In that case,
<code>complete</code>-<code>lastly</code> will complete abruptly with the exception thrown by the code passed to
<code>lastly</code> (this mimics the behavior of <code>finally</code>).</p><p>Otherwise, if the code passed to <code>complete</code> successfully returns a <code>Future</code> (or other &quot;futuristic&quot; type),
<code>complete</code>-<code>lastly</code>
will register the cleanup code to be performed once the future completes and return a new future that will complete
once the original future completes <em>and</em> the subsequent cleanup code has completed execution. The future returned by
<code>complete</code>-<code>lastly</code> will have the same result as the original future passed to <code>complete</code>,
unless the cleanup code throws an exception. If the cleanup code passed to <code>lastly</code> throws
an exception, the future returned by <code>lastly</code> will fail with that exception.</p><p>The <code>complete</code>-<code>lastly</code> syntax is intended to be used to ensure cleanup code is executed
in async testing styles like <code>try</code>-<code>finally</code> is used in traditional testing styles.
Here's an example of <code>complete</code>-<code>lastly</code>
used in <code>withFixture</code> in an async testing style:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgAsyncTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  complete {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } lastly {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.CompositeStatus" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CompositeStatusextendsStatuswithSerializable"></a><a id="CompositeStatus:CompositeStatus"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CompositeStatusextendsStatuswithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Composite Status that aggregates its completion and failed states of set of other Statuses passed to its constructor." href="CompositeStatus.html"><span class="name">CompositeStatus</span></a><span class="result"> extends <a href="Status.html" class="extype" name="org.scalatest.Status">Status</a> with <span class="extype" name="java.io.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Composite <code>Status</code> that aggregates its completion and failed states of set of other <code>Status</code>es passed to its constructor.</p>
    </li><li name="org.scalatest.ConfigMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ConfigMapextendsMap[String,Any]withMapLike[String,Any,org.scalatest.ConfigMap]withSerializable"></a><a id="ConfigMap:ConfigMap"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ConfigMapextendsMap[String,Any]withMapLike[String,Any,org.scalatest.ConfigMap]withSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A map of configuration data." href="ConfigMap.html"><span class="name">ConfigMap</span></a><span class="result"> extends <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] with <span class="extype" name="scala.collection.immutable.MapLike">MapLike</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>, <a href="ConfigMap.html" class="extype" name="org.scalatest.ConfigMap">ConfigMap</a>] with <span class="extype" name="java.io.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">A map of configuration data.</p><div class="fullcomment"><div class="comment cmt"><p>A map of configuration data.</p><p>A <code>ConfigMap</code> can be populated from the <a href="tools/Runner$.html"><code>Runner</code></a> command line via <code>-D</code>
arguments. <code>Runner</code> passes it to many methods where you can use it to configure your
test runs. For example, <code>Runner</code> passed the <code>ConfigMap</code> to:</p><ul><li>the <code>apply</code> method of <a href="Reporter.html"><code>Reporter</code></a>s via <code>RunStarting</code> events</li><li>the <code>run</code> method of <a href="Suite.html"><code>Suite</code></a></li><li>the <code>runNestedSuites</code> method of <code>Suite</code></li><li>the <code>runTests</code> method of <code>Suite</code></li><li>the <code>runTest</code> method of <code>Suite</code></li><li>the <code>withFixture(NoArgTest)</code> method of <code>Suite</code></li><li>the <code>withFixture(OneArgTest)</code> method of <a href="fixture/Suite.html"><code>fixture.Suite</code></a></li><li>the <code>beforeEach(TestData)</code> method of <a href="BeforeAndAfterEachTestData.html"><code>BeforeAndAfterEachTestData</code></a></li><li>the <code>afterEach(TestData)</code> method of <code>BeforeAndAfterEachTestData</code></li></ul><p>In addition to accessing the <code>ConfigMap</code> in overriden implementations of the above methods, you can also transform
and pass along a modified <code>ConfigMap</code>.</p><p>A <code>ConfigMap</code> maps string keys to values of any type, <em>i.e.</em>, it is a <code>Map[String, Any]</code>.
To get a configuration value in a variable of the actual type of that value, therefore, you'll need to perform an unsafe cast. If
this cast fails, you'll get an exception, which so long as the <code>ConfigMap</code> is used only in tests, will
result in either a failed or canceled test or aborted suite. To give such exceptions nice stack depths and error messages, and to
eliminate the need for using <code>asInstanceOf</code> in your test code, <code>ConfigMap</code> provides three
methods for accessing values at expected types.</p><p>The <code>getRequired</code> method returns the value bound to a key cast to a specified type, or throws <a href="exceptions/TestCanceledException.html"><code>TestCanceledException</code></a>
if either the key is not bound or is bound to an incompatible type. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> tempFileName: <span class="stType">String</span> = configMap.getRequired[<span class="stType">String</span>](<span class="stQuotedString">"tempFileName"</span>)

</pre></p><p>The <code>getOptional</code> method returns the value bound to a key cast to a specified type, wrapped in a <code>Some</code>,
returns <code>None</code> if the key is not bound, or throws </code>TestCanceledException</code> if the key exists but is
bound to an incompatible type. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> tempFileName: <span class="stType">Option[String]</span> = configMap.getOptional[<span class="stType">String</span>](<span class="stQuotedString">"tempFileName"</span>)

</pre></p><p>The <code>getWithDefault</code> method returns the value bound to a key cast to a specified type,
returns a specified default value if the key is not bound, or throws </code>TestCanceledException</code> if the key exists but is
either not bound or is bound to an incompatible type. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> tempFileName: <span class="stType">String</span> = configMap.getWithDefault[<span class="stType">String</span>](<span class="stQuotedString">"tempFileName"</span>, <span class="stQuotedString">"tmp.txt"</span>)

</pre>
</p></div></div>
    </li><li name="org.scalatest.ConfigMapWrapperSuite" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ConfigMapWrapperSuiteextendsSuite"></a><a id="ConfigMapWrapperSuite:ConfigMapWrapperSuite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ConfigMapWrapperSuiteextendsSuite" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Wrapper Suite that passes an instance of the config map to the constructor of the wrapped Suite when run is invoked." href="ConfigMapWrapperSuite.html"><span class="name">ConfigMapWrapperSuite</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a></span>
      </span>
      
      <p class="shortcomment cmt">Wrapper <code>Suite</code> that passes an instance of the config map to the constructor of the
wrapped <code>Suite</code> when <code>run</code> is invoked.</p><div class="fullcomment"><div class="comment cmt"><p>Wrapper <code>Suite</code> that passes an instance of the config map to the constructor of the
wrapped <code>Suite</code> when <code>run</code> is invoked.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Trait <code>ConfigMapWrapperSuite</code> is primarily intended to be used with the <a href="path/package.html">"path" traits</a>, which can't
use the usual approaches to accessing the config map because of the eager manner in which they run tests.</em>
</td></tr></table></p><p>Each time <code>run</code> is invoked on an instance of <code>ConfigMapWrapperSuite</code>, this
suite will create a new instance of the suite to wrap, passing to the constructor the config map passed to
<code>run</code>. This way, if the same <code>ConfigMapWrapperSuite</code> instance is run multiple
times, each time with a different config map, an instance of the wrapped suite will be created
for each config map. In addition to being passed to the wrapped suite's constructor, the config map passed
to the <code>ConfigMapWrapperSuite</code>'s <code>run</code> method will also be passed to the <code>run</code>
method of the newly created wrapped suite instance.</p><p>The config map is accessible inside a <code>Suite</code> in many ways. It is passed to <code>run</code>,
<code>runNestedSuites</code>, <code>runTests</code>, and <code>runTest</code>. It is also passed to
<code>withFixture</code>, accessible via a method on <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> and
<a href="fixture/Suite$OneArgTest.html"><code>OneArgTest</code></a>.
It is passed to an overloaded forms of the <code>beforeEach</code> and <code>afterEach</code> methods of trait
<a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>, as well as overloaded forms of the <code>beforeAll</code> and
<code>afterAll</code> methods of trait <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a>. Tests themselves can have information
taken from the config map, or the entire config map, through various means. The config map may be passed into
the test via a <a href="fixture/ConfigMapFixture.html"><code>ConfigMapFixture</code></a>, for example. Class <code>ConfigMapWrapperSuite</code>
represents one more way to get at the config map inside a suite of test: <code>ConfigMapWrapperSuite</code> will
pass the config map to the constructor of your suite class, bringing it easily into scope for tests and
helper methods alike.</p><p>Having the config map passed to the suite constructor might be more convenient in some cases, but in the case
of the <a href="path/package.html"><code>org.scalatest.path</code></a> traits, it is necessary if a test needs
information from a config map. The reason is that in a path trait, the test code is executed eagerly,
<em>before <code>run</code> is invoked</em>. The results of the tests are registered when the tests are executed, and those
results are merely <em>reported</em> once <code>run</code> is invoked. Thus by the time <code>run</code> has been invoked, it
is too late to get the config map to the tests, which have already been executed. Using a <code>ConfigMapWrapperSuite</code> solves that problem.
By passing the config map to the constructor, it is available early enough for the running tests to use it.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<br/>@<span class="stType">WrapWith</span>(classOf[<span class="stType">ConfigMapWrapperSuite</span>])
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span>(configMap: <span class="stType">ConfigMap</span>) <span class="stReserved">extends</span> <span class="stType">path.FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A widget database"</span>) {
    it(<span class="stQuotedString">"should contain consistent values"</span>) {
      <span class="stReserved">val</span> dbName = configMap(<span class="stQuotedString">"WidgetDbName"</span>) <span class="stLineComment">// Can access config map</span>
      <span class="stLineComment">// ...</span>
    }
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.DiagrammedAssertions" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DiagrammedAssertionsextendsAssertions"></a><a id="DiagrammedAssertions:DiagrammedAssertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DiagrammedAssertionsextendsAssertions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Sub-trait of Assertions that override assert and assume methods to include a diagram showing the values of expression in the error message when the assertion or assumption fails." href="DiagrammedAssertions.html"><span class="name">DiagrammedAssertions</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a></span>
      </span>
      
      <p class="shortcomment cmt">Sub-trait of <code>Assertions</code> that override <code>assert</code> and <code>assume</code> methods to include
a diagram showing the values of expression in the error message when the assertion or assumption fails.</p><div class="fullcomment"><div class="comment cmt"><p>Sub-trait of <code>Assertions</code> that override <code>assert</code> and <code>assume</code> methods to include
a diagram showing the values of expression in the error message when the assertion or assumption fails.</p><p>Here are some examples:</p><p><pre class="stREPL">
scala&gt; import DiagrammedAssertions._
import DiagrammedAssertions._

scala&gt; assert(a == b || c &gt;= d)
org.scalatest.exceptions.TestFailedException:

assert(a == b || c &gt;= d)
       | |  | |  | |  |
       1 |  2 |  3 |  4
         |    |    false
         |    false
         false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(xs.exists(_ == 4))
org.scalatest.exceptions.TestFailedException:

assert(xs.exists(_ == 4))
       |  |
       |  false
       List(1, 2, 3)

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert("hello".startsWith("h") &amp;&amp; "goodbye".endsWith("y"))
org.scalatest.exceptions.TestFailedException:

assert("hello".startsWith("h") &amp;&amp; "goodbye".endsWith("y"))
       |       |          |    |  |         |        |
       "hello" true       "h"  |  "goodbye" false    "y"
                               false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(num.isInstanceOf[Int])
org.scalatest.exceptions.TestFailedException:

assert(num.isInstanceOf[Int])
       |   |
       1.0 false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(Some(2).isEmpty)
org.scalatest.exceptions.TestFailedException:

assert(Some(2).isEmpty)
       |    |  |
       |    2  false
       Some(2)

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(None.isDefined)
org.scalatest.exceptions.TestFailedException:

assert(None.isDefined)
       |    |
       None false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(xs.exists(i =&gt; i &gt; 10))
org.scalatest.exceptions.TestFailedException:

assert(xs.exists(i =&gt; i &gt; 10))
       |  |
       |  false
       List(1, 2, 3)

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

</pre></p><p>If the expression passed to <code>assert</code> or <code>assume</code> spans more than one line, <code>DiagrammedAssertions</code> falls
back to the default style of error message, since drawing a diagram would be difficult. Here's an example showing how
<code>DiagrammedAssertions</code> will treat a multi-line assertion (<em>i.e.</em>, you don't get a diagram):</p><p><pre class="stREPL">
scala&gt; assert("hello".startsWith("h") &amp;&amp;
     |   "goodbye".endsWith("y"))
org.scalatest.exceptions.TestFailedException: "hello" started with "h", but "goodbye" did not end with "y"
        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...
</pre></p><p>Also, since an expression diagram essentially represents multi-line ascii art, if a clue string is provided, it appears <em>above</em> the diagram, not after it. It will often also show up in the diagram:</p><p><pre class="stREPL">
scala&gt; assert(None.isDefined, "Don't do this at home")
org.scalatest.exceptions.TestFailedException: Don't do this at home

assert(None.isDefined, "Don't do this at home")
       |    |
       None false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...

scala&gt; assert(None.isDefined,
     |   "Don't do this at home")
org.scalatest.exceptions.TestFailedException: Don't do this at home

assert(None.isDefined,
       |    |
       None false

        at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
        ...
</pre></p><p>Trait <code>DiagrammedAssertions</code> was inspired by Peter Niederwieser's work in <a href="http://code.google.com/p/spock/">Spock</a> and <a href="https://github.com/pniederw/expecty">Expecty</a>.
</p></div></div>
    </li><li name="org.scalatest.DiagrammedExpr" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DiagrammedExpr[T]extendsAnyRef"></a><a id="DiagrammedExpr[T]:DiagrammedExpr[T]"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DiagrammedExpr[T]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="A trait that represent an expression recorded by DiagrammedExprMacro, which includes the following members:" href="DiagrammedExpr.html"><span class="name">DiagrammedExpr</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">A trait that represent an expression recorded by <code>DiagrammedExprMacro</code>, which includes the following members:</p><div class="fullcomment"><div class="comment cmt"><p>A trait that represent an expression recorded by <code>DiagrammedExprMacro</code>, which includes the following members:</p><ul><li>a boolean value</li><li>an anchor that records the position of this expression</li><li>anchor values of this expression (including sub-expressions)</li></ul><p><code>DiagrammedExpr</code> is used by code generated from <code>DiagrammedAssertionsMacro</code>, it needs to be public
so that the generated code can be compiled.  It is expected that ScalaTest users would ever need to use <code>DiagrammedExpr</code>
directly.
</p></div></div>
    </li><li name="org.scalatest.DistributedSuiteSorter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DistributedSuiteSorterextendsAnyRef"></a><a id="DistributedSuiteSorter:DistributedSuiteSorter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DistributedSuiteSorterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="A sorter for the events of a run's distributed suites." href="DistributedSuiteSorter.html"><span class="name">DistributedSuiteSorter</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">A sorter for the events of a run's distributed suites.</p><div class="fullcomment"><div class="comment cmt"><p>A sorter for the events of a run's distributed suites.</p><p>This trait is used, for example, when <code>-PS</code> is passed to <a href="tools/Runner$.html"><code>Runner</code></a>, to sort the
events of distributed suites such that each suite's events are propagated together, with a timeout if an event takes too long.</p></div></div>
    </li><li name="org.scalatest.DistributedTestSorter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DistributedTestSorterextendsAnyRef"></a><a id="DistributedTestSorter:DistributedTestSorter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DistributedTestSorterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="A sorter for the events of a suite's distributed tests." href="DistributedTestSorter.html"><span class="name">DistributedTestSorter</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">A sorter for the events of a suite's distributed tests.</p><div class="fullcomment"><div class="comment cmt"><p>A sorter for the events of a suite's distributed tests.</p><p>This trait is used, for example, by <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> to sort the
events of tests back into sequential order, with a timeout if an event takes too long.</p></div></div>
    </li><li name="org.scalatest.Distributor" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DistributorextendsAnyRef"></a><a id="Distributor:Distributor"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DistributorextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose instances facilitate parallel execution of Suites." href="Distributor.html"><span class="name">Distributor</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose instances facilitate parallel execution of <code>Suite</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>Trait whose instances facilitate parallel execution of <code>Suite</code>s.
An optional <code>Distributor</code> is passed to the <code>run</code> method of <a href="Suite.html"><code>Suite</code></a>. If a
<code>Distributor</code> is indeed passed, trait <code>Suite</code>'s implementation of <code>run</code> will
populate that <code>Distributor</code> with its nested <code>Suite</code>s (by passing them to the <code>Distributor</code>'s
<code>apply</code> method) rather than executing the nested <code>Suite</code>s directly. It is then up to another thread or process
to execute those <code>Suite</code>s.</p><p>If you have a set of nested <code>Suite</code>s that must be executed sequentially, you can mix in trait
<a href="SequentialNestedSuiteExecution.html"><code>SequentialNestedSuiteExecution</code></a>, which overrides <code>runNestedSuites</code> and
calls <code>super</code>'s <code>runNestedSuites</code> implementation, passing in <code>None</code> for the
<code>Distributor</code>.</p><p>Implementations of this trait must be thread safe.</p></div></div>
    </li><li name="org.scalatest.DoNotDiscover" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DoNotDiscoverextendsAnnotation"></a><a id="DoNotDiscover:DoNotDiscover"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DoNotDiscoverextendsAnnotation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Annotation used to indicate that an otherwise discoverable test class should not be discovered." href="DoNotDiscover.html"><span class="name">DoNotDiscover</span></a><span class="result"> extends <span class="extype" name="java.lang.annotation.Annotation">Annotation</span></span>
      </span>
      
      <p class="shortcomment cmt">Annotation used to indicate that an otherwise discoverable test class should not be discovered.</p><div class="fullcomment"><div class="comment cmt"><p>Annotation used to indicate that an otherwise discoverable test class should not be discovered.</p><p><em>Note: This is actually an annotation defined in Java, not a Scala trait. It must be defined in Java instead of Scala so it will be accessible
at runtime. It has been inserted into Scaladoc by pretending it is a trait.</em></p><p>ScalaTest will discover any class that either extends <a href="Suite.html"><code>Suite</code></a> and has a public, no-arg constructor, or is annotated with
a valid <a href="WrapWith.html"><code>WrapWith</code></a> annotation. If you wish to prevent a class from being discovered, simply annotate it
with <code>DoNotDiscover</code>, like this:</p><p><pre class="stHighlight">
import org.scalatest._

@DoNotDiscover
class SetSpec extends FlatSpec {

  "An empty Set" should "have size 0" in {
    assert(Set.empty.size === 0)
  }

  it should "produce NoSuchElementException when head is invoked" in {
    intercept[NoSuchElementException] {
      Set.empty.head
    }
  }
}
</pre></p><p>ScalaTest will run classes annotated with <code>DoNotDiscover</code> if asked to explicitly, it just won't discover them.</p><p>Note that because reflection is not supported on Scala.js, this annotation will only work on the JVM, not on Scala.js.</p></div></div>
    </li><li name="org.scalatest.Documenter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DocumenterextendsAnyRef"></a><a id="Documenter:Documenter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DocumenterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait to which markup text tests can be reported." href="Documenter.html"><span class="name">Documenter</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait to which markup text tests can be reported.</p><div class="fullcomment"><div class="comment cmt"><p>Trait to which markup text tests can be reported.</p><p>Note: <code>Documenter</code> will be described in more detail in a future 2.0 milestone release. As of this release
you can't see its effects yet.</p></div></div>
    </li><li name="org.scalatest.Documenting" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DocumentingextendsAnyRef"></a><a id="Documenting:Documenting"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DocumentingextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains a markup method, which can be used to send markup to the Reporter." href="Documenting.html"><span class="name">Documenting</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains a <code>markup</code> method, which can be used to send markup to the <a href="Reporter.html"><code>Reporter</code></a>.</p>
    </li><li name="org.scalatest.DynaTags" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DynaTagsextendsSerializablewithProduct"></a><a id="DynaTags:DynaTags"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DynaTagsextendsSerializablewithProduct" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Dynamic tags for a run." href="DynaTags.html"><span class="name">DynaTags</span></a><span class="params">(<span name="suiteTags">suiteTags: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>, <span name="testTags">testTags: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]]</span>)</span><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span> with <span class="extype" name="scala.Product">Product</span></span>
      </span>
      
      <p class="shortcomment cmt">Dynamic tags for a run.</p><div class="fullcomment"><div class="comment cmt"><p>Dynamic tags for a run.</p><p>Instances of this class are passed to the <a href="Filter.html"><code>Filter</code></a> constructor to
support running selected suites and tests via dynamic tagging. For example, dynamic tags can be used
to rerun tests that failed previously, or tests selected via a wildcard from <a href="tools/Runner$.html"><code>Runner</code></a> or
the Scala interpreter.</p></div><dl class="paramcmts block"><dt class="param">suiteTags</dt><dd class="cmt"><p>a map from String suite ID to a set of tags for that suite.</p></dd><dt class="param">testTags</dt><dd class="cmt"><p>a map from String suite ID to a map, whose keys are test names and values the tags for that test.</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NullPointerException"><code>NullPointerException</code></span> if either <code>suiteTags</code> or <code>testTags</code> is <code>null</code></p></span></dd></dl></div>
    </li><li name="org.scalatest.EitherValues" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="EitherValuesextendsAnyRef"></a><a id="EitherValues:EitherValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#EitherValuesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides an implicit conversion that adds left.value and right.value methods to Either, which will return the selected value of the Either if defined, or throw TestFailedException if not." href="EitherValues.html"><span class="name">EitherValues</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides an implicit conversion that adds <code>left.value</code> and <code>right.value</code> methods
to <code>Either</code>, which will return the selected value of the <code>Either</code> if defined,
or throw <code>TestFailedException</code> if not.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides an implicit conversion that adds <code>left.value</code> and <code>right.value</code> methods
to <code>Either</code>, which will return the selected value of the <code>Either</code> if defined,
or throw <code>TestFailedException</code> if not.</p><p>This construct allows you to express in one statement that an <code>Either</code> should be <em>left</em> or <em>right</em>
and that its value should meet some expectation. Here's are some examples:</p><p><pre class="stHighlighted">
either1.right.value should be &gt; <span class="stLiteral">9</span>
either2.left.value should be (<span class="stQuotedString">"Muchas problemas"</span>)
</pre></p><p>Or, using assertions instead of matcher expressions:</p><p><pre class="stHighlighted">
assert(either1.right.value &gt; <span class="stLiteral">9</span>)
assert(either2.left.value === <span class="stQuotedString">"Muchas problemas"</span>)
</pre></p><p>Were you to simply invoke <code>right.get</code> or <code>left.get</code> on the <code>Either</code>,
if the <code>Either</code> wasn't defined as expected (<em>e.g.</em>, it was a <code>Left</code> when you expected a <code>Right</code>), it
would throw a <code>NoSuchElementException</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> either: <span class="stType">Either[String, Int]</span> = <span class="stType">Left</span>(<span class="stQuotedString">"Muchas problemas"</span>)
<br/>either.right.get should be &gt; <span class="stLiteral">9</span> <span class="stLineComment">// either.right.get throws NoSuchElementException</span>
</pre></p><p>The <code>NoSuchElementException</code> would cause the test to fail, but without providing a <a href="exceptions/StackDepth.html">stack depth</a> pointing
to the failing line of test code. This stack depth, provided by <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a> (and a
few other ScalaTest exceptions), makes it quicker for
users to navigate to the cause of the failure. Without <code>EitherValues</code>, to get
a stack depth exception you would need to make two statements, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> either: <span class="stType">Either[String, Int]</span> = <span class="stType">Left</span>(<span class="stQuotedString">"Muchas problemas"</span>)
<br/>either should be (<span class="stQuotedString">'right</span>) <span class="stLineComment">// throws TestFailedException</span>
either.right.get should be &gt; <span class="stLiteral">9</span>
</pre></p><p>The <code>EitherValues</code> trait allows you to state that more concisely:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> either: <span class="stType">Either[String, Int]</span> = <span class="stType">Left</span>(<span class="stQuotedString">"Muchas problemas"</span>)
<br/>either.right.value should be &gt; <span class="stLiteral">9</span> <span class="stLineComment">// either.right.value throws TestFailedException</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Entry" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Entry[K,V]extendsMap.Entry[K,V]withProductwithSerializable"></a><a id="Entry[K,V]:Entry[K,V]"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Entry[K,V]extendsMap.Entry[K,V]withProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="A case class implementation of java.util.Map.Entry to make it easier to test Java Maps with ScalaTest Matchers." href="Entry.html"><span class="name">Entry</span></a><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="org.scalatest.Entry.K">K</span></span>, <span name="value">value: <span class="extype" name="org.scalatest.Entry.V">V</span></span>)</span><span class="result"> extends <span class="extype" name="java.util.Map.Entry">java.util.Map.Entry</span>[<span class="extype" name="org.scalatest.Entry.K">K</span>, <span class="extype" name="org.scalatest.Entry.V">V</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">A case class implementation of <code>java.util.Map.Entry</code> to make it easier to
test Java <code>Map</code>s with ScalaTest <a href="Matchers.html">Matchers</a>.</p><div class="fullcomment"><div class="comment cmt"><p>A case class implementation of <code>java.util.Map.Entry</code> to make it easier to
test Java <code>Map</code>s with ScalaTest <a href="Matchers.html">Matchers</a>.</p><p>In Java, <code>java.util.Map</code> is not a subtype of <code>java.util.Collection</code>, and does not
actually define an element type. You can ask a Java <code>Map</code> for an &ldquo;entry set&rdquo;
via the <code>entrySet</code> method, which will return the <code>Map</code>'s key/value pairs
wrapped in a set of <code>java.util.Map.Entry</code>, but a <code>Map</code> is not actually
a collection of <code>Entry</code>. To make Java <code>Map</code>s easier to work with, however,
ScalaTest matchers allows you to treat a Java <code>Map</code> as a collection of <code>Entry</code>,
and defines this convenience implementation of <code>java.util.Map.Entry</code>.
Here's how you use it:</p><p><pre class="stHighlighted">
javaMap should contain (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>))
javaMap should contain oneOf (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>), <span class="stType">Entry</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>))
</pre>
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key of this entry</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value of this entry</p></dd></dl></div>
    </li><li name="org.scalatest.Exceptional" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ExceptionalextendsOutcome"></a><a id="Exceptional:Exceptional"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ExceptionalextendsOutcome" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Superclass for the two outcomes of running a test that contain an exception: Failed and Canceled." href="Exceptional.html"><span class="name">Exceptional</span></a><span class="result"> extends <a href="Outcome.html" class="extype" name="org.scalatest.Outcome">Outcome</a></span>
      </span>
      
      <p class="shortcomment cmt">Superclass for the two outcomes of running a test that contain an exception: <code>Failed</code> and <code>Canceled</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Superclass for the two outcomes of running a test that contain an exception: <code>Failed</code> and <code>Canceled</code>.</p><p>This class provides a <code>toOption</code> method that returns a <code>Some</code> wrapping the contained exception, and
an <code>isExceptional</code> field with the value <code>true</code>. It's companion object provides an extractor that
enables patterns that match a test that either failed or canceled, as in:</p><p><pre class="stHighlighted">
outcome <span class="stReserved">match</span> {
  <span class="stReserved">case</span> <span class="stType">Exceptional</span>(ex) =&gt; <span class="stLineComment">// handle failed or canceled case</span>
  <span class="stReserved">case</span> _ =&gt; <span class="stLineComment">// handle succeeded, pending, or omitted case</span>
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.Failed" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FailedextendsExceptionalwithProductwithSerializable"></a><a id="Failed:Failed"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FailedextendsExceptionalwithProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Outcome for a test that failed, containing an exception describing the cause of the failure." href="Failed.html"><span class="name">Failed</span></a><span class="params">(<span name="exception">exception: <span class="extype" name="scala.Throwable">Throwable</span></span>)</span><span class="result"> extends <a href="Exceptional.html" class="extype" name="org.scalatest.Exceptional">Exceptional</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Outcome for a test that failed, containing an exception describing the cause of the failure.</p><div class="fullcomment"><div class="comment cmt"><p>Outcome for a test that failed, containing an exception describing the cause of the failure.</p><p>Note: the difference between this <code>Failed</code> class and the similarly named <a href="FailedStatus$.html"><code>FailedStatus</code></a>
object is that an instance of this class indicates one test failed, whereas the <code>FailedStatus</code> object indicates either one or more tests failed
and/or one or more suites aborted during a run. Both are used as the result type of <code>Suite</code> lifecycle methods, but <code>Failed</code>
is a possible result of <code>withFixture</code>, whereas <code>FailedStatus</code> is a possible result of <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, or <code>runTest</code>. In short, <code>Failed</code> is always just about one test, whereas <code>FailedStatus</code> could be
about something larger: multiple tests or an entire suite.</p></div></div>
    </li><li name="org.scalatest.FeatureSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FeatureSpecextendsFeatureSpecLike"></a><a id="FeatureSpec:FeatureSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FeatureSpecextendsFeatureSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A suite of tests in which each test represents one scenario of a feature." href="FeatureSpec.html"><span class="name">FeatureSpec</span></a><span class="result"> extends <a href="FeatureSpecLike.html" class="extype" name="org.scalatest.FeatureSpecLike">FeatureSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">A suite of tests in which each test represents one <em>scenario</em> of a <em>feature</em>.</p><div class="fullcomment"><div class="comment cmt"><p>A suite of tests in which each test represents one <em>scenario</em> of a <em>feature</em>.
<code>FeatureSpec</code> is intended for writing tests that are &quot;higher level&quot; than unit tests, for example, integration
tests, functional tests, and acceptance tests. You can use <code>FeatureSpec</code> for unit testing if you prefer, however.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Class <code>FeatureSpec</code> is primarily intended for acceptance testing, including facilitating the process of programmers working alongside non-programmers to
define the acceptance requirements.
</td></tr></table></p><p>Although not required, <code>FeatureSpec</code> is often used together with <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> to express acceptance requirements
in more detail. Here's an example:</p><p><a name="initialExample"></a>
<pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">TVSet</span> {
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
  <span class="stReserved">def</span> isOn: <span class="stType">Boolean</span> = on
  <span class="stReserved">def</span> pressPowerButton() {
    on = !on
  }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  info(<span class="stQuotedString">"As a TV set owner"</span>)
  info(<span class="stQuotedString">"I want to be able to turn the TV on and off"</span>)
  info(<span class="stQuotedString">"So I can watch TV when I want"</span>)
  info(<span class="stQuotedString">"And save energy when I'm not watching TV"</span>)
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
    scenario(<span class="stQuotedString">"User presses power button when TV is off"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a TV set that is switched off"</span>)
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      assert(!tv.isOn)
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      tv.pressPowerButton()
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch on"</span>)
      assert(tv.isOn)
    }
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a TV set that is switched on"</span>)
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      tv.pressPowerButton()
      assert(tv.isOn)
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      tv.pressPowerButton()
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch off"</span>)
      assert(!tv.isOn)
    }
  }
}
</pre></p><p>Note: for more information on the calls to <code>Given</code>, <code>When</code>, and <code>Then</code>, see the documentation
for trait <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> and the <a href="#informers"><code>Informers</code> section</a> below.</p><p>A <code>FeatureSpec</code> contains <em>feature clauses</em> and <em>scenarios</em>. You define a feature clause
with <code>feature</code>, and a scenario with <code>scenario</code>. Both
<code>feature</code> and <code>scenario</code> are methods, defined in
<code>FeatureSpec</code>, which will be invoked
by the primary constructor of <code>TVSetSpec</code>.
A feature clause describes a feature of the <em>subject</em> (class or other entity) you are specifying
and testing. In the previous example,
the subject under specification and test is a TV set. The feature being specified and tested is
the behavior of a TV set when its power button is pressed. With each scenario you provide a
string (the <em>spec text</em>) that specifies the behavior of the subject for
one scenario in which the feature may be used, and a block of code that tests that behavior.
You place the spec text between the parentheses, followed by the test code between curly
braces.  The test code will be wrapped up as a function passed as a by-name parameter to
<code>scenario</code>, which will register the test for later execution.</p><p>A <code>FeatureSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Scenarios can only be registered with the <code>scenario</code> method while the <code>FeatureSpec</code> is
in its registration phase. Any attempt to register a scenario after the <code>FeatureSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>FeatureSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The recommended style
of using <code>FeatureSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p>Each scenario represents one test. The name of the test is the spec text passed to the <code>scenario</code> method.
The feature name does not appear as part of the test name. In a <code>FeatureSpec</code>, therefore, you must take care
to ensure that each test has a unique name (in other words, that each <code>scenario</code> has unique spec text).</p><p>When you run a <code>FeatureSpec</code>, it will send <a href="events/Formatter.html"><code>Formatter</code></a>s in the events it sends to the
<a href="Reporter.html"><code>Reporter</code></a>. ScalaTest's built-in reporters will report these events in such a way
that the output is easy to read as an informal specification of the <em>subject</em> being tested.
For example, were you to run <code>TVSetSpec</code> from within the Scala interpreter:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetSpec)
</pre></p><p>You would see:</p><p><pre class="stREPL">
<span class="stGreen">TVSetSpec:
As a TV set owner
I want to be able to turn the TV on and off
So I can watch TV when I want
And save energy when I'm not watching TV
Feature: TV power button
  Scenario: User presses power button when TV is off
    Given a TV set that is switched off
    When the power button is pressed
    Then the TV should switch on
  Scenario: User presses power button when TV is on
    Given a TV set that is switched on
    When the power button is pressed
    Then the TV should switch off</span>
</pre></p><p>Or, to run just the &ldquo;<code>Feature: TV power button Scenario: User presses power button when TV is on</code>&rdquo; method, you could pass that test's name, or any unique substring of the
name, such as <code>"TV is on"</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetSpec, "TV is on")
<span class="stGreen">TVSetSpec:
As a TV set owner
I want to be able to turn the TV on and off
So I can watch TV when I want
And save energy when I'm not watching TV
Feature: TV power button
  Scenario: User presses power button when TV is on
    Given a TV set that is switched on
    When the power button is pressed
    Then the TV should switch off</span>
</pre></p><p><em>Note: Trait <code>FeatureSpec</code>'s syntax is in part inspired by <a href="http://cukes.info/" target="_blank">Cucumber</a>, a Ruby BDD framework.</em></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>FeatureSpec</code> provides registration
methods that start with <code>ignore</code> instead of <code>scenario</code>. For example, to temporarily
disable the test named <code>addition</code>, just change &ldquo;<code>scenario</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.ignore
<br/><span class="stReserved">import</span> org.scalatest.FeatureSpec
<br/><span class="stReserved">class</span> <span class="stType">TVSet</span> {
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
  <span class="stReserved">def</span> isOn: <span class="stType">Boolean</span> = on
  <span class="stReserved">def</span> pressPowerButton() {
    on = !on
  }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
    ignore(<span class="stQuotedString">"User presses power button when TV is off"</span>) {
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      assert(!tv.isOn)
      tv.pressPowerButton()
      assert(tv.isOn)
    }
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>) {
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      tv.pressPowerButton()
      assert(tv.isOn)
      tv.pressPowerButton()
      assert(!tv.isOn)
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetSpec)
</pre></p><p>It will run only the second scenario and report that the first scenario was ignored:</p><p><pre class="stREPL">
<span class="stGreen">TVSetSpec:
Feature: TV power button</span>
  <span class="stYellow">Scenario: User presses power button when TV is off !!! IGNORED !!!</span>
  <span class="stGreen">Scenario: User presses power button when TV is on</span>
</pre></p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>FeatureSpec</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <a href="Reporter.html"><code>Reporter</code></a> as the suite runs.
Most often the default reporting done by <code>FeatureSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a scenario to the reporter. For example,
the <code>GivenWhenThen</code> trait provides methods that use the implicit <code>info</code> provided by <code>FeatureSpec</code>
to pass such information to the reporter. You can see this in action in the <a href="#initialExample">initial example</a> of this trait's documentation.</p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>FeatureSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FlatSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
     <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  feature(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
    scenario(<span class="stQuotedString">"When an element is added to an empty mutable Set"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/featureSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  feature(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
    scenario(<span class="stQuotedString">"When an element is added to an empty mutable Set"</span>) {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
Feature: An element can be added to an empty mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
  <span class="stGreen">Scenario: When an element is added to an empty mutable Set
    info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <a href="exceptions/TestPendingException.html"><code>TestPendingException</code></a>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented.
You can mark tests as pending in a <code>FeatureSpec</code> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.pending
<br/><span class="stReserved">import</span> org.scalatest.FeatureSpec
<br/><span class="stReserved">class</span> <span class="stType">TVSet</span> {
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
  <span class="stReserved">def</span> isOn: <span class="stType">Boolean</span> = on
  <span class="stReserved">def</span> pressPowerButton() {
    on = !on
  }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is off"</span>) (pending)
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>) {
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      tv.pressPowerButton()
      assert(tv.isOn)
      tv.pressPowerButton()
      assert(!tv.isOn)
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>TVSetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetSpec)
</pre></p><p>It will run both tests, but report that <code>When empty should have size 0</code> is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">TVSetSpec:
Feature: TV power button</span>
  <span class="stYellow">Scenario: User presses power button when TV is off (pending)</span>
  <span class="stGreen">Scenario: User presses power button when TV is on</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait. For example, the following snippet in a <code>FeatureSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.infopending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">TVSet</span> {
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
<br/>  <span class="stReserved">def</span> isOn: <span class="stType">Boolean</span> = on
<br/>  <span class="stReserved">def</span> pressPowerButton() {
    on = !on
  }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  info(<span class="stQuotedString">"As a TV set owner"</span>)
  info(<span class="stQuotedString">"I want to be able to turn the TV on and off"</span>)
  info(<span class="stQuotedString">"So I can watch TV when I want"</span>)
  info(<span class="stQuotedString">"And save energy when I'm not watching TV"</span>)
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
    scenario(<span class="stQuotedString">"User presses power button when TV is off"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"a TV that is switched off"</span>)
      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch on"</span>)
      pending
    }
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"a TV that is switched on"</span>)
      <span class="stType">When</span>(<span class="stQuotedString">"the power button is pressed"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"the TV should switch off"</span>)
      pending
    }
  }
}
</pre></p><p>Would yield the following output when run in the interpreter:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new TVSetSpec)
<span class="stGreen">TVSetSpec:
As a TV set owner
I want to be able to turn the TV on and off
So I can watch TV when I want
And save energy when I'm not watching TV
Feature: TV power button</span>
  <span class="stYellow">Scenario: User presses power button when TV is off (pending)
    Given a TV that is switched off
    When the power button is pressed
    Then the TV should switch on
  Scenario: User presses power button when TV is on (pending)
    Given a TV that is switched on
    When the power button is pressed
    Then the TV should switch off </span>
</pre></p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>FeatureSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>FeatureSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>FeatureSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>FeatureSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>FeatureSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FeatureSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">TVSet</span> {
  <span class="stReserved">private</span> <span class="stReserved">var</span> on: <span class="stType">Boolean</span> = <span class="stReserved">false</span>
  <span class="stReserved">def</span> isOn: <span class="stType">Boolean</span> = on
  <span class="stReserved">def</span> pressPowerButton() {
    on = !on
  }
}
<br/><span class="stReserved">class</span> <span class="stType">TVSetSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  feature(<span class="stQuotedString">"TV power button"</span>) {
    scenario(<span class="stQuotedString">"User presses power button when TV is off"</span>, <span class="stType">Slow</span>) {
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      assert(!tv.isOn)
      tv.pressPowerButton()
      assert(tv.isOn)
    }
<br/>    scenario(<span class="stQuotedString">"User presses power button when TV is on"</span>, <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
      <span class="stReserved">val</span> tv = <span class="stReserved">new</span> <span class="stType">TVSet</span>
      tv.pressPowerButton()
      assert(tv.isOn)
      tv.pressPowerButton()
      assert(!tv.isOn)
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>FeatureSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.FeatureSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"encourage clear code!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      assert(f.buffer.isEmpty)
      f.buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"be easy to reason about!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      assert(f.buffer.isEmpty)
    }
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FeatureSpec
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is designed to "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"designed"</span>, <span class="stQuotedString">"to"</span>)
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    <span class="stLineComment">// This test needs the StringBuilder fixture</span>
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      <span class="stReserved">new</span> <span class="stType">Builder</span> {
        builder.append(<span class="stQuotedString">"encourage clear code!"</span>)
        assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      }
    }
<br/>    <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      <span class="stReserved">new</span> <span class="stType">Buffer</span> {
        buffer += (<span class="stQuotedString">"be"</span>, <span class="stQuotedString">"easy"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"reason"</span>, <span class="stQuotedString">"about!"</span>)
        assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"designed"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"be"</span>, <span class="stQuotedString">"easy"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"reason"</span>, <span class="stQuotedString">"about!"</span>))
      }
    }
<br/>    <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
    scenario(<span class="stQuotedString">"User needs to write tests"</span>) {
      <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
        builder.append(<span class="stQuotedString">"be easy to learn!"</span>)
        buffer += (<span class="stQuotedString">"be"</span>, <span class="stQuotedString">"easy"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"remember"</span>, <span class="stQuotedString">"how"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"write!"</span>)
        assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to learn!"</span>)
        assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"designed"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"be"</span>, <span class="stQuotedString">"easy"</span>,
          <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"remember"</span>, <span class="stQuotedString">"how"</span>, <span class="stQuotedString">"to"</span>, <span class="stQuotedString">"write!"</span>))
      }
    }
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. That is to say, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  scenario(<span class="stQuotedString">"This scenario should succeed"</span>) {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
  }
<br/>  scenario(<span class="stQuotedString">"This scenario should fail"</span>) {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSpec)
<span class="stGreen">ExampleSpec:
Scenario: This scenario should succeed</span>
<span class="stRed">Scenario: This scenario should fail *** FAILED ***
  2 did not equal 3 (<console>:115)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.FeatureSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is designed to "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    <span class="stLineComment">// This test needs the file fixture</span>
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      withFile { (file, writer) =&gt;
        writer.write(<span class="stQuotedString">"encourage clear code!"</span>)
        writer.flush()
        assert(file.length === <span class="stLiteral">46</span>)
      }
    }
    <span class="stLineComment">// This test needs the database fixture</span>
    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      withDatabase { db =&gt;
        db.append(<span class="stQuotedString">"be easy to reason about!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      }
    }
    <span class="stLineComment">// This test needs both the file and the database</span>
    scenario(<span class="stQuotedString">"User needs to write tests"</span>) {
      withDatabase { db =&gt;
        withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          db.append(<span class="stQuotedString">"be easy to learn!"</span>)
          writer.write(<span class="stQuotedString">"be easy to remember how to write!"</span>)
          writer.flush()
          assert(db.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to learn!"</span>)
          assert(file.length === <span class="stLiteral">58</span>)
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p></pre>
<a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <a href="fixture/FeatureSpec.html"><code>fixture.FeatureSpec</code></a>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.FeatureSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FeatureSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is designed to be "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"encourage clear code!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">49</span>)
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"be easy to reason about!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">52</span>)
    }
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/FeatureSpec.html">documentation for <code>fixture.FeatureSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is designed to "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      builder.append(<span class="stQuotedString">"encourage clear code!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      builder.append(<span class="stQuotedString">"be easy to reason about!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      assert(buffer.isEmpty)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is designed to "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      builder.append(<span class="stQuotedString">"encourage clear code!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      builder.append(<span class="stQuotedString">"be easy to reason about!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"easy"</span>
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.featurespec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is designed to "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  feature(<span class="stQuotedString">"Simplicity"</span>) {
    scenario(<span class="stQuotedString">"User needs to read test code written by others"</span>) {
      builder.append(<span class="stQuotedString">"encourage clear code!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to encourage clear code!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
<br/>    scenario(<span class="stQuotedString">"User needs to understand what the tests are doing"</span>) {
      builder.append(<span class="stQuotedString">"be easy to reason about!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is designed to be easy to reason about!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"easy"</span>
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedScenarios"></a></p><h4> Shared scenarios </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in a <code>FeatureSpec</code>, you first place shared tests (<em>i.e.</em>, shared scenarios) in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>FeatureSpec</code> that uses them, so that the scenarios they contain will
be registered as scenarios in that <code>FeatureSpec</code>.
For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several scenarios that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same scenarios for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these scenarios out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>FeatureSpec</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared scenarios are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared scenarios inside the <code>FeatureSpec</code> that uses them. If they are shared
between different <code>FeatureSpec</code>s, however, you could also define them in a separate trait that is mixed into
each <code>FeatureSpec</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared scenarios for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FeatureSpec
<span class="stReserved">import</span> org.scalatest.GivenWhenThen
<span class="stReserved">import</span> org.scalatestexamples.helpers.Stack
<br/><span class="stReserved">trait</span> <span class="stType">FeatureSpecStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(createNonEmptyStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    scenario(<span class="stQuotedString">"empty is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a non-empty stack"</span>)
      <span class="stReserved">val</span> stack = createNonEmptyStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"empty is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"empty returns false"</span>)
      assert(!stack.empty)
    }
<br/>    scenario(<span class="stQuotedString">"peek is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a non-empty stack"</span>)
      <span class="stReserved">val</span> stack = createNonEmptyStack
      <span class="stReserved">val</span> size = stack.size
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"peek is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"peek returns the last item added"</span>)
      assert(stack.peek === lastItemAdded)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the size of the stack is the same as before"</span>)
      assert(stack.size === size)
    }
<br/>    scenario(<span class="stQuotedString">"pop is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a non-empty stack"</span>)
      <span class="stReserved">val</span> stack = createNonEmptyStack
      <span class="stReserved">val</span> size = stack.size
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"pop is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"pop returns the last item added"</span>)
      assert(stack.pop === lastItemAdded)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the size of the stack one less than before"</span>)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(createNonFullStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    scenario(<span class="stQuotedString">"full is invoked on this non-full stack: "</span> + createNonFullStack.toString) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a non-full stack"</span>)
      <span class="stReserved">val</span> stack = createNonFullStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"full is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"full returns false"</span>)
      assert(!stack.full)
    }
<br/>    scenario(<span class="stQuotedString">"push is invoked on this non-full stack: "</span> + createNonFullStack.toString) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"a non-full stack"</span>)
      <span class="stReserved">val</span> stack = createNonFullStack
      <span class="stReserved">val</span> size = stack.size
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"push is invoked on the stack"</span>)
      stack.push(<span class="stLiteral">7</span>)
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the size of the stack is one greater than before"</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the top of the stack contains the pushed value"</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>FeatureSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
scenariosFor(nonFullStack(stackWithOneItem))
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStack) <span class="stLineComment">// assuming lastValuePushed is also in scope inside nonEmptyStack</span>
scenariosFor(nonFullStack)
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FeatureSpec
<span class="stReserved">import</span> org.scalatest.GivenWhenThen
<span class="stReserved">import</span> org.scalatestexamples.helpers.Stack
<br/><span class="stReserved">class</span> <span class="stType">StackFeatureSpec</span> <span class="stReserved">extends</span> <span class="stType">FeatureSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> <span class="stReserved">with</span> <span class="stType">FeatureSpecStackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  feature(<span class="stQuotedString">"A Stack is pushed and popped"</span>) {
<br/>    scenario(<span class="stQuotedString">"empty is invoked on an empty stack"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an empty stack"</span>)
      <span class="stReserved">val</span> stack = emptyStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"empty is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"empty returns true"</span>)
      assert(stack.empty)
    }
<br/>    scenario(<span class="stQuotedString">"peek is invoked on an empty stack"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an empty stack"</span>)
      <span class="stReserved">val</span> stack = emptyStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"peek is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"peek throws IllegalStateException"</span>)
      assertThrows[<span class="stType">IllegalStateException</span>] {
        stack.peek
      }
    }
<br/>    scenario(<span class="stQuotedString">"pop is invoked on an empty stack"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an empty stack"</span>)
      <span class="stReserved">val</span> stack = emptyStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"pop is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"pop throws IllegalStateException"</span>)
      assertThrows[<span class="stType">IllegalStateException</span>] {
        emptyStack.pop
      }
    }
<br/>    scenariosFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
    scenariosFor(nonFullStack(stackWithOneItem))
<br/>    scenariosFor(nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed))
    scenariosFor(nonFullStack(stackWithOneItemLessThanCapacity))
<br/>    scenario(<span class="stQuotedString">"full is invoked on a full stack"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an full stack"</span>)
      <span class="stReserved">val</span> stack = fullStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"full is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"full returns true"</span>)
      assert(stack.full)
    }
<br/>    scenariosFor(nonEmptyStack(fullStack, lastValuePushed))
<br/>    scenario(<span class="stQuotedString">"push is invoked on a full stack"</span>) {
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an full stack"</span>)
      <span class="stReserved">val</span> stack = fullStack
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"push is invoked on the stack"</span>)
      <span class="stType">Then</span>(<span class="stQuotedString">"push throws IllegalStateException"</span>)
      assertThrows[<span class="stType">IllegalStateException</span>] {
        stack.push(<span class="stLiteral">10</span>)
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala> (new StackFeatureSpec).execute()
<span class="stGreen">Feature: A Stack is pushed and popped
  Scenario: empty is invoked on an empty stack
    Given an empty stack
    When empty is invoked on the stack
    Then empty returns true
  Scenario: peek is invoked on an empty stack
    Given an empty stack
    When peek is invoked on the stack
    Then peek throws IllegalStateException
  Scenario: pop is invoked on an empty stack
    Given an empty stack
    When pop is invoked on the stack
    Then pop throws IllegalStateException
  Scenario: empty is invoked on this non-empty stack: Stack(9)
    Given a non-empty stack
    When empty is invoked on the stack
    Then empty returns false
  Scenario: peek is invoked on this non-empty stack: Stack(9)
    Given a non-empty stack
    When peek is invoked on the stack
    Then peek returns the last item added
    And the size of the stack is the same as before
  Scenario: pop is invoked on this non-empty stack: Stack(9)
    Given a non-empty stack
    When pop is invoked on the stack
    Then pop returns the last item added
    And the size of the stack one less than before
  Scenario: full is invoked on this non-full stack: Stack(9)
    Given a non-full stack
    When full is invoked on the stack
    Then full returns false
  Scenario: push is invoked on this non-full stack: Stack(9)
    Given a non-full stack
    When push is invoked on the stack
    Then the size of the stack is one greater than before
    And the top of the stack contains the pushed value
  Scenario: empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
    Given a non-empty stack
    When empty is invoked on the stack
    Then empty returns false
  Scenario: peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
    Given a non-empty stack
    When peek is invoked on the stack
    Then peek returns the last item added
    And the size of the stack is the same as before
  Scenario: pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
    Given a non-empty stack
    When pop is invoked on the stack
    Then pop returns the last item added
    And the size of the stack one less than before
  Scenario: full is invoked on this non-full stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
    Given a non-full stack
    When full is invoked on the stack
    Then full returns false
  Scenario: push is invoked on this non-full stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
    Given a non-full stack
    When push is invoked on the stack
    Then the size of the stack is one greater than before
    And the top of the stack contains the pushed value
  Scenario: full is invoked on a full stack
    Given an full stack
    When full is invoked on the stack
    Then full returns true
  Scenario: empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
    Given a non-empty stack
    When empty is invoked on the stack
    Then empty returns false
  Scenario: peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
    Given a non-empty stack
    When peek is invoked on the stack
    Then peek returns the last item added
    And the size of the stack is the same as before
  Scenario: pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
    Given a non-empty stack
    When pop is invoked on the stack
    Then pop returns the last item added
    And the size of the stack one less than before
  Scenario: push is invoked on a full stack
    Given an full stack
    When push is invoked on the stack
    Then push throws IllegalStateException</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
Although in a <code>FeatureSpec</code>, the <code>feature</code> clause is a nesting construct analogous to
<code>FunSpec</code>'s <code>describe</code> clause, you many sometimes need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in a
<code>FeatureSpec</code>, you can pass in a prefix or suffix string to add to each test name. You can pass this string
the same way you pass any other data needed by the shared tests, or just call <code>toString</code> on the shared fixture object.
This is the approach taken by the previous <code>FeatureSpecStackBehaviors</code> example.</p><p>Given this <code>FeatureSpecStackBehaviors</code> trait, calling it with the <code>stackWithOneItem</code> fixture, like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
</pre></p><p>yields test names:</p><ul><li><code>empty is invoked on this non-empty stack: Stack(9)</code></li><li><code>peek is invoked on this non-empty stack: Stack(9)</code></li><li><code>pop is invoked on this non-empty stack: Stack(9)</code></li></ul><p>Whereas calling it with the <code>stackWithOneItemLessThanCapacity</code> fixture, like this:</p><p><pre class="stHighlighted">
scenariosFor(nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed))
</pre></p><p>yields different test names:</p><ul><li><code>empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li><li><code>peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li><li><code>pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li></ul></div></div>
    </li><li name="org.scalatest.FeatureSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FeatureSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="FeatureSpecLike:FeatureSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FeatureSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class FeatureSpec, which represents a suite of tests in which each test represents one scenario of a feature." href="FeatureSpecLike.html"><span class="name">FeatureSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>FeatureSpec</code>, which represents
a suite of tests in which each test represents one <em>scenario</em> of a
<em>feature</em>.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>FeatureSpec</code>, which represents
a suite of tests in which each test represents one <em>scenario</em> of a
<em>feature</em>.</p><p><a href="FeatureSpec.html"><code>FeatureSpec</code></a> is a class, not a
trait, to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>FeatureSpec</code> into some other class, you can use this
trait instead, because class <code>FeatureSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FeatureSpec.html">detailed
overview of <code>FeatureSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.Filter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FilterextendsSerializable"></a><a id="Filter:Filter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FilterextendsSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Filter whose apply method determines which of the passed tests to run and ignore based on tags to include and exclude passed as as class parameters." href="Filter.html"><span class="name">Filter</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Filter whose <code>apply</code> method determines which of the passed tests to run and ignore based on tags to include and exclude passed as
as class parameters.</p><div class="fullcomment"><div class="comment cmt"><p>Filter whose <code>apply</code> method determines which of the passed tests to run and ignore based on tags to include and exclude passed as
as class parameters.</p><p>This class handles the <code>org.scalatest.Ignore</code> tag specially, in that its <code>apply</code> method indicates which
tests should be ignored based on whether they are tagged with <code>org.scalatest.Ignore</code>. If
<code>"org.scalatest.Ignore"</code> is not passed in the <code>tagsToExclude</code> set, it will be implicitly added. However, if the
<code>tagsToInclude</code> option is defined, and the contained set does not include <code>"org.scalatest.Ignore"</code>, then only those tests
that are both tagged with <code>org.scalatest.Ignore</code> and at least one of the tags in the <code>tagsToInclude</code> set
will be included in the result of <code>apply</code> and marked as ignored (so long as the test is not also
marked with a tag other than <code>org.scalatest.Ignore</code> that is a member of the <code>tagsToExclude</code>
set. For example, if <code>SlowAsMolasses</code> is a member of the <code>tagsToInclude</code> set and a
test is tagged with both <code>org.scalatest.Ignore</code> and <code>SlowAsMolasses</code>, and
<code>SlowAsMolasses</code> appears in the <code>tagsToExclude</code> set, the
<code>SlowAsMolasses</code> tag will &quot;overpower&quot; the <code>org.scalatest.Ignore</code> tag, and the
test will be filtered out entirely rather than being ignored.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="IllegalArgumentException"><code>IllegalArgumentException</code></span> if <code>tagsToInclude</code> is defined, but contains an empty set</p></span><span class="cmt"><p><span class="extype" name="NullArgumentException"><code>NullArgumentException</code></span> if either <code>tagsToInclude</code> or <code>tagsToExclude</code> are null</p></span></dd></dl></div>
    </li><li name="org.scalatest.Finders" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FindersextendsAnnotation"></a><a id="Finders:Finders"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FindersextendsAnnotation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Annotation used to mark a trait or class as defining a testing style that has a org.scalatest.finders.Finder implementation, which IDEs and other tools can use to discover tests and scopes." href="Finders.html"><span class="name">Finders</span></a><span class="result"> extends <span class="extype" name="java.lang.annotation.Annotation">Annotation</span></span>
      </span>
      
      <p class="shortcomment cmt">Annotation used to mark a trait or class as defining a testing style that has a <code>org.scalatest.finders.Finder</code> implementation,
which IDEs and other tools can use to discover tests and scopes.</p><div class="fullcomment"><div class="comment cmt"><p>Annotation used to mark a trait or class as defining a testing style that has a <code>org.scalatest.finders.Finder</code> implementation,
which IDEs and other tools can use to discover tests and scopes.</p><p><em>Note: This is actually an annotation defined in Java, not a Scala trait. It must be defined in Java instead of Scala so it will be accessible
at runtime. It has been inserted into Scaladoc by pretending it is a trait.</em></p><p>This annotation is used to enable different styles of testing, including both native ScalaTest styles and custom user-created styles, to
have rich IDE support. The &quot;Finder API&quot; is released separately from ScalaTest proper, because it is only used by tools such as IDEs.</p></div></div>
    </li><li name="org.scalatest.FixtureContext" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FixtureContextextendsAssertion"></a><a id="FixtureContext:FixtureContext"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FixtureContextextendsAssertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Marker trait for fixture-context objects, that enables them to be used in testing styles that require type Assertion" href="FixtureContext.html"><span class="name">FixtureContext</span></a><span class="result"> extends <a href="compatible/Assertion.html" class="extype" name="org.scalatest.compatible.Assertion">scalatest.compatible.Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Marker trait for fixture-context objects, that enables them
to be used in testing styles that require type <code>Assertion</code></p><div class="fullcomment"><div class="comment cmt"><p>Marker trait for fixture-context objects, that enables them
to be used in testing styles that require type <code>Assertion</code></p><p>A fixture-context object is a way to share fixtures between different
tests that is most useful when different tests need different combinations
of fixture objects. The fixture-context object technique is only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture
objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix
together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects.
Here's an example <code>FlatSpec</code> in which fixture objects are partitioned
into two traits and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.FixtureContext
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">FixtureContext</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">FixtureContext</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  <span class="stLineComment">// This test needs the StringBuilder fixture</span>
  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be productive"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
    builder.append(<span class="stQuotedString">"productive!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
  }
<br/>  <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be readable"</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
    buffer += (<span class="stQuotedString">"readable!"</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
  }
<br/>  <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
  it should <span class="stQuotedString">"be clear and concise"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
    builder.append(<span class="stQuotedString">"clear!"</span>)
    buffer += (<span class="stQuotedString">"concise!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
  }
}
</pre></p><p>Extending <code>FixtureContext</code>, which extends trait <code>org.scalatest.compatible.Assertion</code> makes
it more convenient to use fixture-context objects in styles, such as async styles, that require test bodies
to have type <code>Assertion</code>.</p></div></div>
    </li><li name="org.scalatest.FlatSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FlatSpecextendsFlatSpecLike"></a><a id="FlatSpec:FlatSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FlatSpecextendsFlatSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="FlatSpec.html"><span class="name">FlatSpec</span></a><span class="result"> extends <a href="FlatSpecLike.html" class="extype" name="org.scalatest.FlatSpecLike">FlatSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Class <code>FlatSpec</code> is a good first step for teams wishing to move from xUnit to BDD, because its structure is flat like xUnit, so simple and familiar,
but the test names must be written in a specification style: &ldquo;X should Y,&rdquo; &ldquo;A must B,&rdquo; <em>etc.  </em>
</td></tr></table></p><p>Trait <code>FlatSpec</code> is so named because
your specification text and tests line up flat against the left-side indentation level, with no nesting needed.
Here's an example <code>FlatSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  behavior of <span class="stQuotedString">"An empty Set"</span>
<br/>  it should <span class="stQuotedString">"have size 0"</span> in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>Note: you can use <code>must</code> or <code>can</code> as well as <code>should</code> in a <code>FlatSpec</code>. For example, instead of
<code>it should "have</code>..., you could write <code>it must "have</code>... or <code>it can "have</code>....</p><p>Instead of using a <code>behavior of</code> clause, you can alternatively use a shorthand syntax in which you replace
the first <code>it</code> with the subject string, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>Running either of the two previous versions of <code>SetSpec</code> in the Scala interpreter would yield:</p><p><pre class="stREPL">
<span class="stGreen">An empty Set
- should have size 0
- should produce NoSuchElementException when head is invoked</span>
</pre></p><p>In a <code>FlatSpec</code> you write a one (or more) sentence specification for each bit of behavior you wish to
specify and test. Each specification sentence has a
&quot;subject,&quot; which is sometimes called the <em>system under test</em> (or SUT). The
subject is the entity being specified and tested and also serves as the subject of the sentences you write for each test.
Often you will want to write multiple tests for the same subject. In a <code>FlatSpec</code>, you name the subject once,
with a <code>behavior of</code> clause or its shorthand, then write tests for that subject with <code>it should</code>/<code>must</code>/<code>can "do something"</code> phrases.
Each <code>it</code> refers to the most recently declared subject. For example, the four tests shown in this snippet are all testing
a stack that contains one item:</p><p><pre class="stHighlighted">
behavior of <span class="stQuotedString">"A Stack (with one item)"</span>
<br/>it should <span class="stQuotedString">"be non-empty"</span> in {}
<br/>it should <span class="stQuotedString">"return the top item on peek"</span> in {}
<br/>it should <span class="stQuotedString">"not remove the top item on peek"</span> in {}
<br/>it should <span class="stQuotedString">"remove the top item on pop"</span> in {}
</pre></p><p>The same is true if the tests are written using the shorthand notation:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack (with one item)"</span> should <span class="stQuotedString">"be non-empty"</span> in {}
<br/>it should <span class="stQuotedString">"return the top item on peek"</span> in {}
<br/>it should <span class="stQuotedString">"not remove the top item on peek"</span> in {}
<br/>it should <span class="stQuotedString">"remove the top item on pop"</span> in {}
</pre></p><p>In a <code>FlatSpec</code>, therefore, to figure out what &quot;<code>it</code>&quot; means, you just scan vertically until you find the most
recent use of <code>behavior of</code> or the shorthand notation.</p><p>Because sometimes the subject could be plural, you can alternatively use <code>they</code> instead of <code>it</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"The combinators"</span> should <span class="stQuotedString">"be easy to learn"</span> in {}
<br/>they should <span class="stQuotedString">"be efficient"</span> in {}
<br/>they should <span class="stQuotedString">"do something cool"</span> in {}
</pre></p><p>A <code>FlatSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered while the <code>FlatSpec</code> is
in its registration phase. Any attempt to register a test after the <code>FlatSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>FlatSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The recommended style
of using <code>FlatSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>FlatSpec</code> provides a method
<code>ignore</code> that can be used instead of <code>it</code> or <code>they</code> to register a test. For example, to temporarily
disable the test with the name <code>"An empty Set should produce NoSuchElementException when head is invoked"</code>, just
change &ldquo;<code>it</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  ignore should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the first test and report that the second test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">An empty Set</span>
<span class="stGreen">- should have size 0</span>
<span class="stYellow">- should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>When using shorthand notation, you won't have an <code>it</code> to change into <code>ignore</code> for
the first test of each new subject. To ignore such tests, you must instead change <code>in</code> to <code>ignore</code>.
For example, to temporarily disable the test with the name <code>"An empty Set should have size 0"</code>,
change &ldquo;<code>in</code>&rdquo; into &#8220;<code>ignore</code>&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.ignoreafter
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> ignore {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>If you run this version of <code>StackSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">An empty Set</span>
<span class="stYellow">- should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">- should produce NoSuchElementException when head is invoked</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest._
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
An empty Set</span>
<span class="stYellow">- should have size 0 !!! IGNORED !!!
- should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>FlatSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>FlatSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>FlatSpec</code>
to pass such information to the reporter.  Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
  }
}
</pre></p><p>If you run this <code>FlatSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>FlatSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FlatSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/flatSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
<br/>    info(<span class="stQuotedString">"info is recorded"</span>)
    markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
    note(<span class="stQuotedString">"notes are sent immediately"</span>)
    alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
    set += <span class="stQuotedString">"clarity"</span>
    assert(set.size === <span class="stLiteral">1</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <a href="exceptions/TestPendingException.html"><code>TestPendingException</code></a>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality it is intended to test, has not yet been implemented.
You can mark tests as pending in <code>FlatSpec</code> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.pending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> in (pending)
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>If you run this version of <code>FlatSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run both tests but report that <code>An empty Set should have size 0</code> is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">An empty Set</span>
<span class="stYellow">- should have size 0 (pending)</span>
<span class="stGreen">- should produce NoSuchElementException when head is invoked</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait. For example, the following snippet in a <code>FlatSpec</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"The Scala language"</span> must <span class="stQuotedString">"add correctly"</span> in {
   <span class="stType">Given</span>(<span class="stQuotedString">"two integers"</span>)
   <span class="stType">When</span>(<span class="stQuotedString">"they are added"</span>)
   <span class="stType">Then</span>(<span class="stQuotedString">"the result is the sum of the two numbers"</span>)
   pending
 }
 <span class="stLineComment">// ...</span>
</pre></p><p>Would yield the following output when run in the interpreter:</p><p><pre class="stREPL">
<span class="stGreen">The Scala language</span>
<span class="stYellow">- must add correctly (pending)
  + Given two integers
  + When they are added
  + Then the result is the sum of the two numbers</span>
</pre></p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>FlatSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>FlatSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>FlatSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>FlatSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>FlatSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  behavior of <span class="stQuotedString">"An empty Set"</span>
<br/>  it should <span class="stQuotedString">"have size 0"</span> taggedAs(<span class="stType">Slow</span>) in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  it should <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <a href="Filter.html"><code>Filter</code></a>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>FlatSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(f.buffer.isEmpty)
    f.buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(f.buffer.isEmpty)
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FlatSpec
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  <span class="stLineComment">// This test needs the StringBuilder fixture</span>
  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be productive"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
    builder.append(<span class="stQuotedString">"productive!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
  }
<br/>  <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be readable"</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
    buffer += (<span class="stQuotedString">"readable!"</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
  }
<br/>  <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
  it should <span class="stQuotedString">"be clear and concise"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
    builder.append(<span class="stQuotedString">"clear!"</span>)
    buffer += (<span class="stQuotedString">"concise!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. That is to say, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  <span class="stQuotedString">"This test"</span> should <span class="stQuotedString">"succeed"</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
  }
<br/>  it should <span class="stQuotedString">"fail"</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes <a href="TestData.html" class="extype" name="org.scalatest.TestData"><code>TestData</code></a> such as the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stLineComment">// This test needs the file fixture</span>
  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be productive"</span> in withFile { (file, writer) =&gt;
    writer.write(<span class="stQuotedString">"productive!"</span>)
    writer.flush()
    assert(file.length === <span class="stLiteral">24</span>)
  }
<br/>  <span class="stLineComment">// This test needs the database fixture</span>
  <span class="stQuotedString">"Test code"</span> should <span class="stQuotedString">"be readable"</span> in withDatabase { db =&gt;
    db.append(<span class="stQuotedString">"readable!"</span>)
    assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
  }
<br/>  <span class="stLineComment">// This test needs both the file and the database</span>
  it should <span class="stQuotedString">"be clear and concise"</span> in withDatabase { db =&gt;
    withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
      db.append(<span class="stQuotedString">"clear!"</span>)
      writer.write(<span class="stQuotedString">"concise!"</span>)
      writer.flush()
      assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
      assert(file.length === <span class="stLiteral">21</span>)
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.FlatSpec</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.FlatSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">"easy!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">"fun!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/FlatSpec.html">documentation for <code>fixture.FlatSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should <span class="stQuotedString">"be easy"</span> in {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  it should <span class="stQuotedString">"be fun"</span> in {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.  To accomplish this in a <code>FlatSpec</code>, you first place shared tests in <em>behavior functions</em>.
These behavior functions will be invoked during the construction phase of any <code>FlatSpec</code> that uses them, so that the tests they
contain will be registered as tests in that <code>FlatSpec</code>.  For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>FlatSpec</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures. You
can define a behavior function that encapsulates these shared tests inside the <code>FlatSpec</code> that uses them. If they are shared
between different <code>FlatSpec</code>s, however, you could also define them in a separate trait that is mixed into each <code>FlatSpec</code>
that uses them.</p><p><a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a behavior <em>method</em>) is
defined in a trait along with another method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">StackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">FlatSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(newStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    it should <span class="stQuotedString">"be non-empty"</span> in {
      assert(!newStack.empty)
    }
<br/>    it should <span class="stQuotedString">"return the top item on peek"</span> in {
      assert(newStack.peek === lastItemAdded)
    }
<br/>    it should <span class="stQuotedString">"not remove the top item on peek"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.peek === lastItemAdded)
      assert(stack.size === size)
    }
<br/>    it should <span class="stQuotedString">"remove the top item on pop"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.pop === lastItemAdded)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(newStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    it should <span class="stQuotedString">"not be full"</span> in {
      assert(!newStack.full)
    }
<br/>    it should <span class="stQuotedString">"add to the top on push"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      stack.push(<span class="stLiteral">7</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>FlatSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
it should behave like nonFullStack(stackWithOneItem)
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStack <span class="stLineComment">// assuming lastValuePushed is also in scope inside nonEmptyStack</span>
it should behave like nonFullStack
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">SharedTestExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">StackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  <span class="stQuotedString">"A Stack (when empty)"</span> should <span class="stQuotedString">"be empty"</span> in {
    assert(emptyStack.empty)
  }
<br/>  it should <span class="stQuotedString">"complain on peek"</span> in {
    assertThrows[<span class="stType">IllegalStateException</span>] {
      emptyStack.peek
    }
  }
<br/>  it should <span class="stQuotedString">"complain on pop"</span> in {
    assertThrows[<span class="stType">IllegalStateException</span>] {
      emptyStack.pop
    }
  }
<br/>  <span class="stQuotedString">"A Stack (with one item)"</span> should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
<br/>  it should behave like nonFullStack(stackWithOneItem)
<br/>  <span class="stQuotedString">"A Stack (with one item less than capacity)"</span> should behave like nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed)
<br/>  it should behave like nonFullStack(stackWithOneItemLessThanCapacity)
<br/>  <span class="stQuotedString">"A Stack (full)"</span> should <span class="stQuotedString">"be full"</span> in {
    assert(fullStack.full)
  }
<br/>  it should behave like nonEmptyStack(fullStack, lastValuePushed)
<br/>  it should <span class="stQuotedString">"complain on a push"</span> in {
    assertThrows[<span class="stType">IllegalStateException</span>] {
      fullStack.push(<span class="stLiteral">10</span>)
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SharedTestExampleSpec)
<span class="stGreen">A Stack (when empty)
- should be empty
- should complain on peek
- should complain on pop
A Stack (with one item)
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should not be full
- should add to the top on push
A Stack (with one item less than capacity)
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should not be full
- should add to the top on push
A Stack (full)
- should be full
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should complain on a push</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name. A good way to solve this problem in a <code>FlatSpec</code> is to make sure
each invocation of a behavior function is in the context of a different set of <code>when</code>, <em>verb</em> (<code>should</code>,
<code>must</code>, or </code>can</code>), and <code>that</code> clauses,
which will prepend a string to each test name.
For example, the following code in a <code>FlatSpec</code> would register a test with the name <code>"A Stack (when empty) should be empty"</code>:</p><p><pre class="stHighlighted">
behavior of <span class="stQuotedString">"A Stack (when empty)"</span>
<br/>it should <span class="stQuotedString">"be empty"</span> in {
  assert(emptyStack.empty)
}
<span class="stLineComment">// ...</span>
</pre></p><p>Or, using the shorthand notation:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> when {
  <span class="stQuotedString">"empty"</span> should {
    <span class="stQuotedString">"be empty"</span> in {
      assert(emptyStack.empty)
    }
  }
}
<span class="stLineComment">// ...</span>
</pre></p><p>If the <code>"should be empty"</code> test was factored out into a behavior function, it could be called repeatedly so long
as each invocation of the behavior function is in the context of a different combination
of <code>when</code>, <em>verb</em>, and <code>that</code> clauses.</p></div></div>
    </li><li name="org.scalatest.FlatSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FlatSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="FlatSpecLike:FlatSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FlatSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class FlatSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="FlatSpecLike.html"><span class="name">FlatSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>FlatSpec</code>, which facilitates a
&ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>FlatSpec</code>, which facilitates a
&ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><a href="FlatSpec.html"><code>FlatSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>FlatSpec</code> into some other class, you can use this
trait instead, because class <code>FlatSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FlatSpec.html">detailed
overview of <code>FlatSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.FreeSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecextendsFreeSpecLike"></a><a id="FreeSpec:FreeSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FreeSpecextendsFreeSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)." href="FreeSpec.html"><span class="name">FreeSpec</span></a><span class="result"> extends <a href="FreeSpecLike.html" class="extype" name="org.scalatest.FreeSpecLike">FreeSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are nested inside text clauses denoted with the dash operator (<code>-</code>).</p><div class="fullcomment"><div class="comment cmt"><p>Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are nested inside text clauses denoted with the dash operator (<code>-</code>).</p><p><code>FreeSpec</code> is so named because unlike classes such as <code>WordSpec</code>, <code>FlatSpec</code>, and <code>FunSpec</code>,
it is enforces no structure on the text. You are free to compose text however you like. (A <code>FreeSpec</code> is like free-verse poetry as
opposed to a sonnet or haiku, which defines a structure for the text of the poem.)</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Because it gives absolute freedom (and no guidance) on how specification text should be written, <code>FreeSpec</code> is a good choice for teams experienced
with BDD and able to agree on how to structure the specification text.
</td></tr></table></p><p>Here's an example <code>FreeSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>In a <code>FreeSpec</code> you write a test with a string followed by <code>in</code> and the body of the
test in curly braces, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"should have size 0"</span> in {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can nest a test inside any number of description clauses, which you write with a string followed by a dash character
and a block, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Set"</span> - {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can nest description clauses as deeply as you want. Because the description clause is denoted with an operator, not
a word like <code>should</code>, you are free to structure the text however you wish. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
  <span class="stQuotedString">"A Stack"</span> - {
    <span class="stQuotedString">"whenever it is empty"</span> - {
      <span class="stQuotedString">"certainly ought to"</span> - {
        <span class="stQuotedString">"be empty"</span> in {
          <span class="stLineComment">// ...</span>
        }
        <span class="stQuotedString">"complain on peek"</span> in {
          <span class="stLineComment">// ...</span>
        }
        <span class="stQuotedString">"complain on pop"</span> in {
          <span class="stLineComment">// ...</span>
        }
      }
    }
    <span class="stQuotedString">"but when full, by contrast, must"</span> - {
      <span class="stQuotedString">"be full"</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"complain on push"</span> in {
        <span class="stLineComment">// ...</span>
      }
    }
  }
}
</pre></p><p>Running the above <code>StackSpec</code> in the interpreter would yield:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack
  whenever it is empty
    certainly ought to
&nbsp;   - be empty
&nbsp;   - complain on peek
&nbsp;   - complain on pop
&nbsp; but when full, by contrast, must
&nbsp; - be full
&nbsp; - complain on push</span>
</pre></p><p>A <code>FreeSpec</code> can also be used to write a specification-style test in languages other than English. For
example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">ComputerRoomRulesSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
  <span class="stQuotedString">"Achtung!"</span> - {
    <span class="stQuotedString">"Alle touristen und non-technischen lookenpeepers!"</span> - {
      <span class="stQuotedString">"Das machine is nicht fuer fingerpoken und mittengrabben."</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"Is easy"</span> - {
        <span class="stQuotedString">"schnappen der springenwerk"</span> in {
          <span class="stLineComment">// ...</span>
        }
        <span class="stQuotedString">"blowenfusen"</span> in {
          <span class="stLineComment">// ...</span>
        }
        <span class="stQuotedString">"und poppencorken mit spitzen sparken."</span> in {
          <span class="stLineComment">// ...</span>
        }
      }
      <span class="stQuotedString">"Das machine is diggen by experten only."</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"Is nicht fuer gerwerken by das dummkopfen."</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"Das rubbernecken sightseeren keepen das cottenpicken hands in das pockets."</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"Relaxen und watchen das blinkenlights."</span> in {
        <span class="stLineComment">// ...</span>
      }
    }
  }
}
</pre></p><p>Running the above <code>ComputerRoomRulesSpec</code> in the interpreter would yield:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ComputerRoomRulesSpec)
<span class="stGreen">ComputerRoomRulesSpec:
Achtung!
  Alle touristen und non-technischen lookenpeepers!
&nbsp; - Das machine is nicht fuer fingerpoken und mittengrabben.
&nbsp;   Is easy
&nbsp;   - schnappen der springenwerk
&nbsp;   - blowenfusen
&nbsp;   - und poppencorken mit spitzen sparken.
&nbsp; - Das machine is diggen by experten only.
&nbsp; - Is nicht fuer gerwerken by das dummkopfen.
&nbsp; - Das rubbernecken sightseeren keepen das cottenpicken hands in das pockets.
&nbsp; - Relaxen und watchen das blinkenlights.</span>
</pre></p><p>A <code>FreeSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered while the <code>FreeSpec</code> is
in its registration phase. Any attempt to register a test after the <code>FreeSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>FreeSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The recommended style
of using <code>FreeSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>FreeSpec</code> adds a method
<code>ignore</code> to strings that can be used instead of <code>in</code> to register a test. For example, to temporarily
disable the test with the name <code>"A Stack should pop values in last-in-first-out order"</code>, just
change &ldquo;<code>in</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.ignore
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> ignore {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A Set
  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stYellow">  - should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>FreeSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>FreeSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>FreeSpec</code>
to pass such information to the reporter. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
    }
  }
}
</pre></p><p>If you run this <code>FreeSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>FreeSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FreeSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/freeSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> - {
    <span class="stQuotedString">"should allow an element to be added"</span> in {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
 A mutable Set
   + notes are sent immediately</span>
   <span class="stYellow">+ alerts are also sent immediately</span>
 <span class="stGreen">- should allow an element to be added
   + info is recorded
   + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <a href="exceptions/TestPendingException.html"><code>TestPendingException</code></a>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality it is intended to test, has not yet been implemented.
You can mark tests as pending in a <code>FreeSpec</code> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.pending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> in (pending)
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run both tests but report that <code>should have size 0</code> is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 (pending)</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait. For example, the following snippet in a <code>FreeSpec</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"The Scala language"</span> - {
   <span class="stQuotedString">"should add correctly"</span> in {
     <span class="stType">Given</span>(<span class="stQuotedString">"two integers"</span>)
     <span class="stType">When</span>(<span class="stQuotedString">"they are added"</span>)
     <span class="stType">Then</span>(<span class="stQuotedString">"the result is the sum of the two numbers"</span>)
     pending
   }
   <span class="stLineComment">// ...</span>
</pre></p><p>Would yield the following output when run in the interpreter:</p><p><pre class="stREPL">
<span class="stGreen">The Scala language</span>
<span class="stYellow">- should add correctly (pending)
  + Given two integers
  + When they are added
  + Then the result is the sum of the two numbers</span>
</pre></p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>FreeSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>FreeSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>FreeSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>FreeSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could tag <code>FreeSpec</code> tests like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> taggedAs(<span class="stType">Slow</span>) in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <a href="Filter.html"><code>Filter</code></a>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>FreeSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or an holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(f.buffer.isEmpty)
      f.buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(f.buffer.isEmpty)
    }
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stLineComment">// This test needs the StringBuilder fixture</span>
    <span class="stQuotedString">"should be productive"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
      builder.append(<span class="stQuotedString">"productive!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> - {
    <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
    <span class="stQuotedString">"should be readable"</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
      buffer += (<span class="stQuotedString">"readable!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
    }
<br/>    <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
    <span class="stQuotedString">"should be clear and concise"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
      builder.append(<span class="stQuotedString">"clear!"</span>)
      buffer += (<span class="stQuotedString">"concise!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
    }
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  <span class="stQuotedString">"This test"</span> - {
    <span class="stQuotedString">"should succeed"</span> in {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
    }
<br/>    <span class="stQuotedString">"should fail"</span> in {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stLineComment">// This test needs the file fixture</span>
    <span class="stQuotedString">"should be productive"</span> in withFile { (file, writer) =&gt;
      writer.write(<span class="stQuotedString">"productive!"</span>)
      writer.flush()
      assert(file.length === <span class="stLiteral">24</span>)
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> - {
    <span class="stLineComment">// This test needs the database fixture</span>
    <span class="stQuotedString">"should be readable"</span> in withDatabase { db =&gt;
      db.append(<span class="stQuotedString">"readable!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
    }
<br/>    <span class="stLineComment">// This test needs both the file and the database</span>
    <span class="stQuotedString">"should be clear and concise"</span> in withDatabase { db =&gt;
      withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
        db.append(<span class="stQuotedString">"clear!"</span>)
        writer.write(<span class="stQuotedString">"concise!"</span>)
        writer.flush()
        assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
        assert(file.length === <span class="stLiteral">21</span>)
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.FreeSpec</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.FreeSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FreeSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/FreeSpec.html">documentation for <code>fixture.FreeSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> - {
    <span class="stQuotedString">"should be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"should be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.  To accomplish this in a <code>FreeSpec</code>, you first place shared tests in <em>behavior functions</em>.
These behavior functions will be invoked during the construction phase of any <code>FreeSpec</code> that uses them, so that the tests they
contain will be registered as tests in that <code>FreeSpec</code>.  For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>FreeSpec</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures. You
can define a behavior function that encapsulates these shared tests inside the <code>FreeSpec</code> that uses them. If they are shared
between different <code>FreeSpec</code>s, however, you could also define them in a separate trait that is mixed into each <code>FreeSpec</code>
that uses them.</p><p><a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a behavior <em>method</em>) is
defined in a trait along with another method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">StackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">FreeSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(newStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    <span class="stQuotedString">"be non-empty"</span> in {
      assert(!newStack.empty)
    }
<br/>    <span class="stQuotedString">"return the top item on peek"</span> in {
      assert(newStack.peek === lastItemAdded)
    }
<br/>    <span class="stQuotedString">"not remove the top item on peek"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.peek === lastItemAdded)
      assert(stack.size === size)
    }
<br/>    <span class="stQuotedString">"remove the top item on pop"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.pop === lastItemAdded)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(newStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    <span class="stQuotedString">"not be full"</span> in {
      assert(!newStack.full)
    }
<br/>    <span class="stQuotedString">"add to the top on push"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      stack.push(<span class="stLiteral">7</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>FreeSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre>
behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
behave like nonFullStack(stackWithOneItem)
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre>
behave like nonEmptyStack // assuming lastValuePushed is also in scope inside nonEmptyStack
behave like nonFullStack
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">SharedTestExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> <span class="stReserved">with</span> <span class="stType">StackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  <span class="stQuotedString">"A Stack"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should be empty"</span> in {
        assert(emptyStack.empty)
      }
<br/>      <span class="stQuotedString">"should complain on peek"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.peek
        }
      }
<br/>      <span class="stQuotedString">"should complain on pop"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.pop
        }
      }
    }
<br/>    <span class="stQuotedString">"when it contains one item"</span> - {
      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
        behave like nonFullStack(stackWithOneItem)
      }
    }
<br/>    <span class="stQuotedString">"when it contains one item less than capacity"</span> - {
      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed)
        behave like nonFullStack(stackWithOneItemLessThanCapacity)
      }
    }
<br/>    <span class="stQuotedString">"when full"</span> - {
      <span class="stQuotedString">"should be full"</span> in {
        assert(fullStack.full)
      }
<br/>      <span class="stQuotedString">"should"</span> - {
        behave like nonEmptyStack(fullStack, lastValuePushed)
      }
<br/>      <span class="stQuotedString">"should complain on a push"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          fullStack.push(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SharedTestExampleSpec)
<span class="stGreen">SharedTestExampleSpec:
A Stack
  when empty
&nbsp; - should be empty
&nbsp; - should complain on peek
&nbsp; - should complain on pop
&nbsp; when it contains one item
&nbsp;   should
&nbsp;   - be non-empty
&nbsp;   - return the top item on peek
&nbsp;   - not remove the top item on peek
&nbsp;   - remove the top item on pop
&nbsp;   - not be full
&nbsp;   - add to the top on push
&nbsp; when it contains one item less than capacity
&nbsp;   should
&nbsp;   - be non-empty
&nbsp;   - return the top item on peek
&nbsp;   - not remove the top item on peek
&nbsp;   - remove the top item on pop
&nbsp;   - not be full
&nbsp;   - add to the top on push
&nbsp; when full
&nbsp; - should be full
&nbsp;   should
&nbsp;   - be non-empty
&nbsp;   - return the top item on peek
&nbsp;   - not remove the top item on peek
&nbsp;   - remove the top item on pop
&nbsp; - should complain on a push</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name. A good way to solve this problem in a <code>FreeSpec</code> is to make sure
each test is in the context of different surrounding description clauses,
because a test's name is the concatenation of its surrounding clauses, followed by the test's text.
For example, the following code in a <code>FreeSpec</code> would register a test with the name <code>"A Stack when empty should be empty"</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> - {
  <span class="stQuotedString">"when empty"</span> - {
    <span class="stQuotedString">"should be empty"</span> in {
      assert(emptyStack.empty)
    }
  }
}
<span class="stLineComment">// ...</span>
</pre></p><p>If the <code>"should be empty"</code> test was factored out into a behavior function, it could be called repeatedly so long
as each invocation of the behavior function is in the context of a different surrounding description (dash) clauses.</p></div></div>
    </li><li name="org.scalatest.FreeSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FreeSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="FreeSpecLike:FreeSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FreeSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class FreeSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are nested inside text clauses denoted with the dash operator (-)." href="FreeSpecLike.html"><span class="name">FreeSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>FreeSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are nested inside text clauses denoted with the dash
operator (<code>-</code>).</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>FreeSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are nested inside text clauses denoted with the dash
operator (<code>-</code>).</p><p><a href="FreeSpec.html"><code>FreeSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>FreeSpec</code> into some other class, you can use this
trait instead, because class <code>FreeSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FreeSpec.html">detailed
overview of <code>FreeSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.FunSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FunSpecextendsFunSpecLike"></a><a id="FunSpec:FunSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FunSpecextendsFunSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="FunSpec.html"><span class="name">FunSpec</span></a><span class="result"> extends <a href="FunSpecLike.html" class="extype" name="org.scalatest.FunSpecLike">FunSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
For teams coming from Ruby's RSpec tool, <code>FunSpec</code> will feel familiar and comfortable; More generally, for any team that prefers BDD, <code>FunSpec</code>'s nesting
and gentle guide to structuring text (with <code>describe</code> and <code>it</code>) provide an excellent general-purpose choice for writing specification-style tests.
</td></tr></table></p><p>Here's an example <code>FunSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A Set"</span>) {
    describe(<span class="stQuotedString">"when empty"</span>) {
      it(<span class="stQuotedString">"should have size 0"</span>) {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      it(<span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span>) {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>A <code>FunSpec</code> contains <em>describe clauses</em> and tests. You define a describe clause
with <code>describe</code>, and a test with either <code>it</code> or <code>they</code>.
<code>describe</code>,  <code>it</code>, and <code>they</code> are methods, defined in
<code>FunSpec</code>, which will be invoked
by the primary constructor of <code>SetSpec</code>.
A describe clause names, or gives more information about, the <em>subject</em> (class or other entity) you are specifying
and testing. In the previous example, <code>"A Set"</code>
is the subject under specification and test. With each test you provide a string (the <em>spec text</em>) that specifies
one bit of behavior of the subject, and a block of code that tests that behavior.
You place the spec text between the parentheses, followed by the test code between curly
braces.  The test code will be wrapped up as a function passed as a by-name parameter to
<code>it</code> (or <code>they</code>), which will register the test for later execution.</p><p>Note: the <code>they</code> method is intended for use when the subject is plural, for example:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"The combinators"</span>) {
  they(<span class="stQuotedString">"should be easy to learn"</span>) {}
  they(<span class="stQuotedString">"should be efficient"</span>) {}
  they(<span class="stQuotedString">"should do something cool"</span>) {}
}
</pre></p><p>A <code>FunSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>it</code> or <code>they</code> methods while the <code>FunSpec</code> is
in its registration phase. Any attempt to register a test after the <code>FunSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>FunSpec</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>FunSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p>When you execute a <code>FunSpec</code>, it will send <code>Formatter</code>s in the events it sends to the
<code>Reporter</code>. ScalaTest's built-in reporters will report these events in such a way
that the output is easy to read as an informal specification of the <em>subject</em> being tested.
For example, were you to run <code>SetSpec</code> from within the Scala interpreter:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>You would see:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stGreen">  - should have size 0</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p>Or, to run just the &ldquo;<code>A Set when empty should have size 0</code>&rdquo; test, you could pass that test's name, or any unique substring of the
name, such as <code>"size 0"</code> or even just <code>"0"</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite, "size 0")
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stGreen">  - should have size 0</span>
</pre></p><p>You can also pass to <code>execute</code> a <a href="ConfigMap.html"><em>config map</em></a> of key-value
pairs, which will be passed down into suites and tests, as well as other parameters that configure the run itself.
For more information on running in the Scala interpreter, see the documentation for <code>execute</code> (below) and the
<a href="Shell.html">ScalaTest shell</a>.</p><p>The <code>execute</code> method invokes a <code>run</code> method that takes two
parameters. This <code>run</code> method, which actually executes the suite, will usually be invoked by a test runner, such
as <a href="run$.html"><code>run</code></a>, <a href="tools/Runner$.html"><code>tools.Runner</code></a>, a build tool, or an IDE.</p><p><em>Note: <code>FunSpec</code>'s syntax is in great part inspired by <a href="http://rspec.info/" target="_blank">RSpec</a>, a Ruby BDD framework.</em></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>FunSpec</code> provides registration
methods that start with <code>ignore</code> instead of <code>it</code> or <code>they</code>. For example, to temporarily
disable the test with the text <code>"should have size 0"</code>, just change &ldquo;<code>it</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A Set"</span>) {
    describe(<span class="stQuotedString">"when empty"</span>) {
      ignore(<span class="stQuotedString">"should have size 0"</span>) {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      it(<span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span>) {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A Set"</span>) {
    describe(<span class="stQuotedString">"when empty"</span>) {
      it(<span class="stQuotedString">"should have size 0"</span>) {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      it(<span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span>) {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A Set
  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stYellow">  - should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>FunSpec</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>FunSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <code>Informer</code> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via one of its <code>apply</code> methods.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <code>InfoProvided</code> event.
Here's an example in which the <code>Informer</code> returned by <code>info</code> is used implicitly by the
<code>Given</code>, <code>When</code>, and <code>Then</code> methods of trait <code>GivenWhenThen</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
    }
  }
}
</pre></p><p>If you run this <code>FunSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>FunSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FunSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/funSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A mutable Set"</span>) {
    it(<span class="stQuotedString">"should allow an element to be added"</span>) {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented.</p><p>You can mark a test as pending in <code>FunSpec</code> by placing &quot;<code>(pending)</code>&quot; after the
test name, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.pending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A Set"</span>) {
    describe(<span class="stQuotedString">"when empty"</span>) {
      it(<span class="stQuotedString">"should have size 0"</span>) (pending)
<br/>      it(<span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span>) {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run both tests, but report that the test named &quot;<code>should have size 0</code>&quot; is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 (pending)</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>FunSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>FunSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>FunSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>FunSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>FunSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  describe(<span class="stQuotedString">"A Set"</span>) {
    describe(<span class="stQuotedString">"when empty"</span>) {
      it(<span class="stQuotedString">"should have size 0"</span>, <span class="stType">Slow</span>) {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      it(<span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span>, <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>FunSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or an holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(f.buffer.isEmpty)
      f.buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(f.buffer.isEmpty)
    }
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FunSpec
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    <span class="stLineComment">// This test needs the StringBuilder fixture</span>
    it(<span class="stQuotedString">"should be productive"</span>) {
      <span class="stReserved">new</span> <span class="stType">Builder</span> {
        builder.append(<span class="stQuotedString">"productive!"</span>)
        assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
      }
    }
  }
<br/>  describe(<span class="stQuotedString">"Test code"</span>) {
    <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
    it(<span class="stQuotedString">"should be readable"</span>) {
      <span class="stReserved">new</span> <span class="stType">Buffer</span> {
        buffer += (<span class="stQuotedString">"readable!"</span>)
        assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
      }
    }
<br/>    <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
    it(<span class="stQuotedString">"should be clear and concise"</span>) {
      <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
        builder.append(<span class="stQuotedString">"clear!"</span>)
        buffer += (<span class="stQuotedString">"concise!"</span>)
        assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
        assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
      }
    }
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  describe(<span class="stQuotedString">"This test"</span>) {
    it(<span class="stQuotedString">"should succeed"</span>) {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
    }
<br/>    it(<span class="stQuotedString">"should fail"</span>) {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    <span class="stLineComment">// This test needs the file fixture</span>
    it(<span class="stQuotedString">"should be productive"</span>) {
      withFile { (file, writer) =&gt;
        writer.write(<span class="stQuotedString">"productive!"</span>)
        writer.flush()
        assert(file.length === <span class="stLiteral">24</span>)
      }
    }
  }
<br/>  describe(<span class="stQuotedString">"Test code"</span>) {
    <span class="stLineComment">// This test needs the database fixture</span>
    it(<span class="stQuotedString">"should be readable"</span>) {
      withDatabase { db =&gt;
        db.append(<span class="stQuotedString">"readable!"</span>)
        assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
      }
    }
<br/>    <span class="stLineComment">// This test needs both the file and the database</span>
    it(<span class="stQuotedString">"should be clear and concise"</span>) {
      withDatabase { db =&gt;
       withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
          db.append(<span class="stQuotedString">"clear!"</span>)
          writer.write(<span class="stQuotedString">"concise!"</span>)
          writer.flush()
          assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
          assert(file.length === <span class="stLiteral">21</span>)
        }
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.Suite</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.Suite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/FunSpec.html">documentation for <code>fixture.FunSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.FunSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  describe(<span class="stQuotedString">"Testing"</span>) {
    it(<span class="stQuotedString">"should be easy"</span>) {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    it(<span class="stQuotedString">"should be fun"</span>) {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in a <code>FunSpec</code>, you first place shared tests in <em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>FunSpec</code> that uses them, so that the tests they contain will be registered as tests in that <code>FunSpec</code>.
For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>FunSpec</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures. You
can define a behavior function that encapsulates these shared tests inside the <code>FunSpec</code> that uses them. If they are shared
between different <code>FunSpec</code>s, however, you could also define them in a separate trait that is mixed into each <code>FunSpec</code> that uses them.</p><p><a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">StackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">FunSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(newStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    it(<span class="stQuotedString">"should be non-empty"</span>) {
      assert(!newStack.empty)
    }
<br/>    it(<span class="stQuotedString">"should return the top item on peek"</span>) {
      assert(newStack.peek === lastItemAdded)
    }
<br/>    it(<span class="stQuotedString">"should not remove the top item on peek"</span>) {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.peek === lastItemAdded)
      assert(stack.size === size)
    }
<br/>    it(<span class="stQuotedString">"should remove the top item on pop"</span>) {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.pop === lastItemAdded)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(newStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    it(<span class="stQuotedString">"should not be full"</span>) {
      assert(!newStack.full)
    }
<br/>    it(<span class="stQuotedString">"should add to the top on push"</span>) {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      stack.push(<span class="stLiteral">7</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>FunSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
it should behave like nonFullStack(stackWithOneItem)
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre class="stHighlighted">
it should behave like nonEmptyStack <span class="stLineComment">// assuming lastValuePushed is also in scope inside nonEmptyStack</span>
it should behave like nonFullStack
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">SharedTestExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FunSpec</span> <span class="stReserved">with</span> <span class="stType">StackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  describe(<span class="stQuotedString">"A Stack"</span>) {
<br/>    describe(<span class="stQuotedString">"(when empty)"</span>) {
<br/>      it(<span class="stQuotedString">"should be empty"</span>) {
        assert(emptyStack.empty)
      }
<br/>      it(<span class="stQuotedString">"should complain on peek"</span>) {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.peek
        }
      }
<br/>      it(<span class="stQuotedString">"should complain on pop"</span>) {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.pop
        }
      }
    }
<br/>    describe(<span class="stQuotedString">"(with one item)"</span>) {
      it should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
      it should behave like nonFullStack(stackWithOneItem)
    }
<br/>    describe(<span class="stQuotedString">"(with one item less than capacity)"</span>) {
      it should behave like nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed)
      it should behave like nonFullStack(stackWithOneItemLessThanCapacity)
    }
<br/>    describe(<span class="stQuotedString">"(full)"</span>) {
<br/>      it(<span class="stQuotedString">"should be full"</span>) {
        assert(fullStack.full)
      }
<br/>      it should behave like nonEmptyStack(fullStack, lastValuePushed)
<br/>      it(<span class="stQuotedString">"should complain on a push"</span>) {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          fullStack.push(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">A Stack (when empty)
- should be empty
- should complain on peek
- should complain on pop
A Stack (with one item)
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should not be full
- should add to the top on push
A Stack (with one item less than capacity)
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should not be full
- should add to the top on push
A Stack (full)
- should be full
- should be non-empty
- should return the top item on peek
- should not remove the top item on peek
- should remove the top item on pop
- should complain on a push</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name. A good way to solve this problem in a <code>FunSpec</code> is to surround
each invocation of a behavior function with a <code>describe</code> clause, which will prepend a string to each test name.
For example, the following code in a <code>FunSpec</code> would register a test with the name <code>"A Stack (when empty) should be empty"</code>:</p><p><pre class="stHighlighted">
describe(<span class="stQuotedString">"A Stack"</span>) {
<br/>  describe(<span class="stQuotedString">"(when empty)"</span>) {
<br/>    it(<span class="stQuotedString">"should be empty"</span>) {
      assert(emptyStack.empty)
    }
    <span class="stLineComment">// ...</span>
</pre></p><p>If the <code>"should be empty"</code> test was factored out into a behavior function, it could be called repeatedly so long
as each invocation of the behavior function is inside a different set of <code>describe</code> clauses.
</p></div></div>
    </li><li name="org.scalatest.FunSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="FunSpecLike:FunSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FunSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class FunSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="FunSpecLike.html"><span class="name">FunSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>FunSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are combined with text that specifies the behavior the tests
verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>FunSpec</code>, which
facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD),
in which tests are combined with text that specifies the behavior the tests
verify.</p><p><a href="FunSpec.html"><code>FunSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>FunSpec</code> into some other class, you can use this
trait instead, because class <code>FunSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FunSpec.html">detailed
overview of <code>FunSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.FunSuite" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FunSuiteextendsFunSuiteLike"></a><a id="FunSuite:FunSuite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FunSuiteextendsFunSuiteLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A suite of tests in which each test is represented as a function value." href="FunSuite.html"><span class="name">FunSuite</span></a><span class="result"> extends <a href="FunSuiteLike.html" class="extype" name="org.scalatest.FunSuiteLike">FunSuiteLike</a></span>
      </span>
      
      <p class="shortcomment cmt">A suite of tests in which each test is represented as a function value.</p><div class="fullcomment"><div class="comment cmt"><p>A suite of tests in which each test is represented as a function value. The &ldquo;<code>Fun</code>&rdquo; in <code>FunSuite</code> stands
for &ldquo;function.&rdquo;</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
For teams coming from xUnit, <code>FunSuite</code> feels comfortable and familiar while still giving some benefits of BDD: <code>FunSuite</code> makes it easy to
write descriptive test names, natural to write focused tests, and generates specification-like output that can facilitate communication among
stakeholders.
</td></tr></table></p><p>Here's an example <code>FunSuite</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  test(<span class="stQuotedString">"An empty Set should have size 0"</span>) {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  test(<span class="stQuotedString">"Invoking head on an empty Set should produce NoSuchElementException"</span>) {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>&ldquo;<code>test</code>&rdquo; is a method, defined in <code>FunSuite</code>, which will be invoked
by the primary constructor of <code>SetSuite</code>. You specify the name of the test as
a string between the parentheses, and the test code itself between curly braces.
The test code is a function passed as a by-name parameter to <code>test</code>, which registers
it for later execution.</p><p>A <code>FunSuite</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>test</code> method while the <code>FunSuite</code> is
in its registration phase. Any attempt to register a test after the <code>FunSuite</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>FunSuite</code>,
will be met with a thrown <code>TestRegistrationClosedException</code>. The recommended style
of using <code>FunSuite</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><em>Note: <code>FunSuite</code> was in part inspired by <a href="http://rehersal.sourceforge.net/documentation.shtml" target="_blank">Rehersal</a>,
an early test framework for Scala.</em></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>FunSuite</code> provides registration
methods that start with <code>ignore</code> instead of <code>test</code>. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.ignore
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  ignore(<span class="stQuotedString">"An empty Set should have size 0"</span>) {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  test(<span class="stQuotedString">"Invoking head on an empty Set should produce NoSuchElementException"</span>) {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>If you run this version of <code>SetSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">SetSuite:</span>
<span class="stYellow">- An empty Set should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">- Invoking head on an empty Set should produce NoSuchElementException</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  test(<span class="stQuotedString">"An empty Set should have size 0"</span>) {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  test(<span class="stQuotedString">"Invoking head on an empty Set should produce NoSuchElementException"</span>) {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSuite</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSuite</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
<span class="stGreen">SetSuite:</span>
<span class="stYellow">- An empty Set should have size 0 !!! IGNORED !!!
- Invoking head on an empty Set should produce NoSuchElementException !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>FunSuite</code>'s <code>run</code> method is a <code>Reporter</code>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>FunSuite</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information
to the current <code>Reporter</code> is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <code>InfoProvided</code> event.
Here's an example that shows both a direct use as well as an indirect use through the methods
of <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
  }
}
</pre></p><p>If you run this <code>FunSuite</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
<span class="stGreen">SetSuite:
- an element can be added to an empty mutable Set
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks!</span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>FunSuite</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>FunSuite</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/funSuite.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  test(<span class="stQuotedString">"An element can be added to an empty mutable Set"</span>) {
<br/>    info(<span class="stQuotedString">"info is recorded"</span>)
    markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
    note(<span class="stQuotedString">"notes are sent immediately"</span>)
    alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
    set += <span class="stQuotedString">"clarity"</span>
    assert(set.size === <span class="stLiteral">1</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSuite:
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- An element can be added to an empty mutable Set
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <code>TestPendingException</code>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented.</p><p>Although pending tests may be used more often in specification-style suites, such as
<code>org.scalatest.FunSpec</code>, you can also use it in <code>FunSuite</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.pending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  test(<span class="stQuotedString">"An empty Set should have size 0"</span>) (pending)
<br/>  test(<span class="stQuotedString">"Invoking head on an empty Set should produce NoSuchElementException"</span>) {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>SetSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">SetSuite:</span>
<span class="stYellow">- An empty Set should have size 0 (pending)</span>
<span class="stGreen">- Invoking head on an empty Set should produce NoSuchElementException</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>FunSuite</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>FunSuite</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>FunSuite</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>FunSuite</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>FunSuite</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">SetSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  test(<span class="stQuotedString">"An empty Set should have size 0"</span>, <span class="stType">Slow</span>) {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
<br/>  test(<span class="stQuotedString">"Invoking head on an empty Set should produce NoSuchElementException"</span>,
       <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
    assertThrows[<span class="stType">NoSuchElementException</span>] {
      Set.empty.head
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>FunSuite</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

    <dl>
    <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
    <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
    <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(OneArgTest)</code> instead)</dd>
    </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or an holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.getfixture
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(f.buffer.isEmpty)
    f.buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(f.buffer.isEmpty)
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FunSuite
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  <span class="stLineComment">// This test needs the StringBuilder fixture</span>
  test(<span class="stQuotedString">"Testing should be productive"</span>) {
    <span class="stReserved">new</span> <span class="stType">Builder</span> {
      builder.append(<span class="stQuotedString">"productive!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
  test(<span class="stQuotedString">"Test code should be readable"</span>) {
    <span class="stReserved">new</span> <span class="stType">Buffer</span> {
      buffer += (<span class="stQuotedString">"readable!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
    }
  }
<br/>  <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
  test(<span class="stQuotedString">"Test code should be clear and concise"</span>) {
    <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
      builder.append(<span class="stQuotedString">"clear!"</span>)
      buffer += (<span class="stQuotedString">"concise!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
    }
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  test(<span class="stQuotedString">"This test should succeed"</span>) {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
  }
<br/>  test(<span class="stQuotedString">"This test should fail"</span>) {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
- this test should succeed</span>
<span class="stRed">- this test should fail *** FAILED ***
  2 did not equal 3 (<console>:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.loanfixture
<br/><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stLineComment">// This test needs the file fixture</span>
  test(<span class="stQuotedString">"Testing should be productive"</span>) {
    withFile { (file, writer) =&gt;
      writer.write(<span class="stQuotedString">"productive!"</span>)
      writer.flush()
      assert(file.length === <span class="stLiteral">24</span>)
    }
  }
<br/>  <span class="stLineComment">// This test needs the database fixture</span>
  test(<span class="stQuotedString">"Test code should be readable"</span>) {
    withDatabase { db =&gt;
      db.append(<span class="stQuotedString">"readable!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
    }
  }
<br/>  <span class="stLineComment">// This test needs both the file and the database</span>
  test(<span class="stQuotedString">"Test code should be clear and concise"</span>) {
    withDatabase { db =&gt;
      withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
        db.append(<span class="stQuotedString">"clear!"</span>)
        writer.write(<span class="stQuotedString">"concise!"</span>)
        writer.flush()
        assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
        assert(file.length === <span class="stLiteral">21</span>)
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.Suite</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.Suite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">fixture.FunSuite</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
<br/>    <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>)
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) { f =&gt;
    f.writer.write(<span class="stQuotedString">"easy!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) { f =&gt;
    f.writer.write(<span class="stQuotedString">"fun!"</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/FunSuite.html">documentation for <code>fixture.FunSuite</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  test(<span class="stQuotedString">"testing should be easy"</span>) {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  test(<span class="stQuotedString">"testing should be fun"</span>) {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Suite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Suite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.funsuite.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  test(<span class="stQuotedString">"Testing should be easy"</span>) {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  test(<span class="stQuotedString">"Testing should be fun"</span>) {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"clear"</span>
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
To accomplish this in a <code>FunSuite</code>, you first place shared tests in
<em>behavior functions</em>. These behavior functions will be
invoked during the construction phase of any <code>FunSuite</code> that uses them, so that the tests they contain will
be registered as tests in that <code>FunSuite</code>.
For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>FunSuite</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures.</p><p>You can define a behavior function that encapsulates these shared tests inside the <code>FunSuite</code> that uses them. If they are shared
between different <code>FunSuite</code>s, however, you could also define them in a separate trait that is mixed into
each <code>FunSuite</code> that uses them.
<a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a
behavior <em>method</em>) is defined in a trait along with another
method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSuite
<br/><span class="stReserved">trait</span> <span class="stType">FunSuiteStackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">FunSuite</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(createNonEmptyStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    test(<span class="stQuotedString">"empty is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
      <span class="stReserved">val</span> stack = createNonEmptyStack
      assert(!stack.empty)
    }
<br/>    test(<span class="stQuotedString">"peek is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
      <span class="stReserved">val</span> stack = createNonEmptyStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.peek === lastItemAdded)
      assert(stack.size === size)
    }
<br/>    test(<span class="stQuotedString">"pop is invoked on this non-empty stack: "</span> + createNonEmptyStack.toString) {
      <span class="stReserved">val</span> stack = createNonEmptyStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.pop === lastItemAdded)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(createNonFullStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    test(<span class="stQuotedString">"full is invoked on this non-full stack: "</span> + createNonFullStack.toString) {
      <span class="stReserved">val</span> stack = createNonFullStack
      assert(!stack.full)
    }
<br/>    test(<span class="stQuotedString">"push is invoked on this non-full stack: "</span> + createNonFullStack.toString) {
      <span class="stReserved">val</span> stack = createNonFullStack
      <span class="stReserved">val</span> size = stack.size
      stack.push(<span class="stLiteral">7</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>FunSuite</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
testsFor(nonFullStack(stackWithOneItem))
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStack) <span class="stLineComment">// assuming lastValuePushed is also in scope inside nonEmptyStack</span>
testsFor(nonFullStack)
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSuite
<br/><span class="stReserved">class</span> <span class="stType">StackFunSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">FunSuiteStackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  test(<span class="stQuotedString">"empty is invoked on an empty stack"</span>) {
    <span class="stReserved">val</span> stack = emptyStack
    assert(stack.empty)
  }
<br/>  test(<span class="stQuotedString">"peek is invoked on an empty stack"</span>) {
    <span class="stReserved">val</span> stack = emptyStack
    assertThrows[<span class="stType">IllegalStateException</span>] {
      stack.peek
    }
  }
<br/>  test(<span class="stQuotedString">"pop is invoked on an empty stack"</span>) {
    <span class="stReserved">val</span> stack = emptyStack
    assertThrows[<span class="stType">IllegalStateException</span>] {
      stack.pop
    }
  }
<br/>  testsFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
  testsFor(nonFullStack(stackWithOneItem))
<br/>  testsFor(nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed))
  testsFor(nonFullStack(stackWithOneItemLessThanCapacity))
<br/>  test(<span class="stQuotedString">"full is invoked on a full stack"</span>) {
    <span class="stReserved">val</span> stack = fullStack
    assert(stack.full)
  }
<br/>  testsFor(nonEmptyStack(fullStack, lastValuePushed))
<br/>  test(<span class="stQuotedString">"push is invoked on a full stack"</span>) {
    <span class="stReserved">val</span> stack = fullStack
    assertThrows[<span class="stType">IllegalStateException</span>] {
      stack.push(<span class="stLiteral">10</span>)
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackFunSuite)
<span class="stGreen">StackFunSuite:
- empty is invoked on an empty stack
- peek is invoked on an empty stack
- pop is invoked on an empty stack
- empty is invoked on this non-empty stack: Stack(9)
- peek is invoked on this non-empty stack: Stack(9)
- pop is invoked on this non-empty stack: Stack(9)
- full is invoked on this non-full stack: Stack(9)
- push is invoked on this non-full stack: Stack(9)
- empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
- peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
- pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
- full is invoked on this non-full stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
- push is invoked on this non-full stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)
- full is invoked on a full stack
- empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
- peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
- pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
- push is invoked on a full stack</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name.
In a <code>FunSuite</code> there is no nesting construct analogous to <code>FunSpec</code>'s <code>describe</code> clause.
Therefore, you need to do a bit of
extra work to ensure that the test names are unique. If a duplicate test name problem shows up in a
<code>FunSuite</code>, you'll need to pass in a prefix or suffix string to add to each test name. You can pass this string
the same way you pass any other data needed by the shared tests, or just call <code>toString</code> on the shared fixture object.
This is the approach taken by the previous <code>FunSuiteStackBehaviors</code> example.</p><p>Given this <code>FunSuiteStackBehaviors</code> trait, calling it with the <code>stackWithOneItem</code> fixture, like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStack(stackWithOneItem, lastValuePushed))
</pre></p><p>yields test names:</p><ul><li><code>empty is invoked on this non-empty stack: Stack(9)</code></li><li><code>peek is invoked on this non-empty stack: Stack(9)</code></li><li><code>pop is invoked on this non-empty stack: Stack(9)</code></li></ul><p>Whereas calling it with the <code>stackWithOneItemLessThanCapacity</code> fixture, like this:</p><p><pre class="stHighlighted">
testsFor(nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed))
</pre></p><p>yields different test names:</p><ul><li><code>empty is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li><li><code>peek is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li><li><code>pop is invoked on this non-empty stack: Stack(9, 8, 7, 6, 5, 4, 3, 2, 1)</code></li></ul></div></div>
    </li><li name="org.scalatest.FunSuiteLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FunSuiteLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="FunSuiteLike:FunSuiteLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FunSuiteLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class FunSuite, which represents a suite of tests in which each test is represented as a function value." href="FunSuiteLike.html"><span class="name">FunSuiteLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>FunSuite</code>, which represents
a suite of tests in which each test is represented as a function value.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>FunSuite</code>, which represents
a suite of tests in which each test is represented as a function value.</p><p><a href="FunSuite.html"><code>FunSuite</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>FunSuite</code> into some other class, you can use this
trait instead, because class <code>FunSuite</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="FunSuite.html">detailed
overview of <code>FunSuite</code></a>.</p></div></div>
    </li><li name="org.scalatest.FutureOutcome" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FutureOutcomeextendsAnyRef"></a><a id="FutureOutcome:FutureOutcome"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FutureOutcomeextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Wrapper class for Future[Outcome] that presents a more convenient API for manipulation in withFixture methods in async styles." href="FutureOutcome.html"><span class="name">FutureOutcome</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Wrapper class for <code>Future[Outcome]</code> that presents a more convenient API for
manipulation in <code>withFixture</code> methods in async styles.</p><div class="fullcomment"><div class="comment cmt"><p>Wrapper class for <code>Future[Outcome]</code> that presents a more convenient API for
manipulation in <code>withFixture</code> methods in async styles.</p><p>This type serves as the result type of both test functions and <code>withFixture</code> methods
in ScalaTest's async styles. A <code>Future[Outcome]</code> is not used as this result type
for two reasons. First, <code>Outcome</code> treats exceptions specially, and as a result
methods on <code>Future</code> would usually not yield the desired <code>Future[Outcome]</code> result.
Only run-aborting exceptions should result in a failed <code>Future[Outcome]</code>. Any other thrown exception
other than <code>TestCanceledException</code> or <code>TestPendingException</code>
should result in a successful<code>Future</code> containing a <code>org.scalatest.Failed</code>.
A thrown <code>TestCanceledException</code> should result in a successful <code>Future</code>
containing an <code>org.scalatest.Canceled</code>; A thrown <code>TestPendingException</code> should result in
a successful <code>Future</code> containing a <code>org.scalatest.Pending</code>.
If manipulating a <code>Future[Outcome]</code> directly, by contrast, any thrown exception would result in
a failed <code>Future</code>.</p><p>Additionally, to be consistent with corresponding transformations in traditional testing styles,
methods registering callbacks should return a new future outcome that doesn't complete until
both the original future outcome has completed and the subsequent callback has completed execution.
Additionally, if the callback itself throws an exception, that exception should determine the result
of the future outcome returned by the callback registration method. This behavior is rather inconvenient
to obtain on the current <code>Future</code> API, so <code>FutureOutcome</code> provides well-named
methods that have this behavior.</p><p>Lastly, the <code>FutureOutcome</code> is intended to help prevent confusion by eliminating the need
to work with types like <code>scala.util.Success(org.scalatest.Failed)</code>. For this purpose a
<code>org.scalactic.Or</code> is used instead of a <code>scala.util.Try</code> to describe results
of <code>FutureOutcome</code>.</p><p>A <code>FutureOutcome</code> represents a computation that can result in an <code>Outcome</code> or an &quot;abort.&quot; An abort means
that a run-aborting exception occurred during the computation. Any other, non-run-aborting exception will be represented
as an non-<code>Succeeded</code> <code>Outcome</code>: one of <code>Failed</code>, <code>Canceled</code>, or <code>Pending</code>.</p><p>The methods of <code>FutureOutcome</code> include the following callback registration methods:</p><ul><li><code>onSucceededThen</code> - registers a callback to be executed if the future outcome is <code>Succeeded</code>.</li><li><code>onFailedThen</code> - registers a callback to be executed if the future outcome is <code>Failed</code>.</li><li><code>onCanceledThen</code> - registers a callback to be executed if the future outcome is <code>Canceled</code>.</li><li><code>onPendingThen</code> - registers a callback to be executed if the future outcome is <code>Pending</code>.</li><li><code>onOutcomeThen</code> - registers a callback to be executed if the future outcome is actually an <code>Outcome</code>
     and not an abort.</li><li><code>onAbortedThen</code> - registers a callback to be executed if the future outcome aborts.</li><li><code>onCompletedThen</code> - registers a callback to be executed upon completion no matter how the future outcome completes.</li></ul><p>The callback methods listed previously can be used to perform a side effect once a <code>FutureOutcome</code> completes. To change an
<code>Outcome</code> into a different <code>Outcome</code> asynchronously, use the <code>change</code> registration method, which takes a function
from <code>Outcome</code> to <code>Outcome</code>. The other methods on <code>FutureOutcome</code>, <code>isCompleted</code> and
<code>value</code>, allow you to poll a <code>FutureOutcome</code>. None of the methods on <code>FutureOutcome</code> block.
Lastly, because an implicit <a href="enablers/Futuristic.html"><code>Futuristic</code></a> instance is provided for
<code>FutureOutcome</code>, you can use <a href="CompleteLastly.html"><code>complete</code>-<code>lastly</code> syntax</a>
with <code>FutureOutcome</code>.</p></div></div>
    </li><li name="org.scalatest.GivenWhenThen" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="GivenWhenThenextendsAnyRef"></a><a id="GivenWhenThen:GivenWhenThen"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#GivenWhenThenextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains methods named given, when, then, and and, which take a string message and implicit Informer, and forward the message to the informer." href="GivenWhenThen.html"><span class="name">GivenWhenThen</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains methods named <code>given</code>, <code>when</code>, <code>then</code>, and <code>and</code>,
which take a string message and implicit <a href="Informer.html"><code>Informer</code></a>, and forward the message to the informer.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains methods named <code>given</code>, <code>when</code>, <code>then</code>, and <code>and</code>,
which take a string message and implicit <a href="Informer.html"><code>Informer</code></a>, and forward the message to the informer.</p><p>Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
  }
}
</pre></p><p>If you run this <code>SetSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Ignore" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="IgnoreextendsAnnotation"></a><a id="Ignore:Ignore"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#IgnoreextendsAnnotation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Annotation used to tag a test, or suite of tests, as ignored." href="Ignore.html"><span class="name">Ignore</span></a><span class="result"> extends <span class="extype" name="java.lang.annotation.Annotation">Annotation</span></span>
      </span>
      
      <p class="shortcomment cmt">Annotation used to tag a test, or suite of tests, as ignored.</p><div class="fullcomment"><div class="comment cmt"><p>Annotation used to tag a test, or suite of tests, as ignored.</p><p><em>Note: This is actually an annotation defined in Java, not a Scala trait. It must be defined in Java instead of Scala so it will be accessible
at runtime. It has been inserted into Scaladoc by pretending it is a trait.</em></p><p>If you wish to temporarily ignore an entire suite of tests, you can annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlight">
package org.scalatest.examples.flatspec.ignoreall

import org.scalatest._

@Ignore
class SetSpec extends FlatSpec {

  "An empty Set" should "have size 0" in {
    assert(Set.empty.size === 0)
  }

  it should "produce NoSuchElementException when head is invoked" in {
    intercept[NoSuchElementException] {
      Set.empty.head
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">An empty Set</span>
<span class="stYellow">- should have size 0 !!! IGNORED !!!
- should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class somewhat visible, to encourage the developers to eventually fix and un-ignore it. If you want to
prevent a class from being discovered at all, use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p>Another use case for <code>@Ignore</code> is to mark test <em>methods</em> as ignored in traits <a href="Spec.html"><code>Spec</code></a>
and <a href="fixture/Spec.html"><code>fixture.Spec</code></a>. Here's an example:</p><p><pre class="stHighlight">
package org.scalatest.examples.spec.ignore

import org.scalatest._

class SetSpec extends RefSpec {

  @Ignore def &#96;an empty Set should have size 0&#96; {
    assert(Set.empty.size === 0)
  }

  def &#96;invoking head on an empty Set should produce NoSuchElementException&#96; {
    intercept[NoSuchElementException] {
      Set.empty.head
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> in the Scala interpreter, you'll see that it
runs only the second test and reports that the first test was ignored:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
<span class="stYellow">- an empty Set should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">- invoking head on an empty Set should produce NoSuchElementException</span>
</pre>




Note that because reflection is not supported on Scala.js, this annotation will only work on the JVM, not on Scala.js.

</p></div></div>
    </li><li name="org.scalatest.Informer" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InformerextendsAnyRef"></a><a id="Informer:Informer"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#InformerextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait to which custom information about a running suite of tests can be reported." href="Informer.html"><span class="name">Informer</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait to which custom information about a running suite of tests can be reported.</p><div class="fullcomment"><div class="comment cmt"><p>Trait to which custom information about a running suite of tests can be reported.</p><p>An <code>Informer</code> is essentially
used to wrap a <code>Reporter</code> and provide easy ways to send custom information
to that <code>Reporter</code> via an <code>InfoProvided</code> event.
<code>Informer</code> contains an <code>apply</code> method that takes a string and
an optional payload object of type <code>Any</code>.
The <code>Informer</code> will forward the passed <code>message</code> string to the
<a href="Reporter.html"><code>Reporter</code></a> as the <code>message</code> parameter, and the optional
payload object as the <code>payload</code> parameter, of an <a href="InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>Here's an example in which the <code>Informer</code> is used both directly via <code>info</code>
method of trait <a href="FlatSpec.html"><code>FlatSpec</code></a> and indirectly via the methods of
trait <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should <span class="stQuotedString">"allow an element to be added"</span> in {
    given(<span class="stQuotedString">"an empty mutable Set"</span>)
    <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>    when(<span class="stQuotedString">"an element is added"</span>)
    set += <span class="stQuotedString">"clarity"</span>
<br/>    then(<span class="stQuotedString">"the Set should have size 1"</span>)
    assert(set.size === <span class="stLiteral">1</span>)
<br/>    and(<span class="stQuotedString">"the Set should contain the added element"</span>)
    assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>    info(<span class="stQuotedString">"That's all folks!"</span>)
  }
}
</pre></p><p>If you run this <code>SetSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks! </span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Informing" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="InformingextendsAnyRef"></a><a id="Informing:Informing"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#InformingextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains the info method, which can be used to send info to the reporter." href="Informing.html"><span class="name">Informing</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains the <code>info</code> method, which can be used to send info to the reporter.</p>
    </li><li name="org.scalatest.Inside" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InsideextendsAnyRef"></a><a id="Inside:Inside"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#InsideextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait containing the inside construct, which allows you to make statements about nested object graphs using pattern matching." href="Inside.html"><span class="name">Inside</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait containing the <code>inside</code> construct, which allows you to make statements about nested object graphs using pattern matching.</p><div class="fullcomment"><div class="comment cmt"><p>Trait containing the <code>inside</code> construct, which allows you to make statements about nested object graphs using pattern matching.</p><p>For example, given the following case classes:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Address</span>(street: <span class="stType">String</span>, city: <span class="stType">String</span>, state: <span class="stType">String</span>, zip: <span class="stType">String</span>)
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Name</span>(first: <span class="stType">String</span>, middle: <span class="stType">String</span>, last: <span class="stType">String</span>)
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Record</span>(name: <span class="stType">Name</span>, address: <span class="stType">Address</span>, age: <span class="stType">Int</span>)
</pre></p><p>You could write:</p><p><pre class="stHighlighted">
inside (rec) { <span class="stReserved">case</span> <span class="stType">Record</span>(name, address, age) =&gt;
  inside (name) { <span class="stReserved">case</span> <span class="stType">Name</span>(first, middle, last) =&gt;
    first should be (<span class="stQuotedString">"Sally"</span>)
    middle should be (<span class="stQuotedString">"Ann"</span>)
    last should be (<span class="stQuotedString">"Jones"</span>)
  }
  inside (address) { <span class="stReserved">case</span> <span class="stType">Address</span>(street, city, state, zip) =&gt;
    street should startWith (<span class="stQuotedString">"25"</span>)
    city should endWith (<span class="stQuotedString">"Angeles"</span>)
    state should equal (<span class="stQuotedString">"CA"</span>)
    zip should be (<span class="stQuotedString">"12345"</span>)
  }
  age should be &lt; <span class="stLiteral">99</span>
}
</pre></p><p>If an assertion fails, the error message will include the <code>toString</code> of each value passed
to <code>inside</code> clauses enclosing the failed assertion. For example, if <code>rec</code> in
the previous expression was defined like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> rec = <span class="stType">Record</span>(
  <span class="stType">Name</span>(<span class="stQuotedString">"Sally"</span>, <span class="stQuotedString">"Anna"</span>, <span class="stQuotedString">"Jones"</span>),
  <span class="stType">Address</span>(<span class="stQuotedString">"25 Main St"</span>, <span class="stQuotedString">"Los Angeles"</span>, <span class="stQuotedString">"CA"</span>, <span class="stQuotedString">"12345"</span>),
  <span class="stLiteral">38</span>
)
</pre></p><p>The error message will read:</p><p><pre>
"Ann[a]" was not equal to "Ann[]", inside Name(Sally,Anna,Jones),
inside Record(Name(Sally,Anna,Jones),Address(25 Main St,Los Angeles,CA,12345),38)
</pre></p></div></div>
    </li><li name="org.scalatest.Inspectors" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InspectorsextendsAnyRef"></a><a id="Inspectors:Inspectors"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#InspectorsextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides nestable inspector methods (or just inspectors) that enable assertions to be made about collections." href="Inspectors.html"><span class="name">Inspectors</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides nestable <em>inspector methods</em> (or just <em>inspectors</em>) that enable assertions to be made about collections.</p><div class="fullcomment"><div class="comment cmt"><p>Provides nestable <em>inspector methods</em> (or just <em>inspectors</em>) that enable assertions to be made about collections.</p><p>For example, the <code>forAll</code> method enables you to state that something should be true about all elements of a collection, such
as that all elements should be positive:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Assertions._
import Assertions._

scala&gt; import Inspectors._
import Inspectors._

scala&gt; val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; forAll (xs) { x =&gt; assert(x &gt; 0) }
</pre></p><p>Or, with matchers:</p><p><pre class="stREPL">
scala&gt; import Matchers._
import Matchers._

scala&gt; forAll (xs) { x =&gt; x should be &gt; 0 }
</pre></p><p>To make assertions about nested collections, you can nest the inspector method invocations.
For example, given the following list of lists of <code>Int</code>:</p><p><pre class="stREPL">
scala&gt; val yss =
     |   List(
     |     List(1, 2, 3),
     |     List(1, 2, 3),
     |     List(1, 2, 3)
     |   )
yss: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3), List(1, 2, 3))
</pre></p><p>You can assert that all <code>Int</code> elements in all nested lists are positive by nesting two <code>forAll</code> method invocations, like this:</p><p><pre class="stREPL">
scala&gt; forAll (yss) { ys =&gt;
     |   forAll (ys) { y =&gt; y should be &gt; 0 }
     | }
</pre></p><p>The full list of inspector methods are:</p><ul><li><code>forAll</code> - succeeds if the assertion holds true for every element</li><li><code>forAtLeast</code> - succeeds if the assertion holds true for at least the specified number of elements</li><li><code>forAtMost</code> - succeeds if the assertion holds true for at most the specified number of elements</li><li><code>forBetween</code> - succeeds if the assertion holds true for between the specified minimum and maximum number of elements, inclusive</li><li><code>forEvery</code> - same as <code>forAll</code>, but lists all failing elements if it fails (whereas <code>forAll</code> just reports the first failing element)</li><li><code>forExactly</code> - succeeds if the assertion holds true for exactly the specified number of elements</li></ul><p>The error messages produced by inspector methods are designed to make sense no matter how deeply you nest the method invocations.
Here's an example of a nested inspection that fails and the resulting error message:</p><p><pre class="stREPL">
scala&gt; forAll (yss) { ys =&gt;
     |   forAll (ys) { y =&gt; y should be &lt; 2 }
     | }
org.scalatest.exceptions.TestFailedException: forAll failed, because:
  at index 0, forAll failed, because:
    at index 1, 2 was not less than 2 (&lt;console&gt;:20)
  in List(1, 2, 3) (&lt;console&gt;:20)
in List(List(1, 2, 3), List(1, 2, 3), List(1, 2, 3))
     at org.scalatest.InspectorsHelper$.forAll(Inspectors.scala:146)
     ...
</pre></p><p>One way the error message is designed to help you understand the error is by using indentation that mimics the indentation of the
source code (optimistically assuming the source will be nicely indented). The error message above indicates the outer <code>forAll</code> failed
because its initial <code>List</code> (<em>i.e.</em>, at index 0) failed
the assertion, which was that all elements of that initial <code>List[Int]</code> at index 0 should be less than 2. This assertion failed because index 1 of
that inner list contained the value 2, which was indeed &ldquo;not less than 2.&rdquo; The error message for the inner list is an indented line inside the error message
for the outer list. The actual contents of each list are displayed at the end in inspector error messages, also indented appropriately. The actual contents
are placed at the end so that for very large collections, the contents will not drown out and make it difficult to find the messages that describe
actual causes of the failure.</p><p>The <code>forAll</code> and <code>forEvery</code> methods are similar in that both succeed only if the assertion holds for all elements of the collection.
They differ in that <code>forAll</code> will only report the first element encountered that failed the assertion, but <code>forEvery</code> will report <em>all</em>
elements that fail the assertion. The tradeoff is that while <code>forEvery</code> gives more information, it may take longer to run because it must inspect every element
of the collection. The <code>forAll</code> method can simply stop inspecting once it encounters the first failing element. Here's an example that
shows the difference in the <code>forAll</code> and <code>forEvery</code> error messages:</p><p><pre class="stREPL">
scala&gt; forAll (xs) { x =&gt; x should be &lt; 3 }
org.scalatest.exceptions.TestFailedException: forAll failed, because:
  at index 2, 3 was not less than 3 (&lt;console&gt;:18)
in List(1, 2, 3, 4, 5)
     at org.scalatest.InspectorsHelper$.forAll(Inspectors.scala:146)
     ...

scala&gt; forEvery (xs) { x =&gt; x should be &lt; 3 }
org.scalatest.exceptions.TestFailedException: forEvery failed, because:
  at index 2, 3 was not less than 3 (&lt;console&gt;:18),
  at index 3, 4 was not less than 3 (&lt;console&gt;:18),
  at index 4, 5 was not less than 3 (&lt;console&gt;:18)
in List(1, 2, 3, 4, 5)
     at org.scalatest.InspectorsHelper$.forEvery(Inspectors.scala:226)
     ...
</pre></p><p>Note that if you're using matchers, you can alternatively use <em>inspector shorthands</em> for writing non-nested
inspections. Here's an example:</p><p><pre>
scala&gt; all (xs) should be &gt; 3
org.scalatest.exceptions.TestFailedException: 'all' inspection failed, because:
  at index 0, 1 was not greater than 3
in List(1, 2, 3, 4, 5)
     at org.scalatest.InspectorsHelper$.forAll(Inspectors.scala:146)
</pre></p><p>You can use <code>Inspectors</code> on any <code>scala.collection.GenTraversable</code>, <code>java.util.Collection</code>,
<code>java.util.Map</code> (with <a href="Entry.html"><code>Entry</code></a>), <code>Array</code>, or <code>String</code>.
Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Inspectors._
import Inspectors._

scala&gt; import Matchers._
import Matchers._

scala&gt; forAll (Array(1, 2, 3)) { e =&gt; e should be &lt; 5 }

scala&gt; import collection.JavaConverters._
import collection.JavaConverters._

scala&gt; val js = List(1, 2, 3).asJava
js: java.util.List[Int] = [1, 2, 3]

scala&gt; forAll (js) { j =&gt; j should be &lt; 5 }

scala&gt; val jmap = Map("a" -&gt; 1, "b" -&gt; 2).asJava
jmap: java.util.Map[String,Int] = {a=1, b=2}

scala&gt; forAtLeast(1, jmap) { e =&gt; e shouldBe Entry("b", 2) }

scala&gt; forAtLeast(2, "hello, world!") { c =&gt; c shouldBe 'o' }
</pre>
</p></div></div>
    </li><li name="org.scalatest.LoneElement" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="LoneElementextendsAnyRef"></a><a id="LoneElement:LoneElement"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#LoneElementextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides an implicit conversion that adds to collection types a loneElement method, which will return the value of the lone element if the collection does indeed contain one and only one element, or throw TestFailedException if not." href="LoneElement.html"><span class="name">LoneElement</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides an implicit conversion that adds to collection types a <code>loneElement</code> method, which
will return the value of the lone element if the collection does
indeed contain one and only one element, or throw <a href="TestFailedException.html"><code>TestFailedException</code></a> if not.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides an implicit conversion that adds to collection types a <code>loneElement</code> method, which
will return the value of the lone element if the collection does
indeed contain one and only one element, or throw <a href="TestFailedException.html"><code>TestFailedException</code></a> if not.</p><p>This construct allows you to express in one statement that a collection should contain one and only one element
and that the element value should meet some expectation. Here's an example:</p><p><pre class="stHighlighted">
set.loneElement should be &gt; <span class="stLiteral">9</span>
</pre></p><p>Or, using an assertion instead of a matcher expression:</p><p><pre class="stHighlighted">
assert(set.loneElement &gt; <span class="stLiteral">9</span>)
</pre></p><p>The <code>loneElement</code> syntax can be used with any collection type <code>C</code> for which an
implicit <a href="enablers/Collecting.html"><code>Collecting[C]</code></a> is available. ScalaTest provides
implicit <code>Collecting</code> instances for <code>scala.collection.GenTraversable</code>, <code>Array</code>,
and <code>java.util.Collection</code>. You can enable the <code>loneElement</code>
syntax on other collection types by defining an implicit <code>Collecting</code> instances for those types.</p><p>If you want to use <code>loneElement</code> with a <code>java.util.Map</code>, first transform it to a
set of entries with <code>entrySet</code>, and if helpful, use ScalaTest's <a href="Entry.html"><code>Entry</code></a> class:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import LoneElement._
import LoneElement._

scala&gt; import Matchers._
import Matchers._

scala&gt; val jmap = new java.util.HashMap[String, Int]
jmap: java.util.HashMap[String,Int] = {}

scala&gt; jmap.put("one", 1)
res0: Int = 0

scala&gt; jmap.entrySet.loneElement should be (Entry("one", 1))
</pre>
</p></div></div>
    </li><li name="org.scalatest.Matchers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="MatchersextendsAssertionswithTolerancewithShouldVerbwithMatcherWordswithExplicitly"></a><a id="Matchers:Matchers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#MatchersextendsAssertionswithTolerancewithShouldVerbwithMatcherWordswithExplicitly" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word should." href="Matchers.html"><span class="name">Matchers</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a> with <span class="extype" name="org.scalactic.Tolerance">Tolerance</span> with <a href="words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="words/MatcherWords.html" class="extype" name="org.scalatest.words.MatcherWords">MatcherWords</a> with <span class="extype" name="org.scalactic.Explicitly">Explicitly</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides a domain specific language (DSL) for expressing assertions in tests
using the word <code>should</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides a domain specific language (DSL) for expressing assertions in tests
using the word <code>should</code>.</p><p>For example, if you mix <code>Matchers</code> into
a suite class, you can write an equality assertion in that suite like this:</p><p><pre class="stHighlighted">
result should equal (<span class="stLiteral">3</span>)
</pre></p><p>Here <code>result</code> is a variable, and can be of any type. If the object is an
<code>Int</code> with the value 3, execution will continue (<em>i.e.</em>, the expression will result
in the unit value, <code>()</code>). Otherwise, a <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>
will be thrown with a detail message that explains the problem, such as <code>"7 did not equal 3"</code>.
This <code>TestFailedException</code> will cause the test to fail.</p><p>Here is a table of contents for this documentation:</p><ul><li><a href="#matchersMigration">Matchers migration in ScalaTest 2.0</a></li><li><a href="#checkingEqualityWithMatchers">Checking equality with matchers</a></li><li><a href="#checkingSizeAndLength">Checking size and length</a></li><li><a href="#checkingStrings">Checking strings</a></li><li><a href="#greaterAndLessThan">Greater and less than</a></li><li><a href="#checkingBooleanPropertiesWithBe">Checking <code>Boolean</code> properties with <code>be</code></a></li><li><a href="#usingCustomBeMatchers">Using custom <code>BeMatchers</code></a></li><li><a href="#checkingObjectIdentity">Checking object identity</a></li><li><a href="#checkingAnObjectsClass">Checking an object's class</a></li><li><a href="#checkingNumbersAgainstARange">Checking numbers against a range</a></li><li><a href="#checkingForEmptiness">Checking for emptiness</a></li><li><a href="#workingWithContainers">Working with "containers"</a></li><li><a href="#workingWithAggregations">Working with "aggregations"</a></li><li><a href="#workingWithSequences">Working with "sequences"</a></li><li><a href="#workingWithSortables">Working with "sortables"</a></li><li><a href="#workingWithIterators">Working with iterators</a></li><li><a href="#inspectorShorthands">Inspector shorthands</a></li><li><a href="#singleElementCollections">Single-element collections</a></li><li><a href="#javaCollectionsAndMaps">Java collections and maps</a></li><li><a href="#stringsAndArraysAsCollections"><code>String</code>s and <code>Array</code>s as collections</a></li><li><a href="#beAsAnEqualityComparison">Be as an equality comparison</a></li><li><a href="#beingNegative">Being negative</a></li><li><a href="#checkingThatCodeDoesNotCompile">Checking that a snippet of code does not compile</a></li><li><a href="#logicalExpressions">Logical expressions with <code>and</code> and <code>or</code></a></li><li><a href="#workingWithOptions">Working with <code>Option</code>s</a></li><li><a href="#checkingArbitraryProperties">Checking arbitrary properties with <code>have</code></a></li><li><a href="#lengthSizeHavePropertyMatchers">Using <code>length</code> and <code>size</code> with <code>HavePropertyMatcher</code>s</a></li><li><a href="#matchingAPattern">Checking that an expression matches a pattern</a></li><li><a href="#usingCustomMatchers">Using custom matchers</a></li><li><a href="#checkingForExpectedExceptions">Checking for expected exceptions</a></li><li><a href="#thosePeskyParens">Those pesky parens</a></li></ul><p>Trait <a href="MustMatchers.html"><code>MustMatchers</code></a> is an alternative to <code>Matchers</code> that provides the exact same
meaning, syntax, and behavior as <code>Matchers</code>, but uses the verb <code>must</code> instead of <code>should</code>.
The two traits differ only in the English semantics of the verb: <code>should</code>
is informal, making the code feel like conversation between the writer and the reader; <code>must</code> is more formal, making the code feel more like
a written specification.</p><p><a name="checkingEqualityWithMatchers"></a></p><h4> Checking equality with matchers </h4><p>ScalaTest matchers provides five different ways to check equality, each designed to address a different need. They are:</p><p><pre class="stHighlighted">
result should equal (<span class="stLiteral">3</span>) <span class="stLineComment">// can customize equality</span>
result should === (<span class="stLiteral">3</span>)   <span class="stLineComment">// can customize equality and enforce type constraints</span>
result should be (<span class="stLiteral">3</span>)    <span class="stLineComment">// cannot customize equality, so fastest to compile</span>
result shouldEqual <span class="stLiteral">3</span>    <span class="stLineComment">// can customize equality, no parentheses required</span>
result shouldBe <span class="stLiteral">3</span>       <span class="stLineComment">// cannot customize equality, so fastest to compile, no parentheses required</span>
</pre></p><p>The &ldquo;<code>left</code> <code>should</code> <code>equal</code> <code>(right)</code>&rdquo; syntax requires an
<a href="../scalactic/Equality.html"><code>org.scalactic.Equality[L]</code></a> to be provided (either implicitly or explicitly), where
<code>L</code> is the left-hand type on which <code>should</code> is invoked. In the &quot;<code>left</code> <code>should</code> <code>equal</code> <code>(right)</code>&quot; case,
for example, <code>L</code> is the type of <code>left</code>. Thus if <code>left</code> is type <code>Int</code>, the &quot;<code>left</code> <code>should</code>
<code>equal</code> <code>(right)</code>&quot;
statement would require an <code>Equality[Int]</code>.</p><p>By default, an implicit <code>Equality[T]</code> instance is available for any type <code>T</code>, in which equality is implemented
by simply invoking <code>==</code>  on the <code>left</code>
value, passing in the <code>right</code> value, with special treatment for arrays. If either <code>left</code> or <code>right</code> is an array, <code>deep</code>
will be invoked on it before comparing with <em>==</em>. Thus, the following expression
will yield false, because <code>Array</code>'s <code>equals</code> method compares object identity:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) == <span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) <span class="stLineComment">// yields false</span>
</pre></p><p>The next expression will by default <em>not</em> result in a <code>TestFailedException</code>, because default <code>Equality[Array[Int]]</code> compares
the two arrays structurally, taking into consideration the equality of the array's contents:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) should equal (<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)) <span class="stLineComment">// succeeds (i.e., does not throw TestFailedException)</span>
</pre></p><p>If you ever do want to verify that two arrays are actually the same object (have the same identity), you can use the
<code>be theSameInstanceAs</code> syntax, <a href="#checkingObjectIdentity">described below</a>.</p><p>You can customize the meaning of equality for a type when using &quot;<code>should</code> <code>equal</code>,&quot; &quot;<code>should</code> <code>===</code>,&quot;
or <code>shouldEqual</code> syntax by defining implicit <code>Equality</code> instances that will be used instead of default <code>Equality</code>.
You might do this to normalize types before comparing them with <code>==</code>, for instance, or to avoid calling the <code>==</code> method entirely,
such as if you want to compare <code>Double</code>s with a tolerance.
For an example, see the main documentation of <a href="../scalactic/Equality.html">trait <code>Equality</code></a>.</p><p>You can always supply implicit parameters explicitly, but in the case of implicit parameters of type <code>Equality[T]</code>, Scalactic provides a
simple &quot;explicitly&quot; DSL. For example, here's how you could explicitly supply an <code>Equality[String]</code> instance that normalizes both left and right
sides (which must be strings), by transforming them to lowercase:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; import org.scalactic.Explicitly._
import org.scalactic.Explicitly._

scala&gt; import org.scalactic.StringNormalizations._
import org.scalactic.StringNormalizations._

scala&gt; "Hi" should equal ("hi") (after being lowerCased)
</pre></p><p>The <code>after</code> <code>being</code> <code>lowerCased</code> expression results in an <code>Equality[String]</code>, which is then passed
explicitly as the second curried parameter to <code>equal</code>. For more information on the explicitly DSL, see the main documentation
for trait <a href="../scalactic/Explicitly.html"><code>Explicitly</code></a>.</p><p>The &quot;<code>should</code> <code>be</code>&quot; and <code>shouldBe</code> syntax do not take an <code>Equality[T]</code> and can therefore not be customized.
They always use the default approach to equality described above. As a result, &quot;<code>should</code> <code>be</code>&quot; and <code>shouldBe</code> will
likely be the fastest-compiling matcher syntax for equality comparisons, since the compiler need not search for
an implicit <code>Equality[T]</code> each time.</p><p>The <code>should</code> <code>===</code> syntax (and its complement, <code>should</code> <code>!==</code>) can be used to enforce type
constraints at compile-time between the left and right sides of the equality comparison. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; import org.scalactic.TypeCheckedTripleEquals._
import org.scalactic.TypeCheckedTripleEquals._

scala&gt; Some(2) should === (2)
&lt;console&gt;:17: error: types Some[Int] and Int do not adhere to the equality constraint
selected for the === and !== operators; the missing implicit parameter is of
type org.scalactic.CanEqual[Some[Int],Int]
              Some(2) should === (2)
                      ^
</pre></p><p>By default, the &quot;<code>Some(2)</code> <code>should</code> <code>===</code> <code>(2)</code>&quot; statement would fail at runtime. By mixing in
the equality constraints provided by <code>TypeCheckedTripleEquals</code>, however, the statement fails to compile. For more information
and examples, see the main documentation for <a href="../scalactic/TypeCheckedTripleEquals.html">trait <code>TypeCheckedTripleEquals</code></a>.</p><p><a name="checkingSizeAndLength"></a></p><h4> Checking size and length </h4><p>You can check the size or length of any type of object for which it
makes sense. Here's how checking for length looks:</p><p><pre class="stHighlighted">
result should have length <span class="stLiteral">3</span>
</pre></p><p>Size is similar:</p><p><pre class="stHighlighted">
result should have size <span class="stLiteral">10</span>
</pre></p><p>The <code>length</code> syntax can be used with <code>String</code>, <code>Array</code>, any <code>scala.collection.GenSeq</code>,
any <code>java.util.List</code>, and any type <code>T</code> for which an implicit <code>Length[T]</code> type class is
available in scope.
Similarly, the <code>size</code> syntax can be used with <code>Array</code>, any <code>scala.collection.GenTraversable</code>,
any <code>java.util.Collection</code>, any <code>java.util.Map</code>, and any type <code>T</code> for which an implicit <code>Size[T]</code> type class is
available in scope. You can enable the <code>length</code> or <code>size</code> syntax for your own arbitrary types, therefore,
by defining <a href="enablers/Length.html"><code>Length</code></a> or <a href="enablers/Size.html"><code>Size</code></a> type
classes for those types.</p><p>In addition, the <code>length</code> syntax can be used with any object that has a field or method named <code>length</code>
or a method named <code>getLength</code>.   Similarly, the <code>size</code> syntax can be used with any
object that has a field or method named <code>size</code> or a method named <code>getSize</code>.
The type of a <code>length</code> or <code>size</code> field, or return type of a method, must be either <code>Int</code>
or <code>Long</code>. Any such method must take no parameters. (The Scala compiler will ensure at compile time that
the object on which <code>should</code> is being invoked has the appropriate structure.)</p><p><a name="checkingStrings"></a></p><h4> Checking strings </h4><p>You can check for whether a string starts with, ends with, or includes a substring like this:</p><p><pre class="stHighlighted">
string should startWith (<span class="stQuotedString">"Hello"</span>)
string should endWith (<span class="stQuotedString">"world"</span>)
string should include (<span class="stQuotedString">"seven"</span>)
</pre></p><p>You can check for whether a string starts with, ends with, or includes a regular expression, like this:</p><p><pre class="stHighlighted">
string should startWith regex <span class="stQuotedString">"Hel*o"</span>
string should endWith regex <span class="stQuotedString">"wo.ld"</span>
string should include regex <span class="stQuotedString">"wo.ld"</span>
</pre></p><p>And you can check whether a string fully matches a regular expression, like this:</p><p><pre class="stHighlighted">
string should fullyMatch regex <span class="stQuotedString">"""(-)?(\d+)(\.\d*)?"""</span>
</pre></p><p>The regular expression passed following the <code>regex</code> token can be either a <code>String</code>
or a <code>scala.util.matching.Regex</code>.</p><p>With the <code>startWith</code>, <code>endWith</code>, <code>include</code>, and <code>fullyMatch</code>
tokens can also be used with an optional specification of required groups, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"abbccxxx"</span> should startWith regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"xxxabbcc"</span> should endWith regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"xxxabbccxxx"</span> should include regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"abbcc"</span> should fullyMatch regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
</pre></p><p>You can check whether a string is empty with <code>empty</code>:</p><p><pre class="stHighlighted">
s shouldBe empty
</pre></p><p>You can also use most of ScalaTest's matcher syntax for collections on <code>String</code> by
treating the <code>String</code>s as collections of characters. For examples, see the
<a href="#stringsAndArraysAsCollections"><code>String</code>s and <code>Array</code>s as collections</a> section below.</p><p><a name="greaterAndLessThan"></a></p><h4> Greater and less than </h4><p>You can check whether any type for which an implicit <code>Ordering[T]</code> is available
is greater than, less than, greater than or equal, or less
than or equal to a value of type <code>T</code>. The syntax is:</p><p><pre class="stHighlighted">
one should be &lt; <span class="stLiteral">7</span>
one should be &gt; <span class="stLiteral">0</span>
one should be &lt;= <span class="stLiteral">7</span>
one should be &gt;= <span class="stLiteral">0</span>
</pre></p><p><a name="checkingBooleanPropertiesWithBe"></a></p><h4> Checking <code>Boolean</code> properties with <code>be</code> </h4><p>If an object has a method that takes no parameters and returns boolean, you can check
it by placing a <code>Symbol</code> (after <code>be</code>) that specifies the name
of the method (excluding an optional prefix of &quot;<code>is</code>&quot;). A symbol literal
in Scala begins with a tick mark and ends at the first non-identifier character. Thus,
<code>'traversableAgain</code> results in a <code>Symbol</code> object at runtime, as does
<code>'completed</code> and <code>'file</code>. Here's an example:</p><p><pre class="stHighlighted">
iter shouldBe <span class="stQuotedString">'traversableAgain</span>
</pre></p><p>Given this code, ScalaTest will use reflection to look on the object referenced from
<code>emptySet</code> for a method that takes no parameters and results in <code>Boolean</code>,
with either the name <code>empty</code> or <code>isEmpty</code>. If found, it will invoke
that method. If the method returns <code>true</code>, execution will continue. But if it returns
<code>false</code>, a <code>TestFailedException</code> will be thrown that will contain a detail message, such as:</p><p><pre class="stHighlighted">
non-empty iterator was not traversableAgain
</pre></p><p>This <code>be</code> syntax can be used with any reference (<code>AnyRef</code>) type.  If the object does
not have an appropriately named predicate method, you'll get a <code>TestFailedException</code>
at runtime with a detailed message that explains the problem.
(For the details on how a field or method is selected during this
process, see the documentation for <a href="words/BeWord.html"><code>BeWord</code></a>.)</p><p>If you think it reads better, you can optionally put <code>a</code> or <code>an</code> after
<code>be</code>. For example, <code>java.io.File</code> has two predicate methods,
<code>isFile</code> and <code>isDirectory</code>. Thus with a <code>File</code> object
named <code>temp</code>, you could write:</p><p><pre class="stHighlighted">
temp should be a <span class="stQuotedString">'file</span>
</pre></p><p>Or, given <code>java.awt.event.KeyEvent</code> has a method <code>isActionKey</code> that takes
no arguments and returns <code>Boolean</code>, you could assert that a <code>KeyEvent</code> is
an action key with:</p><p><pre class="stHighlighted">
keyEvent should be an <span class="stQuotedString">'actionKey</span>
</pre></p><p>If you prefer to check <code>Boolean</code> properties in a type-safe manner, you can use a <code>BePropertyMatcher</code>.
This would allow you to write expressions such as:</p><p><pre class="stHighlighted">
xs shouldBe traversableAgain
temp should be a file
keyEvent should be an actionKey
</pre></p><p>These expressions would fail to compile if <code>should</code> is used on an inappropriate type, as determined
by the type parameter of the <code>BePropertyMatcher</code> being used. (For example, <code>file</code> in this example
would likely be of type <code>BePropertyMatcher[java.io.File]</code>. If used with an appropriate type, such an expression will compile
and at run time the <code>Boolean</code> property method or field will be accessed directly; <em>i.e.</em>, no reflection will be used.
See the documentation for <a href="matchers/BePropertyMatcher.html"><code>BePropertyMatcher</code></a> for more information.</p><p><a name="usingCustomBeMatchers"></a></p><h4> Using custom <code>BeMatchers</code> </h4><p>If you want to create a new way of using <code>be</code>, which doesn't map to an actual property on the
type you care about, you can create a <code>BeMatcher</code>. You could use this, for example, to create <code>BeMatcher[Int]</code>
called <code>odd</code>, which would match any odd <code>Int</code>, and <code>even</code>, which would match
any even <code>Int</code>.
Given this pair of <code>BeMatcher</code>s, you could check whether an <code>Int</code> was odd or even with expressions like:</p><p><pre class="stHighlighted">
num shouldBe odd
num should not be even
</pre></p><p>For more information, see the documentation for <a href="matchers/BeMatcher.html"><code>BeMatcher</code></a>.</p><p><a name="checkingObjectIdentity"></a></p><h4> Checking object identity </h4><p>If you need to check that two references refer to the exact same object, you can write:</p><p><pre class="stHighlighted">
ref1 should be theSameInstanceAs ref2
</pre></p><p><a name="checkingAnObjectsClass"></a></p><h4> Checking an object's class </h4><p>If you need to check that an object is an instance of a particular class or trait, you can supply the type to
&ldquo;<code>be</code> <code>a</code>&rdquo; or &ldquo;<code>be</code> <code>an</code>&rdquo;:</p><p><pre class="stHighlighted">
result1 shouldBe a [<span class="stType">Tiger</span>]
result1 should not be an [<span class="stType">Orangutan</span>]
</pre></p><p>Because type parameters are erased on the JVM, we recommend you insert an underscore for any type parameters
when using this syntax. Both of the following test only that the result is an instance of <code>List[_]</code>, because at
runtime the type parameter has been erased:</p><p><pre class="stHighlighted">
result shouldBe a [<span class="stType">List[_]</span>] <span class="stLineComment">// recommended</span>
result shouldBe a [<span class="stType">List[Fruit]</span>] <span class="stLineComment">// discouraged</span>
</pre></p><p><a name="checkingNumbersAgainstARange"></a></p><h4> Checking numbers against a range </h4><p>Often you may want to check whether a number is within a
range. You can do that using the <code>+-</code> operator, like this:</p><p><pre class="stHighlighted">
sevenDotOh should equal (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh should === (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh should be (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh shouldEqual <span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>
sevenDotOh shouldBe <span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>
</pre></p><p>Any of these expressions will cause a <code>TestFailedException</code> to be thrown if the floating point
value, <code>sevenDotOh</code> is outside the range <code>6.7</code> to <code>7.1</code>.
You can use <code>+-</code> with any type <code>T</code> for which an implicit <code>Numeric[T]</code> exists, such as integral types:</p><p><pre class="stHighlighted">
seven should equal (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven should === (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven should be (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven shouldEqual <span class="stLiteral">6</span> +- <span class="stLiteral">2</span>
seven shouldBe <span class="stLiteral">6</span> +- <span class="stLiteral">2</span>
</pre></p><p><a name="checkingForEmptiness"></a></p><h4> Checking for emptiness </h4><p>You can check whether an object is &quot;empty&quot;, like this:</p><p><pre class="stHighlighted">
traversable shouldBe empty
javaMap should not be empty
</pre></p><p>The <code>empty</code> token can be used with any type <code>L</code> for which an implicit <code>Emptiness[L]</code> exists.
The <code>Emptiness</code> companion object provides implicits for <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>, and <code>Option[E]</code>. In addition, the
<code>Emptiness</code> companion object provides structural implicits for types that declare an <code>isEmpty</code> method that
returns a <code>Boolean</code>. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; List.empty shouldBe empty

scala&gt; None shouldBe empty

scala&gt; Some(1) should not be empty

scala&gt; "" shouldBe empty

scala&gt; new java.util.HashMap[Int, Int] shouldBe empty

scala&gt; new { def isEmpty = true} shouldBe empty

scala&gt; Array(1, 2, 3) should not be empty
</pre></p><p><a name="workingWithContainers"></a></p><h4> Working with &quot;containers&quot; </h4><p>You can check whether a collection contains a particular element like this:</p><p><pre class="stHighlighted">
traversable should contain (<span class="stQuotedString">"five"</span>)
</pre></p><p>The <code>contain</code> syntax shown above can be used with any type <code>C</code> that has a &quot;containing&quot; nature, evidenced by
an implicit <code>org.scalatest.enablers.Containing[L]</code>, where <code>L</code> is left-hand type on
which <code>should</code> is invoked. In the <code>Containing</code>
companion object, implicits are provided for types <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>, and <code>Option[E]</code>.
Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; List(1, 2, 3) should contain (2)

scala&gt; Map('a' -&gt; 1, 'b' -&gt; 2, 'c' -&gt; 3) should contain ('b' -&gt; 2)

scala&gt; Set(1, 2, 3) should contain (2)

scala&gt; Array(1, 2, 3) should contain (2)

scala&gt; "123" should contain ('2')

scala&gt; Some(2) should contain (2)
</pre></p><p>ScalaTest's implicit methods that provide the <code>Containing[L]</code> type classes require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Containing[Array[Int]]</code> you must supply an <code>Equality[Int]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Containing[L]</code>,
implicit conversions are provided in the <code>Containing</code> companion object from <code>Equality[E]</code> to the various
types of containers of <code>E</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; List("Hi", "Di", "Ho") should contain ("ho")
org.scalatest.exceptions.TestFailedException: List(Hi, Di, Ho) did not contain element "ho"
        at ...

scala&gt; import org.scalactic.Explicitly._
import org.scalactic.Explicitly._

scala&gt; import org.scalactic.StringNormalizations._
import org.scalactic.StringNormalizations._

scala&gt; (List("Hi", "Di", "Ho") should contain ("ho")) (after being lowerCased)
</pre></p><p>Note that when you use the explicitly DSL with <code>contain</code> you need to wrap the entire
<code>contain</code> expression in parentheses, as shown here.</p><p><pre>
(List("Hi", "Di", "Ho") should contain ("ho")) (after being lowerCased)
^                                            ^
</pre></p><p>In addition to determining whether an object contains another object, you can use <code>contain</code> to
make other determinations.
For example, the <code>contain</code> <code>oneOf</code> syntax ensures that one and only one of the specified elements are
contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) should contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"howdy"</span> should contain oneOf (<span class="stQuotedString">'a'</span>, <span class="stQuotedString">'b'</span>, <span class="stQuotedString">'c'</span>, <span class="stQuotedString">'d'</span>)
</pre></p><p>Note that if multiple specified elements appear in the containing object, <code>oneOf</code> will fail:</p><p><pre class="stREPL">
scala&gt; List(1, 2, 3) should contain oneOf (2, 3, 4)
org.scalatest.exceptions.TestFailedException: List(1, 2, 3) did not contain one (and only one) of (2, 3, 4)
        at ...
</pre></p><p>If you really want to ensure one or more of the specified elements are contained in the containing object,
use <code>atLeastOneOf</code>, described below, instead of <code>oneOf</code>. Keep in mind, <code>oneOf</code>
means &quot;<em>exactly</em> one of.&quot;</p><p>Note also that with any <code>contain</code> syntax, you can place custom implicit <code>Equality[E]</code> instances in scope
to customize how containership is determined, or use the explicitly DSL. Here's an example:</p><p><pre class="stHighlighted">
(<span class="stType">Array</span>(<span class="stQuotedString">"Doe"</span>, <span class="stQuotedString">"Ray"</span>, <span class="stQuotedString">"Me"</span>) should contain oneOf (<span class="stQuotedString">"X"</span>, <span class="stQuotedString">"RAY"</span>, <span class="stQuotedString">"BEAM"</span>)) (after being lowerCased)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;one of&quot; comparison, you can use &quot;oneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain oneElementOf <span class="stType">List</span>(<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) should contain oneElementOf <span class="stType">Vector</span>(<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"howdy"</span> should contain oneElementOf <span class="stType">Set</span>(<span class="stQuotedString">'a'</span>, <span class="stQuotedString">'b'</span>, <span class="stQuotedString">'c'</span>, <span class="stQuotedString">'d'</span>)
(<span class="stType">Array</span>(<span class="stQuotedString">"Doe"</span>, <span class="stQuotedString">"Ray"</span>, <span class="stQuotedString">"Me"</span>) should contain oneElementOf <span class="stType">List</span>(<span class="stQuotedString">"X"</span>, <span class="stQuotedString">"RAY"</span>, <span class="stQuotedString">"BEAM"</span>)) (after being lowerCased)
</pre></p><p>The <code>contain</code> <code>noneOf</code> syntax does the opposite of <code>oneOf</code>: it ensures none of the specified elements
are contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) should contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"12345"</span> should contain noneOf (<span class="stQuotedString">'7'</span>, <span class="stQuotedString">'8'</span>, <span class="stQuotedString">'9'</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;none of&quot; comparison, you can use &quot;noElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain noElementsOf <span class="stType">List</span>(<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) should contain noElementsOf <span class="stType">Vector</span>(<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"12345"</span> should contain noElementsOf <span class="stType">Set</span>(<span class="stQuotedString">'7'</span>, <span class="stQuotedString">'8'</span>, <span class="stQuotedString">'9'</span>)
</pre></p><p><a name="workingWithAggregations"></a></p><h4> Working with &quot;aggregations&quot; </h4><p>As mentioned, the &quot;<code>contain</code>,&quot;  &quot;<code>contain</code> <code>oneOf</code>,&quot; and &quot;<code>contain</code> <code>noneOf</code>&quot; syntax requires a
<code>Containing[L]</code> be provided, where <code>L</code> is the left-hand type.  Other <code>contain</code> syntax, which
will be described in this section, requires an <code>Aggregating[L]</code> be provided, where again <code>L</code> is the left-hand type.
(An <code>Aggregating[L]</code> instance defines the &quot;aggregating nature&quot; of a type <code>L</code>.)
The reason, essentially, is that <code>contain</code> syntax that makes sense for <code>Option</code> is enabled by
<code>Containing[L]</code>, whereas syntax that does <em>not</em> make sense for <code>Option</code> is enabled
by <code>Aggregating[L]</code>. For example, it doesn't make sense to assert that an <code>Option[Int]</code> contains all of a set of integers, as it
could only ever contain one of them. But this does make sense for a type such as <code>List[Int]</code> that can aggregate zero to many integers.</p><p>The <code>Aggregating</code> companion object provides implicit instances of <code>Aggregating[L]</code>
for types <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>. Note that these are the same types as are supported with
<code>Containing</code>, but with <code>Option[E]</code> missing.
Here are some examples:</p><p>The <code>contain</code> <code>atLeastOneOf</code> syntax, for example, works for any type <code>L</code> for which an <code>Aggregating[L]</code> exists. It ensures
that at least one of (<em>i.e.</em>, one or more of) the specified objects are contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) should contain atLeastOneOf (<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>)
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) should contain atLeastOneOf (<span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>)
<span class="stQuotedString">"abc"</span> should contain atLeastOneOf (<span class="stQuotedString">'c'</span>, <span class="stQuotedString">'a'</span>, <span class="stQuotedString">'t'</span>)
</pre></p><p>Similar to <code>Containing[L]</code>, the implicit methods that provide the <code>Aggregating[L]</code> instances require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Aggregating[Vector[String]]</code> you must supply an <code>Equality[String]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Aggregating[L]</code>,
implicit conversions are provided in the <code>Aggregating</code> companion object from <code>Equality[E]</code> to the various
types of aggregations of <code>E</code>. Here's an example:</p><p><pre class="stHighlighted">
(<span class="stType">Vector</span>(<span class="stQuotedString">" A"</span>, <span class="stQuotedString">"B "</span>) should contain atLeastOneOf (<span class="stQuotedString">"a "</span>, <span class="stQuotedString">"b"</span>, <span class="stQuotedString">"c"</span>)) (after being lowerCased and trimmed)
</pre></p><p>If you have a collection of elements that you'd like to use in an &quot;at least one of&quot; comparison, you can use &quot;atLeastOneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) should contain atLeastOneElementOf <span class="stType">List</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>)
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) should contain atLeastOneElementOf <span class="stType">Vector</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>)
<span class="stQuotedString">"abc"</span> should contain atLeastOneElementOf <span class="stType">Set</span>(<span class="stQuotedString">'c'</span>, <span class="stQuotedString">'a'</span>, <span class="stQuotedString">'t'</span>)
(<span class="stType">Vector</span>(<span class="stQuotedString">" A"</span>, <span class="stQuotedString">"B "</span>) should contain atLeastOneElementOf <span class="stType">List</span>(<span class="stQuotedString">"a "</span>, <span class="stQuotedString">"b"</span>, <span class="stQuotedString">"c"</span>)) (after being lowerCased and trimmed)
</pre></p><p>The &quot;<code>contain</code> <code>atMostOneOf</code>&quot; syntax lets you specify a set of objects at most one of which should be contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain atMostOneOf (<span class="stLiteral">5</span>, <span class="stLiteral">6</span>, <span class="stLiteral">7</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;at most one of&quot; comparison, you can use &quot;atMostOneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain atMostOneElementOf <span class="stType">Vector</span>(<span class="stLiteral">5</span>, <span class="stLiteral">6</span>, <span class="stLiteral">7</span>)
</pre></p><p>The &quot;<code>contain</code> <code>allOf</code>&quot; syntax lets you specify a set of objects that should all be contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain allOf (<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;all of&quot; comparison, you can use &quot;allElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) should contain allElementsOf <span class="stType">Array</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>)
</pre></p><p>The &quot;<code>contain</code> <code>only</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects, though it may
contain more than one of each:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">1</span>) should contain only (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The &quot;<code>contain</code> <code>theSameElementsAs</code>&quot; and &quot;<code>contain</code> <code>theSameElementsInOrderAs</code> syntax differ from the others
in that the right hand side is a <code>GenTraversable[_]</code> rather than a varargs of <code>Any</code>. (Note: in a future 2.0 milestone release, possibly
2.0.M6, these will likely be widened to accept any type <code>R</code> for which an <code>Aggregating[R]</code> exists.)</p><p>The &quot;<code>contain</code> <code>theSameElementsAs</code>&quot; syntax lets you assert that two aggregations contain the same objects:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>) should contain theSameElementsAs <span class="stType">Vector</span>(<span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The number of times any family of equal objects appears must also be the same in both the left and right aggregations.
The specified objects may appear multiple times, but must appear in the order they appear in the right-hand list. For example, if
the last 3 element is left out of the right-hand list in the previous example, the expression would fail because the left side
has three 3's and the right hand side has only two:</p><p><pre class="stREPL">
List(1, 2, 2, 3, 3, 3) should contain theSameElementsAs Vector(3, 2, 3, 1, 2)
org.scalatest.exceptions.TestFailedException: List(1, 2, 2, 3, 3, 3) did not contain the same elements as Vector(3, 2, 3, 1, 2)
        at ...
</pre></p><p>Note that no <code>onlyElementsOf</code> matcher is provided, because it would have the same
behavior as <code>theSameElementsAs</code>. (<em>I.e.</em>, if you were looking for <code>onlyElementsOf</code>, please use <code>theSameElementsAs</code>
instead.)</p><p><a name="workingWithSequences"></a></p><h4> Working with &quot;sequences&quot; </h4><p>The rest of the <code>contain</code> syntax, which
will be described in this section, requires a <code>Sequencing[L]</code> be provided, where again <code>L</code> is the left-hand type.
(A <code>Sequencing[L]</code> instance defines the &quot;sequencing nature&quot; of a type <code>L</code>.)
The reason, essentially, is that <code>contain</code> syntax that implies an &quot;order&quot; of elements makes sense only for types that place elements in a sequence.
For example, it doesn't make sense to assert that a <code>Map[String, Int]</code> or <code>Set[Int]</code> contains all of a set of integers in a particular
order, as these types don't necessarily define an order for their elements. But this does make sense for a type such as <code>Seq[Int]</code> that does define
an order for its elements.</p><p>The <code>Sequencing</code> companion object provides implicit instances of <code>Sequencing[L]</code>
for types <code>GenSeq[E]</code>, <code>java.util.List[E]</code>,
<code>String</code>, and <code>Array[E]</code>.
Here are some examples:</p><p>Similar to <code>Containing[L]</code>, the implicit methods that provide the <code>Aggregating[L]</code> instances require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Aggregating[Vector[String]]</code> you must supply an <code>Equality[String]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Aggregating[L]</code>,
implicit conversions are provided in the <code>Aggregating</code> companion object from <code>Equality[E]</code> to the various
types of aggregations of <code>E</code>. Here's an example:</p><p>The &quot;<code>contain</code> <code>inOrderOnly</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects, in order.
The specified objects may appear multiple times, but must appear in the order they appear in the right-hand list. Here's an example:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>) should contain inOrderOnly (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The &quot;<code>contain</code> <code>inOrder</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects in order, like
<code>inOrderOnly</code>, but allows other objects to appear in the left-hand aggregation as well:
contain more than one of each:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">0</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">99</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>) should contain inOrder (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;in order&quot; comparison, you can use &quot;inOrderElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">0</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">99</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>) should contain inOrderElementsOf <span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that &quot;order&quot; in <code>inOrder</code>, <code>inOrderOnly</code>, and <code>theSameElementsInOrderAs</code> (described below)
in the <code>Aggregation[L]</code> instances built-in to ScalaTest is defined as &quot;iteration order&quot;.</p><p>Lastly, the &quot;<code>contain</code> <code>theSameElementsInOrderAs</code>&quot; syntax lets you assert that two aggregations contain
the same exact elements in the same (iteration) order:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) should contain theSameElementsInOrderAs <span class="stType">collection.mutable.TreeSet</span>(<span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">1</span>)
</pre></p><p>The previous assertion succeeds because the iteration order of a<code>TreeSet</code> is the natural
ordering of its elements, which in this case is 1, 2, 3. An iterator obtained from the left-hand <code>List</code> will produce the same elements
in the same order.</p><p>Note that no <code>inOrderOnlyElementsOf</code> matcher is provided, because it would have the same
behavior as <code>theSameElementsInOrderAs</code>. (<em>I.e.</em>, if you were looking for <code>inOrderOnlyElementsOf</code>, please use <code>theSameElementsInOrderAs</code>
instead.)</p><p><a name="workingWithSortables"></a></p><h4> Working with &quot;sortables&quot; </h4><p>You can also ask whether the elements of &quot;sortable&quot; objects (such as <code>Array</code>s, Java <code>List</code>s, and <code>GenSeq</code>s)
are in sorted order, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) shouldBe sorted
</pre></p><p><a name="workingWithIterators"></a></p><h4> Working with iterators </h4><p>Although it seems desirable to provide similar matcher syntax for Scala and Java iterators to that provided for sequences like
<code>Seq</code>s, <code>Array</code>, and <code>java.util.List</code>, the
ephemeral nature of iterators makes this problematic. Some syntax (such as <code>should</code> <code>contain</code>) is relatively straightforward to
support on iterators, but other syntax (such
as, for example, <code>Inspector</code> expressions on nested iterators) is not. Rather
than allowing inconsistencies between sequences and iterators in the API, we chose to not support any such syntax directly on iterators:</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> it = <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).iterator
it: <span class="stType">Iterator[Int]</span> = non-empty iterator
<br/>scala&gt; it should contain (<span class="stLiteral">2</span>)
&lt;console&gt;:<span class="stLiteral">15</span>: error: could not find <span class="stReserved">implicit</span> value <span class="stReserved">for</span> parameter typeClass1: <span class="stType">org.scalatest.enablers.Containing[Iterator[Int]]</span>
           it should contain (<span class="stLiteral">2</span>)
              ^
</pre></p><p>Instead, you will need to convert your iterators to a sequence explicitly before using them in matcher expressions:</p><p><pre class="stHighlighted">
scala&gt; it.toStream should contain (<span class="stLiteral">2</span>)
</pre></p><p>We recommend you convert (Scala or Java) iterators to <code>Stream</code>s, as shown in the previous example, so that you can
continue to reap any potential benefits provided by the laziness of the underlying iterator.</p><p><a name="inspectorShorthands"></a></p><h4> Inspector shorthands </h4><p>You can use the <a href="Inspectors.html"><code>Inspectors</code></a> syntax with matchers as well as assertions. If you have a multi-dimensional collection, such as a
list of lists, using <code>Inspectors</code> is your best option:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> yss =
  <span class="stType">List</span>(
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>),
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>),
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
  )
<br/>forAll (yss) { ys =&gt;
  forAll (ys) { y =&gt; y should be &gt; <span class="stLiteral">0</span> }
}
</pre></p><p>For assertions on one-dimensional collections, however, matchers provides &quot;inspector shorthands.&quot; Instead of writing:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> xs = <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
forAll (xs) { x =&gt; x should be &lt; <span class="stLiteral">10</span> }
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
all (xs) should be &lt; <span class="stLiteral">10</span>
</pre></p><p>The previous statement asserts that all elements of the <code>xs</code> list should be less than 10.
All of the inspectors have shorthands in matchers. Here is the full list:</p><ul><li><code>all</code> - succeeds if the assertion holds true for every element</li><li><code>atLeast</code> - succeeds if the assertion holds true for at least the specified number of elements</li><li><code>atMost</code> - succeeds if the assertion holds true for at most the specified number of elements</li><li><code>between</code> - succeeds if the assertion holds true for between the specified minimum and maximum number of elements, inclusive</li><li><code>every</code> - same as <code>all</code>, but lists all failing elements if it fails (whereas <code>all</code> just reports the first failing element)</li><li><code>exactly</code> - succeeds if the assertion holds true for exactly the specified number of elements</li></ul><p>Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.Matchers._
import org.scalatest.Matchers._

scala&gt; val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; all (xs) should be &gt; 0

scala&gt; atMost (2, xs) should be &gt;= 4

scala&gt; atLeast (3, xs) should be &lt; 5

scala&gt; between (2, 3, xs) should (be &gt; 1 and be &lt; 5)

scala&gt; exactly (2, xs) should be &lt;= 2

scala&gt; every (xs) should be &lt; 10

scala&gt; // And one that fails...

scala&gt; exactly (2, xs) shouldEqual 2
org.scalatest.exceptions.TestFailedException: 'exactly(2)' inspection failed, because only 1 element
    satisfied the assertion block at index 1:
  at index 0, 1 did not equal 2,
  at index 2, 3 did not equal 2,
  at index 3, 4 did not equal 2,
  at index 4, 5 did not equal 2
in List(1, 2, 3, 4, 5)
        at ...
</pre></p><p>Like <a href=""><code>Inspectors</code></a>, objects used with inspector shorthands can be any type <code>T</code> for which a <code>Collecting[T, E]</code>
is available, which by default includes <code>GenTraversable</code>,
Java <code>Collection</code>, Java <code>Map</code>, <code>Array</code>s, and <code>String</code>s.
Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Matchers._
import Matchers._

scala&gt; all (Array(1, 2, 3)) should be &lt; 5

scala&gt; import collection.JavaConverters._
import collection.JavaConverters._

scala&gt; val js = List(1, 2, 3).asJava
js: java.util.List[Int] = [1, 2, 3]

scala&gt; all (js) should be &lt; 5

scala&gt; val jmap = Map("a" -&gt; 1, "b" -&gt; 2).asJava
jmap: java.util.Map[String,Int] = {a=1, b=2}

scala&gt; atLeast(1, jmap) shouldBe Entry("b", 2)

scala&gt; atLeast(2, "hello, world!") shouldBe 'o'
</pre></p><p><a name="singleElementCollections"></a></p><h4> Single-element collections </h4><p>To assert both that a collection contains just one &quot;lone&quot; element as well as something else about that element, you can use
the <code>loneElement</code> syntax provided by trait <a href="LoneElement.html"><code>LoneElement</code></a>. For example, if a
<code>Set[Int]</code> should contain just one element, an <code>Int</code>
less than or equal to 10, you could write:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> LoneElement._
set.loneElement should be &lt;= <span class="stLiteral">10</span>
</pre></p><p>You can invoke <code>loneElement</code> on any type <code>T</code> for which an implicit <a href="enablers/Collecting.html"><code>Collecting[E, T]</code></a>
is available, where <code>E</code> is the element type returned by the <code>loneElement</code> invocation. By default, you can use <code>loneElement</code>
on <code>GenTraversable</code>, Java <code>Collection</code>, Java <code>Map</code>, <code>Array</code>, and <code>String</code>.</p><p><a name="javaCollectionsAndMaps"></a></p><h4> Java collections and maps </h4><p>You can use similar syntax on Java collections (<code>java.util.Collection</code>) and maps (<code>java.util.Map</code>).
For example, you can check whether a Java <code>Collection</code> or <code>Map</code> is <code>empty</code>,
like this:</p><p><pre class="stHighlighted">
javaCollection should be (<span class="stQuotedString">'empty</span>)
javaMap should be (<span class="stQuotedString">'empty</span>)
</pre></p><p>Even though Java's <code>List</code> type doesn't actually have a <code>length</code> or <code>getLength</code> method,
you can nevertheless check the length of a Java <code>List</code> (<code>java.util.List</code>) like this:</p><p><pre class="stHighlighted">
javaList should have length <span class="stLiteral">9</span>
</pre></p><p>You can check the size of any Java <code>Collection</code> or <code>Map</code>, like this:</p><p><pre class="stHighlighted">
javaMap should have size <span class="stLiteral">20</span>
javaSet should have size <span class="stLiteral">90</span>
</pre></p><p>In addition, you can check whether a Java <code>Collection</code> contains a particular
element, like this:</p><p><pre class="stHighlighted">
javaCollection should contain (<span class="stQuotedString">"five"</span>)
</pre></p><p>One difference to note between the syntax supported on Java and Scala collections is that
in Java, <code>Map</code> is not a subtype of <code>Collection</code>, and does not
actually define an element type. You can ask a Java <code>Map</code> for an &quot;entry set&quot;
via the <code>entrySet</code> method, which will return the <code>Map</code>'s key/value pairs
wrapped in a set of <code>java.util.Map.Entry</code>, but a <code>Map</code> is not actually
a collection of <code>Entry</code>. To make Java <code>Map</code>s easier to work with, however,
ScalaTest matchers allows you to treat a Java <code>Map</code> as a collection of <code>Entry</code>,
and defines a convenience implementation of <code>java.util.Map.Entry</code> in
<a href="Entry.html"><code>org.scalatest.Entry</code></a>. Here's how you use it:</p><p><pre class="stHighlighted">
javaMap should contain (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>))
javaMap should contain oneOf (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>), <span class="stType">Entry</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>))
</pre></p><p>You can also just check whether a Java <code>Map</code> contains a particular key, or value, like this:</p><p><pre class="stHighlighted">
javaMap should contain key <span class="stLiteral">1</span>
javaMap should contain value <span class="stQuotedString">"Howdy"</span>
</pre></p><p><a name="stringsAndArraysAsCollections"></a></p><h4> <code>String</code>s and <code>Array</code>s as collections </h4><p>You can also use all the syntax described above for Scala and Java collections on <code>Array</code>s and
<code>String</code>s. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Matchers._
import Matchers._

scala&gt; atLeast (2, Array(1, 2, 3)) should be &gt; 1

scala&gt; atMost (2, "halloo") shouldBe 'o'

scala&gt; Array(1, 2, 3) shouldBe sorted

scala&gt; "abcdefg" shouldBe sorted

scala&gt; Array(1, 2, 3) should contain atMostOneOf (3, 4, 5)

scala&gt; "abc" should contain atMostOneOf ('c', 'd', 'e')
</pre></p><p><a name="beAsAnEqualityComparison"></a></p><h4> <code>be</code> as an equality comparison </h4><p>All uses of <code>be</code> other than those shown previously perform an equality comparison. They work
the same as <code>equal</code> when it is used with default equality. This redundancy between <code>be</code> and <code>equals</code> exists in part
because it enables syntax that sometimes sounds more natural. For example, instead of writing:</p><p><pre class="stHighlighted">
result should equal (<span class="stReserved">null</span>)
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
result should be (<span class="stReserved">null</span>)
</pre></p><p>(Hopefully you won't write that too much given <code>null</code> is error prone, and <code>Option</code>
is usually a better, well, option.)
As mentioned <a href="#checkingEqualityWithMatchers">previously</a>, the other difference between <code>equal</code>
and <code>be</code> is that <code>equal</code> delegates the equality check to an <code>Equality</code> typeclass, whereas
<code>be</code> always uses default equality.
Here are some other examples of <code>be</code> used for equality comparison:</p><p><pre class="stHighlighted">
sum should be (<span class="stLiteral">7.0</span>)
boring should be (<span class="stReserved">false</span>)
fun should be (<span class="stReserved">true</span>)
list should be (<span class="stType">Nil</span>)
option should be (<span class="stType">None</span>)
option should be (<span class="stType">Some</span>(<span class="stLiteral">1</span>))
</pre></p><p>As with <code>equal</code> used with default equality, using <code>be</code> on arrays results in <code>deep</code> being called on both arrays prior to
calling <code>equal</code>. As a result,
the following expression would <em>not</em> throw a <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) should be (<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)) <span class="stLineComment">// succeeds (i.e., does not throw TestFailedException)</span>
</pre></p><p>Because <code>be</code> is used in several ways in ScalaTest matcher syntax, just as it is used in many ways in English, one
potential point of confusion in the event of a failure is determining whether <code>be</code> was being used as an equality comparison or
in some other way, such as a property assertion. To make it more obvious when <code>be</code> is being used for equality, the failure
messages generated for those equality checks will include the word <code>equal</code> in them. For example, if this expression fails with a
<code>TestFailedException</code>:</p><p><pre class="stHighlighted">
option should be (<span class="stType">Some</span>(<span class="stLiteral">1</span>))
</pre></p><p>The detail message in that <code>TestFailedException</code> will include the words <code>"equal to"</code> to signify <code>be</code>
was in this case being used for equality comparison:</p><p><pre class="stHighlighted">
<span class="stType">Some</span>(<span class="stLiteral">2</span>) was not equal to <span class="stType">Some</span>(<span class="stLiteral">1</span>)
</pre></p><p><a name="beingNegative"></a></p><h4> Being negative </h4><p>If you wish to check the opposite of some condition, you can simply insert <code>not</code> in the expression.
Here are a few examples:</p><p><pre class="stHighlighted">
result should not be (<span class="stReserved">null</span>)
sum should not be &lt;= (<span class="stLiteral">10</span>)
mylist should not equal (yourList)
string should not startWith (<span class="stQuotedString">"Hello"</span>)
</pre></p><p><a name="checkingThatCodeDoesNotCompile"></a></p><h4> Checking that a snippet of code does not compile </h4><p>Often when creating libraries you may wish to ensure that certain arrangements of code that
represent potential &ldquo;user errors&rdquo; do not compile, so that your library is more error resistant.
ScalaTest <code>Matchers</code> trait includes the following syntax for that purpose:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: String = 1"</span> shouldNot compile
</pre></p><p>If you want to ensure that a snippet of code does not compile because of a type error (as opposed
to a syntax error), use:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: String = 1"</span> shouldNot typeCheck
</pre></p><p>Note that the <code>shouldNot</code> <code>typeCheck</code> syntax will only succeed if the given snippet of code does not
compile because of a type error. A syntax error will still result in a thrown <code>TestFailedException</code>.</p><p>If you want to state that a snippet of code <em>does</em> compile, you can make that
more obvious with:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: Int = 1"</span> should compile
</pre></p><p>Although the previous three constructs are implemented with macros that determine at compile time whether
the snippet of code represented by the string does or does not compile, errors
are reported as test failures at runtime.</p><p><a name="logicalExpressions"></a></p><h4> Logical expressions with <code>and</code> and <code>or</code> </h4><p>You can also combine matcher expressions with <code>and</code> and/or <code>or</code>, however,
you must place parentheses or curly braces around the <code>and</code> or <code>or</code> expression. For example,
this <code>and</code>-expression would not compile, because the parentheses are missing:</p><p><pre class="stHighlighted">
map should contain key (<span class="stQuotedString">"two"</span>) and not contain value (<span class="stLiteral">7</span>) <span class="stLineComment">// ERROR, parentheses missing!</span>
</pre></p><p>Instead, you need to write:</p><p><pre class="stHighlighted">
map should (contain key (<span class="stQuotedString">"two"</span>) and not contain value (<span class="stLiteral">7</span>))
</pre></p><p>Here are some more examples:</p><p><pre class="stHighlighted">
number should (be &gt; (<span class="stLiteral">0</span>) and be &lt;= (<span class="stLiteral">10</span>))
option should (equal (<span class="stType">Some</span>(<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>))) or be (<span class="stType">None</span>))
string should (
  equal (<span class="stQuotedString">"fee"</span>) or
  equal (<span class="stQuotedString">"fie"</span>) or
  equal (<span class="stQuotedString">"foe"</span>) or
  equal (<span class="stQuotedString">"fum"</span>)
)
</pre></p><p>Two differences exist between expressions composed of these <code>and</code> and <code>or</code> operators and the expressions you can write
on regular <code>Boolean</code>s using its <code>&amp;&amp;</code> and <code>||</code> operators. First, expressions with <code>and</code>
and <code>or</code> do not short-circuit. The following contrived expression, for example, would print <code>"hello, world!"</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"yellow"</span> should (equal (<span class="stQuotedString">"blue"</span>) and equal { println(<span class="stQuotedString">"hello, world!"</span>); <span class="stQuotedString">"green"</span> })
</pre></p><p>In other words, the entire <code>and</code> or <code>or</code> expression is always evaluated, so you'll see any side effects
of the right-hand side even if evaluating
only the left-hand side is enough to determine the ultimate result of the larger expression. Failure messages produced by these
expressions will &quot;short-circuit,&quot; however,
mentioning only the left-hand side if that's enough to determine the result of the entire expression. This &quot;short-circuiting&quot; behavior
of failure messages is intended
to make it easier and quicker for you to ascertain which part of the expression caused the failure. The failure message for the previous
expression, for example, would be:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"yellow"</span> did not equal <span class="stQuotedString">"blue"</span>
</pre></p><p>Most likely this lack of short-circuiting would rarely be noticeable, because evaluating the right hand side will usually not
involve a side effect. One situation where it might show up, however, is if you attempt to <code>and</code> a <code>null</code> check on a variable with an expression
that uses the variable, like this:</p><p><pre class="stHighlighted">
map should (not be (<span class="stReserved">null</span>) and contain key (<span class="stQuotedString">"ouch"</span>))
</pre></p><p>If <code>map</code> is <code>null</code>, the test will indeed fail, but with a <code>NullArgumentException</code>, not a
<code>TestFailedException</code>. Here, the <code>NullArgumentException</code> is the visible right-hand side effect. To get a
<code>TestFailedException</code>, you would need to check each assertion separately:</p><p><pre class="stHighlighted">
map should not be (<span class="stReserved">null</span>)
map should contain key (<span class="stQuotedString">"ouch"</span>)
</pre></p><p>If <code>map</code> is <code>null</code> in this case, the <code>null</code> check in the first expression will fail with
a <code>TestFailedException</code>, and the second expression will never be executed.</p><p>The other difference with <code>Boolean</code> operators is that although <code>&amp;&amp;</code> has a higher precedence than <code>||</code>,
<code>and</code> and <code>or</code>
have the same precedence. Thus although the <code>Boolean</code> expression <code>(a || b &amp;&amp; c)</code> will evaluate the <code>&amp;&amp;</code> expression
before the <code>||</code> expression, like <code>(a || (b &amp;&amp; c))</code>, the following expression:</p><p><pre class="stHighlighted">
traversable should (contain (<span class="stLiteral">7</span>) or contain (<span class="stLiteral">8</span>) and have size (<span class="stLiteral">9</span>))
</pre></p><p>Will evaluate left to right, as:</p><p><pre class="stHighlighted">
traversable should ((contain (<span class="stLiteral">7</span>) or contain (<span class="stLiteral">8</span>)) and have size (<span class="stLiteral">9</span>))
</pre></p><p>If you really want the <code>and</code> part to be evaluated first, you'll need to put in parentheses, like this:</p><p><pre class="stHighlighted">
traversable should (contain (<span class="stLiteral">7</span>) or (contain (<span class="stLiteral">8</span>) and have size (<span class="stLiteral">9</span>)))
</pre></p><p><a name="workingWithOptions"></a></p><h4> Working with <code>Option</code>s </h4><p>You can work with options using ScalaTest's equality, <code>empty</code>,
<code>defined</code>, and <code>contain</code> syntax.
For example, if you wish to check whether an option is <code>None</code>, you can write any of:</p><p><pre class="stHighlighted">
option shouldEqual <span class="stType">None</span>
option shouldBe <span class="stType">None</span>
option should === (<span class="stType">None</span>)
option shouldBe empty
</pre></p><p>If you wish to check an option is defined, and holds a specific value, you can write any of:</p><p><pre class="stHighlighted">
option shouldEqual <span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>)
option shouldBe <span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>)
option should === (<span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>))
</pre></p><p>If you only wish to check that an option is defined, but don't care what it's value is, you can write:</p><p><pre class="stHighlighted">
option shouldBe defined
</pre></p><p>If you mix in (or import the members of) <a href="OptionValues.html"><code>OptionValues</code></a>,
you can write one statement that indicates you believe an option should be defined and then say something else about its value. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.OptionValues._
option.value should be &lt; <span class="stLiteral">7</span>
</pre></p><p>As mentioned previously, you can use also use ScalaTest's <code>contain</code>, <code>contain oneOf</code>, and
<code>contain noneOf</code> syntax with options:</p><p><pre class="stHighlighted">
<span class="stType">Some</span>(<span class="stLiteral">2</span>) should contain (<span class="stLiteral">2</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) should contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) should contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
</pre></p><p><a name="checkingArbitraryProperties"></a></p><h4> Checking arbitrary properties with <code>have</code> </h4><p>Using <code>have</code>, you can check properties of any type, where a <em>property</em> is an attribute of any
object that can be retrieved either by a public field, method, or JavaBean-style <code>get</code>
or <code>is</code> method, like this:</p><p><pre class="stHighlighted">
book should have (
  <span class="stQuotedString">'title</span> (<span class="stQuotedString">"Programming in Scala"</span>),
  <span class="stQuotedString">'author</span> (<span class="stType">List</span>(<span class="stQuotedString">"Odersky"</span>, <span class="stQuotedString">"Spoon"</span>, <span class="stQuotedString">"Venners"</span>)),
  <span class="stQuotedString">'pubYear</span> (<span class="stLiteral">2008</span>)
)
</pre></p><p>This expression will use reflection to ensure the <code>title</code>, <code>author</code>, and <code>pubYear</code> properties of object <code>book</code>
are equal to the specified values. For example, it will ensure that <code>book</code> has either a public Java field or method
named <code>title</code>, or a public method named <code>getTitle</code>, that when invoked (or accessed in the field case) results
in the string <code>"Programming in Scala"</code>. If all specified properties exist and have their expected values, respectively,
execution will continue. If one or more of the properties either does not exist, or exists but results in an unexpected value,
a <code>TestFailedException</code> will be thrown that explains the problem. (For the details on how a field or method is selected during this
process, see the documentation for <a href="Matchers$HavePropertyMatcherGenerator.html"><code>HavePropertyMatcherGenerator</code></a>.)</p><p>When you use this syntax, you must place one or more property values in parentheses after <code>have</code>, separated by commas, where a <em>property
value</em> is a symbol indicating the name of the property followed by the expected value in parentheses. The only exceptions to this rule is the syntax
for checking size and length shown previously, which does not require parentheses. If you forget and put parentheses in, however, everything will
still work as you'd expect. Thus instead of writing:</p><p><pre class="stHighlighted">
array should have length (<span class="stLiteral">3</span>)
set should have size (<span class="stLiteral">90</span>)
</pre></p><p>You can alternatively, write:</p><p><pre class="stHighlighted">
array should have (length (<span class="stLiteral">3</span>))
set should have (size (<span class="stLiteral">90</span>))
</pre></p><p>If a property has a value different from the specified expected value, a <code>TestFailedError</code> will be thrown
with a detailed message that explains the problem. For example, if you assert the following on
a <code>book</code> whose title is <code>Moby Dick</code>:</p><p><pre class="stHighlighted">
book should have (<span class="stQuotedString">'title</span> (<span class="stQuotedString">"A Tale of Two Cities"</span>))
</pre></p><p>You'll get a <code>TestFailedException</code> with this detail message:</p><p><pre>
The title property had value "Moby Dick", instead of its expected value "A Tale of Two Cities",
on object Book("Moby Dick", "Melville", 1851)
</pre></p><p>If you prefer to check properties in a type-safe manner, you can use a <code>HavePropertyMatcher</code>.
This would allow you to write expressions such as:</p><p><pre class="stHighlighted">
book should have (
  title (<span class="stQuotedString">"Programming in Scala"</span>),
  author (<span class="stType">List</span>(<span class="stQuotedString">"Odersky"</span>, <span class="stQuotedString">"Spoon"</span>, <span class="stQuotedString">"Venners"</span>)),
  pubYear (<span class="stLiteral">2008</span>)
)
</pre></p><p>These expressions would fail to compile if <code>should</code> is used on an inappropriate type, as determined
by the type parameter of the <code>HavePropertyMatcher</code> being used. (For example, <code>title</code> in this example
might be of type <code>HavePropertyMatcher[org.publiclibrary.Book]</code>. If used with an appropriate type, such an expression will compile
and at run time the property method or field will be accessed directly; <em>i.e.</em>, no reflection will be used.
See the documentation for <a href="matchers/HavePropertyMatcher.html"><code>HavePropertyMatcher</code></a> for more information.</p><p><a name="lengthSizeHavePropertyMatchers"></a></p><h4> Using <code>length</code> and <code>size</code> with <code>HavePropertyMatcher</code>s </h4><p>If you want to use <code>length</code> or <code>size</code> syntax with your own custom <code>HavePropertyMatcher</code>s, you
can do so, but you must write <code>(of [&ldquo;the type&rdquo;])</code> afterwords. For example, you could write:</p><p><pre class="stHighlighted">
book should have (
  title (<span class="stQuotedString">"A Tale of Two Cities"</span>),
  length (<span class="stLiteral">220</span>) (of [<span class="stType">Book</span>]),
  author (<span class="stQuotedString">"Dickens"</span>)
)
</pre></p><p>Prior to ScalaTest 2.0, &ldquo;<code>length</code> <code>(22)</code>&rdquo; yielded a <code>HavePropertyMatcher[Any, Int]</code> that used reflection to dynamically look
for a <code>length</code> field or <code>getLength</code> method. In ScalaTest 2.0, &ldquo;<code>length</code> <code>(22)</code>&rdquo; yields a
<code>MatcherFactory1[Any, Length]</code>, so it is no longer a <code>HavePropertyMatcher</code>. The <code>(of [&lt;type&gt;])</code> syntax converts the
the <code>MatcherFactory1[Any, Length]</code> to a <code>HavePropertyMatcher[&lt;type&gt;, Int]</code>.</p><p><a name="matchingAPattern"></a></p><h4> Checking that an expression matches a pattern </h4><p>ScalaTest's <a href="Inside.html"><code>Inside</code></a> trait allows you to make assertions after a pattern match.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Name</span>(first: <span class="stType">String</span>, middle: <span class="stType">String</span>, last: <span class="stType">String</span>)
<br/><span class="stReserved">val</span> name = <span class="stType">Name</span>(<span class="stQuotedString">"Jane"</span>, <span class="stQuotedString">"Q"</span>, <span class="stQuotedString">"Programmer"</span>)
<br/>inside(name) { <span class="stReserved">case</span> <span class="stType">Name</span>(first, _, _) =&gt;
  first should startWith (<span class="stQuotedString">"S"</span>)
}
</pre></p><p>You can use <code>inside</code> to just ensure a pattern is matched, without making any further assertions, but a better
alternative for that kind of assertion is <code>matchPattern</code>. The <code>matchPattern</code> syntax allows you
to express that you expect a value to match a particular pattern, no more and no less:</p><p><pre class="stHighlighted">
name should matchPattern { <span class="stReserved">case</span> <span class="stType">Name</span>(<span class="stQuotedString">"Sarah"</span>, _, _) =&gt; }
</pre></p><p><a name="usingCustomMatchers"></a></p><h4> Using custom matchers </h4><p>If none of the built-in matcher syntax (or options shown so far for extending the syntax) satisfy a particular need you have, you can create
custom <code>Matcher</code>s that allow
you to place your own syntax directly after <code>should</code>. For example, class <code>java.io.File</code> has a method <code>isHidden</code>, which
indicates whether a file of a certain path and name is hidden. Because the <code>isHidden</code> method takes no parameters and returns <code>Boolean</code>,
you can call it using <code>be</code> with a symbol or <code>BePropertyMatcher</code>, yielding assertions like:</p><p><pre class="stHighlighted">
file should be (<span class="stQuotedString">'hidden</span>)  <span class="stLineComment">// using a symbol</span>
file should be (hidden)   <span class="stLineComment">// using a BePropertyMatcher</span>
</pre></p><p>If it doesn't make sense to have your custom syntax follow <code>be</code>, you might want to create a custom <code>Matcher</code>
instead, so your syntax can follow <code>should</code> directly. For example, you might want to be able to check whether
a <code>java.io.File</code>'s name ends with a particular extension, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// using a plain-old Matcher</span>
file should endWithExtension (<span class="stQuotedString">"txt"</span>)
</pre></p><p>ScalaTest provides several mechanism to make it easy to create custom matchers, including ways to compose new matchers
out of existing ones complete with new error messages.  For more information about how to create custom
<code>Matcher</code>s, please see the documentation for the <a href="matchers/Matcher.html"><code>Matcher</code></a> trait.</p><p><a name="checkingForExpectedExceptions"></a></p><h4> Checking for expected exceptions </h4><p>Sometimes you need to test whether a method throws an expected exception under certain circumstances, such
as when invalid arguments are passed to the method. With <code>Matchers</code> mixed in, you can
check for an expected exception like this:</p><p><pre class="stHighlighted">
an [<span class="stType">IndexOutOfBoundsException</span>] should be thrownBy s.charAt(-<span class="stLiteral">1</span>)
</pre></p><p>If <code>charAt</code> throws an instance of <code>StringIndexOutOfBoundsException</code>,
this expression will result in that exception. But if <code>charAt</code> completes normally, or throws a different
exception, this expression will complete abruptly with a <code>TestFailedException</code>.</p><p>If you need to further inspect an expected exception, you can capture it using this syntax:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> thrown = the [<span class="stType">IndexOutOfBoundsException</span>] thrownBy s.charAt(-<span class="stLiteral">1</span>)
</pre></p><p>This expression returns the caught exception so that you can inspect it further if you wish, for
example, to ensure that data contained inside the exception has the expected values. Here's an
example:</p><p><pre class="stHighlighted">
thrown.getMessage should equal (<span class="stQuotedString">"String index out of range: -1"</span>)
</pre></p><p>If you prefer you can also capture and inspect an expected exception in one statement, like this:</p><p><pre class="stHighlighted">
the [<span class="stType">ArithmeticException</span>] thrownBy <span class="stLiteral">1</span> / <span class="stLiteral">0</span> should have message <span class="stQuotedString">"/ by zero"</span>
the [<span class="stType">IndexOutOfBoundsException</span>] thrownBy {
  s.charAt(-<span class="stLiteral">1</span>)
} should have message <span class="stQuotedString">"String index out of range: -1"</span>
</pre></p><p>You can also state that no exception should be thrown by some code, like this:</p><p><pre class="stHighlighted">
noException should be thrownBy <span class="stLiteral">0</span> / <span class="stLiteral">1</span>
</pre></p><p><a name="thosePeskyParens"></a></p><h4> Those pesky parens </h4><p>Perhaps the most tricky part of writing assertions using ScalaTest matchers is remembering
when you need or don't need parentheses, but bearing in mind a few simple rules should help.
It is also reassuring to know that if you ever leave off a set of parentheses when they are
required, your code will not compile. Thus the compiler will help you remember when you need the parens.
That said, the rules are:</p><p>1. Although you don't always need them, you may choose to always put parentheses
around right-hand values, such as the <code>7</code> in <code>num should equal (7)</code>:</p><p><pre>
result should equal <span class="stRed">(</span>4<span class="stRed">)</span>
array should have length <span class="stRed">(</span>3<span class="stRed">)</span>
book should have (
  'title <span class="stRed">(</span>"Programming in Scala"<span class="stRed">)</span>,
  'author <span class="stRed">(</span>List("Odersky", "Spoon", "Venners")<span class="stRed">)</span>,
  'pubYear <span class="stRed">(</span>2008<span class="stRed">)</span>
)
option should be <span class="stRed">(</span>'defined<span class="stRed">)</span>
catMap should (contain key <span class="stRed">(</span>9<span class="stRed">)</span> and contain value <span class="stRed">(</span>"lives"<span class="stRed">)</span>)</span>
keyEvent should be an <span class="stRed">(</span>'actionKey<span class="stRed">)</span>
javaSet should have size <span class="stRed">(</span>90<span class="stRed">)</span>
</pre></p><p>2. Except for <code>length</code>, <code>size</code> and <code>message</code>, you must always put parentheses around
the list of one or more property values following a <code>have</code>:</p><p><pre>
file should (exist and have <span class="stRed">(</span>'name ("temp.txt")<span class="stRed">)</span>)
book should have <span class="stRed">(</span>
  title ("Programming in Scala"),
  author (List("Odersky", "Spoon", "Venners")),
  pubYear (2008)
<span class="stRed">)</span>
javaList should have length (9) // parens optional for length and size
</pre></p><p>3. You must always put parentheses around <code>and</code> and <code>or</code> expressions, as in:</p><p><pre>
catMap should <span class="stRed">(</span>contain key (9) and contain value ("lives")<span class="stRed">)</span>
number should <span class="stRed">(</span>equal (2) or equal (4) or equal (8)<span class="stRed">)</span>
</pre></p><p>4. Although you don't always need them, you may choose to always put parentheses
around custom <code>Matcher</code>s when they appear directly after <code>not</code>:</p><p><pre>
file should exist
file should not <span class="stRed">(</span>exist<span class="stRed">)</span>
file should (exist and have ('name ("temp.txt")))
file should (not <span class="stRed">(</span>exist<span class="stRed">)</span> and have ('name ("temp.txt"))
file should (have ('name ("temp.txt") or exist)
file should (have ('name ("temp.txt") or not <span class="stRed">(</span>exist<span class="stRed">)</span>)
</pre></p><p>That's it. With a bit of practice it should become natural to you, and the compiler will always be there to tell you if you
forget a set of needed parentheses.</p><p><em>Note: ScalaTest's matchers are in part inspired by the matchers of <a href="http://rspec.info" target="_blank">RSpec</a>,
<a href="https://github.com/hamcrest/JavaHamcrest" target="_blank">Hamcrest</a>, and
<a href="http://etorreborre.github.io/specs2/" target="_blank">specs2</a>, and its &ldquo;<code>shouldNot compile</code>&rdquo; syntax
by the <code>illTyped</code> macro of <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a>.</em></p></div></div>
    </li><li name="org.scalatest.MustMatchers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="MustMatchersextendsAssertionswithTolerancewithMustVerbwithMatcherWordswithExplicitly"></a><a id="MustMatchers:MustMatchers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#MustMatchersextendsAssertionswithTolerancewithMustVerbwithMatcherWordswithExplicitly" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides a domain specific language (DSL) for expressing assertions in tests using the word must." href="MustMatchers.html"><span class="name">MustMatchers</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a> with <span class="extype" name="org.scalactic.Tolerance">Tolerance</span> with <a href="words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="words/MatcherWords.html" class="extype" name="org.scalatest.words.MatcherWords">MatcherWords</a> with <span class="extype" name="org.scalactic.Explicitly">Explicitly</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides a domain specific language (DSL) for expressing assertions in tests
using the word <code>must</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides a domain specific language (DSL) for expressing assertions in tests
using the word <code>must</code>.</p><p>For example, if you mix <code>Matchers</code> into
a suite class, you can write an equality assertion in that suite like this:</p><p><pre class="stHighlighted">
result must equal (<span class="stLiteral">3</span>)
</pre></p><p>Here <code>result</code> is a variable, and can be of any type. If the object is an
<code>Int</code> with the value 3, execution will continue (<em>i.e.</em>, the expression will result
in the unit value, <code>()</code>). Otherwise, a <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>
will be thrown with a detail message that explains the problem, such as <code>"7 did not equal 3"</code>.
This <code>TestFailedException</code> will cause the test to fail.</p><p>Here is a table of contents for this documentation:</p><ul><li><a href="#matchersMigration">Matchers migration in ScalaTest 2.0</a></li><li><a href="#checkingEqualityWithMatchers">Checking equality with matchers</a></li><li><a href="#checkingSizeAndLength">Checking size and length</a></li><li><a href="#checkingStrings">Checking strings</a></li><li><a href="#greaterAndLessThan">Greater and less than</a></li><li><a href="#checkingBooleanPropertiesWithBe">Checking <code>Boolean</code> properties with <code>be</code></a></li><li><a href="#usingCustomBeMatchers">Using custom <code>BeMatchers</code></a></li><li><a href="#checkingObjectIdentity">Checking object identity</a></li><li><a href="#checkingAnObjectsClass">Checking an object's class</a></li><li><a href="#checkingNumbersAgainstARange">Checking numbers against a range</a></li><li><a href="#checkingForEmptiness">Checking for emptiness</a></li><li><a href="#workingWithContainers">Working with "containers"</a></li><li><a href="#workingWithAggregations">Working with "aggregations"</a></li><li><a href="#workingWithSequences">Working with "sequences"</a></li><li><a href="#workingWithSortables">Working with "sortables"</a></li><li><a href="#workingWithIterators">Working with iterators</a></li><li><a href="#inspectorShorthands">Inspector shorthands</a></li><li><a href="#singleElementCollections">Single-element collections</a></li><li><a href="#javaCollectionsAndMaps">Java collections and maps</a></li><li><a href="#stringsAndArraysAsCollections"><code>String</code>s and <code>Array</code>s as collections</a></li><li><a href="#beAsAnEqualityComparison">Be as an equality comparison</a></li><li><a href="#beingNegative">Being negative</a></li><li><a href="#checkingThatCodeDoesNotCompile">Checking that a snippet of code does not compile</a></li><li><a href="#logicalExpressions">Logical expressions with <code>and</code> and <code>or</code></a></li><li><a href="#workingWithOptions">Working with <code>Option</code>s</a></li><li><a href="#checkingArbitraryProperties">Checking arbitrary properties with <code>have</code></a></li><li><a href="#lengthSizeHavePropertyMatchers">Using <code>length</code> and <code>size</code> with <code>HavePropertyMatcher</code>s</a></li><li><a href="#matchingAPattern">Checking that an expression matches a pattern</a></li><li><a href="#usingCustomMatchers">Using custom matchers</a></li><li><a href="#checkingForExpectedExceptions">Checking for expected exceptions</a></li><li><a href="#thosePeskyParens">Those pesky parens</a></li></ul><p>Trait <code>MustMatchers</code> is an alternative to <a href="Matchers.html"><code>Matchers</code></a> that provides the exact same
meaning, syntax, and behavior as <code>Matchers</code>, but uses the verb <code>must</code> instead of <code>should</code>.
The two traits differ only in the English semantics of the verb: <code>should</code>
is informal, making the code feel like conversation between the writer and the reader; <code>must</code> is more formal, making the code feel more like
a written specification.</p><p><a name="checkingEqualityWithMatchers"></a></p><h4> Checking equality with matchers </h4><p>ScalaTest matchers provides five different ways to check equality, each designed to address a different need. They are:</p><p><pre class="stHighlighted">
result must equal (<span class="stLiteral">3</span>) <span class="stLineComment">// can customize equality</span>
result must === (<span class="stLiteral">3</span>)   <span class="stLineComment">// can customize equality and enforce type constraints</span>
result must be (<span class="stLiteral">3</span>)    <span class="stLineComment">// cannot customize equality, so fastest to compile</span>
result mustEqual <span class="stLiteral">3</span>    <span class="stLineComment">// can customize equality, no parentheses required</span>
result mustBe <span class="stLiteral">3</span>       <span class="stLineComment">// cannot customize equality, so fastest to compile, no parentheses required</span>
</pre></p><p>The &ldquo;<code>left</code> <code>must</code> <code>equal</code> <code>(right)</code>&rdquo; syntax requires an
<a href="../scalactic/Equality.html"><code>org.scalactic.Equality[L]</code></a> to be provided (either implicitly or explicitly), where
<code>L</code> is the left-hand type on which <code>must</code> is invoked. In the &quot;<code>left</code> <code>must</code> <code>equal</code> <code>(right)</code>&quot; case,
for example, <code>L</code> is the type of <code>left</code>. Thus if <code>left</code> is type <code>Int</code>, the &quot;<code>left</code> <code>must</code>
<code>equal</code> <code>(right)</code>&quot;
statement would require an <code>Equality[Int]</code>.</p><p>By default, an implicit <code>Equality[T]</code> instance is available for any type <code>T</code>, in which equality is implemented
by simply invoking <code>==</code>  on the <code>left</code>
value, passing in the <code>right</code> value, with special treatment for arrays. If either <code>left</code> or <code>right</code> is an array, <code>deep</code>
will be invoked on it before comparing with <em>==</em>. Thus, the following expression
will yield false, because <code>Array</code>'s <code>equals</code> method compares object identity:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) == <span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) <span class="stLineComment">// yields false</span>
</pre></p><p>The next expression will by default <em>not</em> result in a <code>TestFailedException</code>, because default <code>Equality[Array[Int]]</code> compares
the two arrays structurally, taking into consideration the equality of the array's contents:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) must equal (<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)) <span class="stLineComment">// succeeds (i.e., does not throw TestFailedException)</span>
</pre></p><p>If you ever do want to verify that two arrays are actually the same object (have the same identity), you can use the
<code>be theSameInstanceAs</code> syntax, <a href="#checkingObjectIdentity">described below</a>.</p><p>You can customize the meaning of equality for a type when using &quot;<code>must</code> <code>equal</code>,&quot; &quot;<code>must</code> <code>===</code>,&quot;
or <code>mustEqual</code> syntax by defining implicit <code>Equality</code> instances that will be used instead of default <code>Equality</code>.
You might do this to normalize types before comparing them with <code>==</code>, for instance, or to avoid calling the <code>==</code> method entirely,
such as if you want to compare <code>Double</code>s with a tolerance.
For an example, see the main documentation of <a href="../scalactic/Equality.html">trait <code>Equality</code></a>.</p><p>You can always supply implicit parameters explicitly, but in the case of implicit parameters of type <code>Equality[T]</code>, Scalactic provides a
simple &quot;explicitly&quot; DSL. For example, here's how you could explicitly supply an <code>Equality[String]</code> instance that normalizes both left and right
sides (which must be strings), by transforming them to lowercase:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; import org.scalactic.Explicitly._
import org.scalactic.Explicitly._

scala&gt; import org.scalactic.StringNormalizations._
import org.scalactic.StringNormalizations._

scala&gt; "Hi" must equal ("hi") (after being lowerCased)
</pre></p><p>The <code>after</code> <code>being</code> <code>lowerCased</code> expression results in an <code>Equality[String]</code>, which is then passed
explicitly as the second curried parameter to <code>equal</code>. For more information on the explicitly DSL, see the main documentation
for trait <a href="../scalactic/Explicitly.html"><code>Explicitly</code></a>.</p><p>The &quot;<code>must</code> <code>be</code>&quot; and <code>mustBe</code> syntax do not take an <code>Equality[T]</code> and can therefore not be customized.
They always use the default approach to equality described above. As a result, &quot;<code>must</code> <code>be</code>&quot; and <code>mustBe</code> will
likely be the fastest-compiling matcher syntax for equality comparisons, since the compiler need not search for
an implicit <code>Equality[T]</code> each time.</p><p>The <code>must</code> <code>===</code> syntax (and its complement, <code>must</code> <code>!==</code>) can be used to enforce type
constraints at compile-time between the left and right sides of the equality comparison. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; import org.scalactic.TypeCheckedTripleEquals._
import org.scalactic.TypeCheckedTripleEquals._

scala&gt; Some(2) must === (2)
&lt;console&gt;:17: error: types Some[Int] and Int do not adhere to the equality constraint
selected for the === and !== operators; the missing implicit parameter is of
type org.scalactic.CanEqual[Some[Int],Int]
              Some(2) must === (2)
                      ^
</pre></p><p>By default, the &quot;<code>Some(2)</code> <code>must</code> <code>===</code> <code>(2)</code>&quot; statement would fail at runtime. By mixing in
the equality constraints provided by <code>TypeCheckedTripleEquals</code>, however, the statement fails to compile. For more information
and examples, see the main documentation for <a href="../scalactic/TypeCheckedTripleEquals.html">trait <code>TypeCheckedTripleEquals</code></a>.</p><p><a name="checkingSizeAndLength"></a></p><h4> Checking size and length </h4><p>You can check the size or length of any type of object for which it
makes sense. Here's how checking for length looks:</p><p><pre class="stHighlighted">
result must have length <span class="stLiteral">3</span>
</pre></p><p>Size is similar:</p><p><pre class="stHighlighted">
result must have size <span class="stLiteral">10</span>
</pre></p><p>The <code>length</code> syntax can be used with <code>String</code>, <code>Array</code>, any <code>scala.collection.GenSeq</code>,
any <code>java.util.List</code>, and any type <code>T</code> for which an implicit <code>Length[T]</code> type class is
available in scope.
Similarly, the <code>size</code> syntax can be used with <code>Array</code>, any <code>scala.collection.GenTraversable</code>,
any <code>java.util.Collection</code>, any <code>java.util.Map</code>, and any type <code>T</code> for which an implicit <code>Size[T]</code> type class is
available in scope. You can enable the <code>length</code> or <code>size</code> syntax for your own arbitrary types, therefore,
by defining <a href="enablers/Length.html"><code>Length</code></a> or <a href="enablers/Size.html"><code>Size</code></a> type
classes for those types.</p><p>In addition, the <code>length</code> syntax can be used with any object that has a field or method named <code>length</code>
or a method named <code>getLength</code>.   Similarly, the <code>size</code> syntax can be used with any
object that has a field or method named <code>size</code> or a method named <code>getSize</code>.
The type of a <code>length</code> or <code>size</code> field, or return type of a method, must be either <code>Int</code>
or <code>Long</code>. Any such method must take no parameters. (The Scala compiler will ensure at compile time that
the object on which <code>must</code> is being invoked has the appropriate structure.)</p><p><a name="checkingStrings"></a></p><h4> Checking strings </h4><p>You can check for whether a string starts with, ends with, or includes a substring like this:</p><p><pre class="stHighlighted">
string must startWith (<span class="stQuotedString">"Hello"</span>)
string must endWith (<span class="stQuotedString">"world"</span>)
string must include (<span class="stQuotedString">"seven"</span>)
</pre></p><p>You can check for whether a string starts with, ends with, or includes a regular expression, like this:</p><p><pre class="stHighlighted">
string must startWith regex <span class="stQuotedString">"Hel*o"</span>
string must endWith regex <span class="stQuotedString">"wo.ld"</span>
string must include regex <span class="stQuotedString">"wo.ld"</span>
</pre></p><p>And you can check whether a string fully matches a regular expression, like this:</p><p><pre class="stHighlighted">
string must fullyMatch regex <span class="stQuotedString">"""(-)?(\d+)(\.\d*)?"""</span>
</pre></p><p>The regular expression passed following the <code>regex</code> token can be either a <code>String</code>
or a <code>scala.util.matching.Regex</code>.</p><p>With the <code>startWith</code>, <code>endWith</code>, <code>include</code>, and <code>fullyMatch</code>
tokens can also be used with an optional specification of required groups, like this:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"abbccxxx"</span> must startWith regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"xxxabbcc"</span> must endWith regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"xxxabbccxxx"</span> must include regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
<span class="stQuotedString">"abbcc"</span> must fullyMatch regex (<span class="stQuotedString">"a(b*)(c*)"</span> withGroups (<span class="stQuotedString">"bb"</span>, <span class="stQuotedString">"cc"</span>))
</pre></p><p>You can check whether a string is empty with <code>empty</code>:</p><p><pre class="stHighlighted">
s mustBe empty
</pre></p><p>You can also use most of ScalaTest's matcher syntax for collections on <code>String</code> by
treating the <code>String</code>s as collections of characters. For examples, see the
<a href="#stringsAndArraysAsCollections"><code>String</code>s and <code>Array</code>s as collections</a> section below.</p><p><a name="greaterAndLessThan"></a></p><h4> Greater and less than </h4><p>You can check whether any type for which an implicit <code>Ordering[T]</code> is available
is greater than, less than, greater than or equal, or less
than or equal to a value of type <code>T</code>. The syntax is:</p><p><pre class="stHighlighted">
one must be &lt; <span class="stLiteral">7</span>
one must be &gt; <span class="stLiteral">0</span>
one must be &lt;= <span class="stLiteral">7</span>
one must be &gt;= <span class="stLiteral">0</span>
</pre></p><p><a name="checkingBooleanPropertiesWithBe"></a></p><h4> Checking <code>Boolean</code> properties with <code>be</code> </h4><p>If an object has a method that takes no parameters and returns boolean, you can check
it by placing a <code>Symbol</code> (after <code>be</code>) that specifies the name
of the method (excluding an optional prefix of &quot;<code>is</code>&quot;). A symbol literal
in Scala begins with a tick mark and ends at the first non-identifier character. Thus,
<code>'traversableAgain</code> results in a <code>Symbol</code> object at runtime, as does
<code>'completed</code> and <code>'file</code>. Here's an example:</p><p><pre class="stHighlighted">
iter mustBe <span class="stQuotedString">'traversableAgain</span>
</pre></p><p>Given this code, ScalaTest will use reflection to look on the object referenced from
<code>emptySet</code> for a method that takes no parameters and results in <code>Boolean</code>,
with either the name <code>empty</code> or <code>isEmpty</code>. If found, it will invoke
that method. If the method returns <code>true</code>, execution will continue. But if it returns
<code>false</code>, a <code>TestFailedException</code> will be thrown that will contain a detail message, such as:</p><p><pre class="stHighlighted">
non-empty iterator was not traversableAgain
</pre></p><p>This <code>be</code> syntax can be used with any reference (<code>AnyRef</code>) type.  If the object does
not have an appropriately named predicate method, you'll get a <code>TestFailedException</code>
at runtime with a detailed message that explains the problem.
(For the details on how a field or method is selected during this
process, see the documentation for <a href="words/BeWord.html"><code>BeWord</code></a>.)</p><p>If you think it reads better, you can optionally put <code>a</code> or <code>an</code> after
<code>be</code>. For example, <code>java.io.File</code> has two predicate methods,
<code>isFile</code> and <code>isDirectory</code>. Thus with a <code>File</code> object
named <code>temp</code>, you could write:</p><p><pre class="stHighlighted">
temp must be a <span class="stQuotedString">'file</span>
</pre></p><p>Or, given <code>java.awt.event.KeyEvent</code> has a method <code>isActionKey</code> that takes
no arguments and returns <code>Boolean</code>, you could assert that a <code>KeyEvent</code> is
an action key with:</p><p><pre class="stHighlighted">
keyEvent must be an <span class="stQuotedString">'actionKey</span>
</pre></p><p>If you prefer to check <code>Boolean</code> properties in a type-safe manner, you can use a <code>BePropertyMatcher</code>.
This would allow you to write expressions such as:</p><p><pre class="stHighlighted">
xs mustBe traversableAgain
temp must be a file
keyEvent must be an actionKey
</pre></p><p>These expressions would fail to compile if <code>must</code> is used on an inappropriate type, as determined
by the type parameter of the <code>BePropertyMatcher</code> being used. (For example, <code>file</code> in this example
would likely be of type <code>BePropertyMatcher[java.io.File]</code>. If used with an appropriate type, such an expression will compile
and at run time the <code>Boolean</code> property method or field will be accessed directly; <em>i.e.</em>, no reflection will be used.
See the documentation for <a href="matchers/BePropertyMatcher.html"><code>BePropertyMatcher</code></a> for more information.</p><p><a name="usingCustomBeMatchers"></a></p><h4> Using custom <code>BeMatchers</code> </h4><p>If you want to create a new way of using <code>be</code>, which doesn't map to an actual property on the
type you care about, you can create a <code>BeMatcher</code>. You could use this, for example, to create <code>BeMatcher[Int]</code>
called <code>odd</code>, which would match any odd <code>Int</code>, and <code>even</code>, which would match
any even <code>Int</code>.
Given this pair of <code>BeMatcher</code>s, you could check whether an <code>Int</code> was odd or even with expressions like:</p><p><pre class="stHighlighted">
num mustBe odd
num must not be even
</pre></p><p>For more information, see the documentation for <a href="matchers/BeMatcher.html"><code>BeMatcher</code></a>.</p><p><a name="checkingObjectIdentity"></a></p><h4> Checking object identity </h4><p>If you need to check that two references refer to the exact same object, you can write:</p><p><pre class="stHighlighted">
ref1 must be theSameInstanceAs ref2
</pre></p><p><a name="checkingAnObjectsClass"></a></p><h4> Checking an object's class </h4><p>If you need to check that an object is an instance of a particular class or trait, you can supply the type to
&ldquo;<code>be</code> <code>a</code>&rdquo; or &ldquo;<code>be</code> <code>an</code>&rdquo;:</p><p><pre class="stHighlighted">
result1 mustBe a [<span class="stType">Tiger</span>]
result1 must not be an [<span class="stType">Orangutan</span>]
</pre></p><p>Because type parameters are erased on the JVM, we recommend you insert an underscore for any type parameters
when using this syntax. Both of the following test only that the result is an instance of <code>List[_]</code>, because at
runtime the type parameter has been erased:</p><p><pre class="stHighlighted">
result mustBe a [<span class="stType">List[_]</span>] <span class="stLineComment">// recommended</span>
result mustBe a [<span class="stType">List[Fruit]</span>] <span class="stLineComment">// discouraged</span>
</pre></p><p><a name="checkingNumbersAgainstARange"></a></p><h4> Checking numbers against a range </h4><p>Often you may want to check whether a number is within a
range. You can do that using the <code>+-</code> operator, like this:</p><p><pre class="stHighlighted">
sevenDotOh must equal (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh must === (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh must be (<span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>)
sevenDotOh mustEqual <span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>
sevenDotOh mustBe <span class="stLiteral">6.9</span> +- <span class="stLiteral">0.2</span>
</pre></p><p>Any of these expressions will cause a <code>TestFailedException</code> to be thrown if the floating point
value, <code>sevenDotOh</code> is outside the range <code>6.7</code> to <code>7.1</code>.
You can use <code>+-</code> with any type <code>T</code> for which an implicit <code>Numeric[T]</code> exists, such as integral types:</p><p><pre class="stHighlighted">
seven must equal (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven must === (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven must be (<span class="stLiteral">6</span> +- <span class="stLiteral">2</span>)
seven mustEqual <span class="stLiteral">6</span> +- <span class="stLiteral">2</span>
seven mustBe <span class="stLiteral">6</span> +- <span class="stLiteral">2</span>
</pre></p><p><a name="checkingForEmptiness"></a></p><h4> Checking for emptiness </h4><p>You can check whether an object is &quot;empty&quot;, like this:</p><p><pre class="stHighlighted">
traversable mustBe empty
javaMap must not be empty
</pre></p><p>The <code>empty</code> token can be used with any type <code>L</code> for which an implicit <code>Emptiness[L]</code> exists.
The <code>Emptiness</code> companion object provides implicits for <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>, and <code>Option[E]</code>. In addition, the
<code>Emptiness</code> companion object provides structural implicits for types that declare an <code>isEmpty</code> method that
returns a <code>Boolean</code>. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; List.empty mustBe empty

scala&gt; None mustBe empty

scala&gt; Some(1) must not be empty

scala&gt; "" mustBe empty

scala&gt; new java.util.HashMap[Int, Int] mustBe empty

scala&gt; new { def isEmpty = true} mustBe empty

scala&gt; Array(1, 2, 3) must not be empty
</pre></p><p><a name="workingWithContainers"></a></p><h4> Working with &quot;containers&quot; </h4><p>You can check whether a collection contains a particular element like this:</p><p><pre class="stHighlighted">
traversable must contain (<span class="stQuotedString">"five"</span>)
</pre></p><p>The <code>contain</code> syntax shown above can be used with any type <code>C</code> that has a &quot;containing&quot; nature, evidenced by
an implicit <code>org.scalatest.enablers.Containing[L]</code>, where <code>L</code> is left-hand type on
which <code>must</code> is invoked. In the <code>Containing</code>
companion object, implicits are provided for types <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>, and <code>Option[E]</code>.
Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; List(1, 2, 3) must contain (2)

scala&gt; Map('a' -&gt; 1, 'b' -&gt; 2, 'c' -&gt; 3) must contain ('b' -&gt; 2)

scala&gt; Set(1, 2, 3) must contain (2)

scala&gt; Array(1, 2, 3) must contain (2)

scala&gt; "123" must contain ('2')

scala&gt; Some(2) must contain (2)
</pre></p><p>ScalaTest's implicit methods that provide the <code>Containing[L]</code> type classes require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Containing[Array[Int]]</code> you must supply an <code>Equality[Int]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Containing[L]</code>,
implicit conversions are provided in the <code>Containing</code> companion object from <code>Equality[E]</code> to the various
types of containers of <code>E</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; List("Hi", "Di", "Ho") must contain ("ho")
org.scalatest.exceptions.TestFailedException: List(Hi, Di, Ho) did not contain element "ho"
        at ...

scala&gt; import org.scalactic.Explicitly._
import org.scalactic.Explicitly._

scala&gt; import org.scalactic.StringNormalizations._
import org.scalactic.StringNormalizations._

scala&gt; (List("Hi", "Di", "Ho") must contain ("ho")) (after being lowerCased)
</pre></p><p>Note that when you use the explicitly DSL with <code>contain</code> you need to wrap the entire
<code>contain</code> expression in parentheses, as shown here.</p><p><pre>
(List("Hi", "Di", "Ho") must contain ("ho")) (after being lowerCased)
^                                            ^
</pre></p><p>In addition to determining whether an object contains another object, you can use <code>contain</code> to
make other determinations.
For example, the <code>contain</code> <code>oneOf</code> syntax ensures that one and only one of the specified elements are
contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) must contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"howdy"</span> must contain oneOf (<span class="stQuotedString">'a'</span>, <span class="stQuotedString">'b'</span>, <span class="stQuotedString">'c'</span>, <span class="stQuotedString">'d'</span>)
</pre></p><p>Note that if multiple specified elements appear in the containing object, <code>oneOf</code> will fail:</p><p><pre class="stREPL">
scala&gt; List(1, 2, 3) must contain oneOf (2, 3, 4)
org.scalatest.exceptions.TestFailedException: List(1, 2, 3) did not contain one (and only one) of (2, 3, 4)
        at ...
</pre></p><p>If you really want to ensure one or more of the specified elements are contained in the containing object,
use <code>atLeastOneOf</code>, described below, instead of <code>oneOf</code>. Keep in mind, <code>oneOf</code>
means &quot;<em>exactly</em> one of.&quot;</p><p>Note also that with any <code>contain</code> syntax, you can place custom implicit <code>Equality[E]</code> instances in scope
to customize how containership is determined, or use the explicitly DSL. Here's an example:</p><p><pre class="stHighlighted">
(<span class="stType">Array</span>(<span class="stQuotedString">"Doe"</span>, <span class="stQuotedString">"Ray"</span>, <span class="stQuotedString">"Me"</span>) must contain oneOf (<span class="stQuotedString">"X"</span>, <span class="stQuotedString">"RAY"</span>, <span class="stQuotedString">"BEAM"</span>)) (after being lowerCased)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;one of&quot; comparison, you can use &quot;oneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain oneElementOf <span class="stType">List</span>(<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) must contain oneElementOf <span class="stType">Vector</span>(<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"howdy"</span> must contain oneElementOf <span class="stType">Set</span>(<span class="stQuotedString">'a'</span>, <span class="stQuotedString">'b'</span>, <span class="stQuotedString">'c'</span>, <span class="stQuotedString">'d'</span>)
(<span class="stType">Array</span>(<span class="stQuotedString">"Doe"</span>, <span class="stQuotedString">"Ray"</span>, <span class="stQuotedString">"Me"</span>) must contain oneElementOf <span class="stType">List</span>(<span class="stQuotedString">"X"</span>, <span class="stQuotedString">"RAY"</span>, <span class="stQuotedString">"BEAM"</span>)) (after being lowerCased)
</pre></p><p>The <code>contain</code> <code>noneOf</code> syntax does the opposite of <code>oneOf</code>: it ensures none of the specified elements
are contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) must contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"12345"</span> must contain noneOf (<span class="stQuotedString">'7'</span>, <span class="stQuotedString">'8'</span>, <span class="stQuotedString">'9'</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;none of&quot; comparison, you can use &quot;noElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain noElementsOf <span class="stType">List</span>(<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) must contain noElementsOf <span class="stType">Vector</span>(<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
<span class="stQuotedString">"12345"</span> must contain noElementsOf <span class="stType">Set</span>(<span class="stQuotedString">'7'</span>, <span class="stQuotedString">'8'</span>, <span class="stQuotedString">'9'</span>)
</pre></p><p><a name="workingWithAggregations"></a></p><h4> Working with &quot;aggregations&quot; </h4><p>As mentioned, the &quot;<code>contain</code>,&quot;  &quot;<code>contain</code> <code>oneOf</code>,&quot; and &quot;<code>contain</code> <code>noneOf</code>&quot; syntax requires a
<code>Containing[L]</code> be provided, where <code>L</code> is the left-hand type.  Other <code>contain</code> syntax, which
will be described in this section, requires an <code>Aggregating[L]</code> be provided, where again <code>L</code> is the left-hand type.
(An <code>Aggregating[L]</code> instance defines the &quot;aggregating nature&quot; of a type <code>L</code>.)
The reason, essentially, is that <code>contain</code> syntax that makes sense for <code>Option</code> is enabled by
<code>Containing[L]</code>, whereas syntax that does <em>not</em> make sense for <code>Option</code> is enabled
by <code>Aggregating[L]</code>. For example, it doesn't make sense to assert that an <code>Option[Int]</code> contains all of a set of integers, as it
could only ever contain one of them. But this does make sense for a type such as <code>List[Int]</code> that can aggregate zero to many integers.</p><p>The <code>Aggregating</code> companion object provides implicit instances of <code>Aggregating[L]</code>
for types <code>GenTraversable[E]</code>, <code>java.util.Collection[E]</code>,
<code>java.util.Map[K, V]</code>, <code>String</code>, <code>Array[E]</code>. Note that these are the same types as are supported with
<code>Containing</code>, but with <code>Option[E]</code> missing.
Here are some examples:</p><p>The <code>contain</code> <code>atLeastOneOf</code> syntax, for example, works for any type <code>L</code> for which an <code>Aggregating[L]</code> exists. It ensures
that at least one of (<em>i.e.</em>, one or more of) the specified objects are contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) must contain atLeastOneOf (<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>)
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) must contain atLeastOneOf (<span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>)
<span class="stQuotedString">"abc"</span> must contain atLeastOneOf (<span class="stQuotedString">'c'</span>, <span class="stQuotedString">'a'</span>, <span class="stQuotedString">'t'</span>)
</pre></p><p>Similar to <code>Containing[L]</code>, the implicit methods that provide the <code>Aggregating[L]</code> instances require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Aggregating[Vector[String]]</code> you must supply an <code>Equality[String]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Aggregating[L]</code>,
implicit conversions are provided in the <code>Aggregating</code> companion object from <code>Equality[E]</code> to the various
types of aggregations of <code>E</code>. Here's an example:</p><p><pre class="stHighlighted">
(<span class="stType">Vector</span>(<span class="stQuotedString">" A"</span>, <span class="stQuotedString">"B "</span>) must contain atLeastOneOf (<span class="stQuotedString">"a "</span>, <span class="stQuotedString">"b"</span>, <span class="stQuotedString">"c"</span>)) (after being lowerCased and trimmed)
</pre></p><p>If you have a collection of elements that you'd like to use in an &quot;at least one of&quot; comparison, you can use &quot;atLeastOneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) must contain atLeastOneElementOf <span class="stType">List</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>)
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) must contain atLeastOneElementOf <span class="stType">Vector</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>)
<span class="stQuotedString">"abc"</span> must contain atLeastOneElementOf <span class="stType">Set</span>(<span class="stQuotedString">'c'</span>, <span class="stQuotedString">'a'</span>, <span class="stQuotedString">'t'</span>)
(<span class="stType">Vector</span>(<span class="stQuotedString">" A"</span>, <span class="stQuotedString">"B "</span>) must contain atLeastOneElementOf <span class="stType">List</span>(<span class="stQuotedString">"a "</span>, <span class="stQuotedString">"b"</span>, <span class="stQuotedString">"c"</span>)) (after being lowerCased and trimmed)
</pre></p><p>The &quot;<code>contain</code> <code>atMostOneOf</code>&quot; syntax lets you specify a set of objects at most one of which must be contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain atMostOneOf (<span class="stLiteral">5</span>, <span class="stLiteral">6</span>, <span class="stLiteral">7</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;at most one of&quot; comparison, you can use &quot;atMostOneElementOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain atMostOneElementOf <span class="stType">Vector</span>(<span class="stLiteral">5</span>, <span class="stLiteral">6</span>, <span class="stLiteral">7</span>)
</pre></p><p>The &quot;<code>contain</code> <code>allOf</code>&quot; syntax lets you specify a set of objects that must all be contained in the containing object:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain allOf (<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;all of&quot; comparison, you can use &quot;allElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>) must contain allElementsOf <span class="stType">Array</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>)
</pre></p><p>The &quot;<code>contain</code> <code>only</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects, though it may
contain more than one of each:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">1</span>) must contain only (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The &quot;<code>contain</code> <code>theSameElementsAs</code>&quot; and &quot;<code>contain</code> <code>theSameElementsInOrderAs</code> syntax differ from the others
in that the right hand side is a <code>GenTraversable[_]</code> rather than a varargs of <code>Any</code>. (Note: in a future 2.0 milestone release, possibly
2.0.M6, these will likely be widened to accept any type <code>R</code> for which an <code>Aggregating[R]</code> exists.)</p><p>The &quot;<code>contain</code> <code>theSameElementsAs</code>&quot; syntax lets you assert that two aggregations contain the same objects:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>) must contain theSameElementsAs <span class="stType">Vector</span>(<span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The number of times any family of equal objects appears must also be the same in both the left and right aggregations.
The specified objects may appear multiple times, but must appear in the order they appear in the right-hand list. For example, if
the last 3 element is left out of the right-hand list in the previous example, the expression would fail because the left side
has three 3's and the right hand side has only two:</p><p><pre class="stREPL">
List(1, 2, 2, 3, 3, 3) must contain theSameElementsAs Vector(3, 2, 3, 1, 2)
org.scalatest.exceptions.TestFailedException: List(1, 2, 2, 3, 3, 3) did not contain the same elements as Vector(3, 2, 3, 1, 2)
        at ...
</pre></p><p>Note that no <code>onlyElementsOf</code> matcher is provided, because it would have the same
behavior as <code>theSameElementsAs</code>. (<em>I.e.</em>, if you were looking for <code>onlyElementsOf</code>, please use <code>theSameElementsAs</code>
instead.)</p><p><a name="workingWithSequences"></a></p><h4> Working with &quot;sequences&quot; </h4><p>The rest of the <code>contain</code> syntax, which
will be described in this section, requires a <code>Sequencing[L]</code> be provided, where again <code>L</code> is the left-hand type.
(A <code>Sequencing[L]</code> instance defines the &quot;sequencing nature&quot; of a type <code>L</code>.)
The reason, essentially, is that <code>contain</code> syntax that implies an &quot;order&quot; of elements makes sense only for types that place elements in a sequence.
For example, it doesn't make sense to assert that a <code>Map[String, Int]</code> or <code>Set[Int]</code> contains all of a set of integers in a particular
order, as these types don't necessarily define an order for their elements. But this does make sense for a type such as <code>Seq[Int]</code> that does define
an order for its elements.</p><p>The <code>Sequencing</code> companion object provides implicit instances of <code>Sequencing[L]</code>
for types <code>GenSeq[E]</code>, <code>java.util.List[E]</code>,
<code>String</code>, and <code>Array[E]</code>.
Here are some examples:</p><p>Similar to <code>Containing[L]</code>, the implicit methods that provide the <code>Aggregating[L]</code> instances require an <code>Equality[E]</code>, where
<code>E</code> is an element type. For example, to obtain a <code>Aggregating[Vector[String]]</code> you must supply an <code>Equality[String]</code>,
either implicitly or explicitly. The <code>contain</code> syntax uses this <code>Equality[E]</code> to determine containership.
Thus if you want to change how containership is determined for an element type <code>E</code>, place an implicit <code>Equality[E]</code>
in scope or use the explicitly DSL. Although the implicit parameter required for the <code>contain</code> syntax is of type <code>Aggregating[L]</code>,
implicit conversions are provided in the <code>Aggregating</code> companion object from <code>Equality[E]</code> to the various
types of aggregations of <code>E</code>. Here's an example:</p><p>The &quot;<code>contain</code> <code>inOrderOnly</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects, in order.
The specified objects may appear multiple times, but must appear in the order they appear in the right-hand list. Here's an example:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>) must contain inOrderOnly (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The &quot;<code>contain</code> <code>inOrder</code>&quot; syntax lets you assert that the containing object contains <em>only</em> the specified objects in order, like
<code>inOrderOnly</code>, but allows other objects to appear in the left-hand aggregation as well:
contain more than one of each:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">0</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">99</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>) must contain inOrder (<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>If you have a collection of elements that you'd like to use in a &quot;in order&quot; comparison, you can use &quot;inOrderElementsOf,&quot; like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">0</span>, <span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">2</span>, <span class="stLiteral">99</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">3</span>, <span class="stLiteral">5</span>) must contain inOrderElementsOf <span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that &quot;order&quot; in <code>inOrder</code>, <code>inOrderOnly</code>, and <code>theSameElementsInOrderAs</code> (described below)
in the <code>Aggregation[L]</code> instances built-in to ScalaTest is defined as &quot;iteration order&quot;.</p><p>Lastly, the &quot;<code>contain</code> <code>theSameElementsInOrderAs</code>&quot; syntax lets you assert that two aggregations contain
the same exact elements in the same (iteration) order:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) must contain theSameElementsInOrderAs <span class="stType">collection.mutable.TreeSet</span>(<span class="stLiteral">3</span>, <span class="stLiteral">2</span>, <span class="stLiteral">1</span>)
</pre></p><p>The previous assertion succeeds because the iteration order of a<code>TreeSet</code> is the natural
ordering of its elements, which in this case is 1, 2, 3. An iterator obtained from the left-hand <code>List</code> will produce the same elements
in the same order.</p><p>Note that no <code>inOrderOnlyElementsOf</code> matcher is provided, because it would have the same
behavior as <code>theSameElementsInOrderAs</code>. (<em>I.e.</em>, if you were looking for <code>inOrderOnlyElementsOf</code>, please use <code>theSameElementsInOrderAs</code>
instead.)</p><p><a name="workingWithSortables"></a></p><h4> Working with &quot;sortables&quot; </h4><p>You can also ask whether the elements of &quot;sortable&quot; objects (such as <code>Array</code>s, Java <code>List</code>s, and <code>GenSeq</code>s)
are in sorted order, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) mustBe sorted
</pre></p><p><a name="workingWithIterators"></a></p><h4> Working with iterators </h4><p>Although it seems desirable to provide similar matcher syntax for Scala and Java iterators to that provided for sequences like
<code>Seq</code>s, <code>Array</code>, and <code>java.util.List</code>, the
ephemeral nature of iterators makes this problematic. Some syntax (such as <code>must</code> <code>contain</code>) is relatively straightforward to
support on iterators, but other syntax (such
as, for example, <code>Inspector</code> expressions on nested iterators) is not. Rather
than allowing inconsistencies between sequences and iterators in the API, we chose to not support any such syntax directly on iterators:</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> it = <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).iterator
it: <span class="stType">Iterator[Int]</span> = non-empty iterator
<br/>scala&gt; it must contain (<span class="stLiteral">2</span>)
&lt;console&gt;:<span class="stLiteral">15</span>: error: could not find <span class="stReserved">implicit</span> value <span class="stReserved">for</span> parameter typeClass1: <span class="stType">org.scalatest.enablers.Containing[Iterator[Int]]</span>
           it must contain (<span class="stLiteral">2</span>)
              ^
</pre></p><p>Instead, you will need to convert your iterators to a sequence explicitly before using them in matcher expressions:</p><p><pre class="stHighlighted">
scala&gt; it.toStream must contain (<span class="stLiteral">2</span>)
</pre></p><p>We recommend you convert (Scala or Java) iterators to <code>Stream</code>s, as shown in the previous example, so that you can
continue to reap any potential benefits provided by the laziness of the underlying iterator.</p><p><a name="inspectorShorthands"></a></p><h4> Inspector shorthands </h4><p>You can use the <a href="Inspectors.html"><code>Inspectors</code></a> syntax with matchers as well as assertions. If you have a multi-dimensional collection, such as a
list of lists, using <code>Inspectors</code> is your best option:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> yss =
  <span class="stType">List</span>(
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>),
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>),
    <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
  )
<br/>forAll (yss) { ys =&gt;
  forAll (ys) { y =&gt; y must be &gt; <span class="stLiteral">0</span> }
}
</pre></p><p>For assertions on one-dimensional collections, however, matchers provides &quot;inspector shorthands.&quot; Instead of writing:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> xs = <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
forAll (xs) { x =&gt; x must be &lt; <span class="stLiteral">10</span> }
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
all (xs) must be &lt; <span class="stLiteral">10</span>
</pre></p><p>The previous statement asserts that all elements of the <code>xs</code> list must be less than 10.
All of the inspectors have shorthands in matchers. Here is the full list:</p><ul><li><code>all</code> - succeeds if the assertion holds true for every element</li><li><code>atLeast</code> - succeeds if the assertion holds true for at least the specified number of elements</li><li><code>atMost</code> - succeeds if the assertion holds true for at most the specified number of elements</li><li><code>between</code> - succeeds if the assertion holds true for between the specified minimum and maximum number of elements, inclusive</li><li><code>every</code> - same as <code>all</code>, but lists all failing elements if it fails (whereas <code>all</code> just reports the first failing element)</li><li><code>exactly</code> - succeeds if the assertion holds true for exactly the specified number of elements</li></ul><p>Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.MustMatchers._
import org.scalatest.MustMatchers._

scala&gt; val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; all (xs) must be &gt; 0

scala&gt; atMost (2, xs) must be &gt;= 4

scala&gt; atLeast (3, xs) must be &lt; 5

scala&gt; between (2, 3, xs) must (be &gt; 1 and be &lt; 5)

scala&gt; exactly (2, xs) must be &lt;= 2

scala&gt; every (xs) must be &lt; 10

scala&gt; // And one that fails...

scala&gt; exactly (2, xs) mustEqual 2
org.scalatest.exceptions.TestFailedException: 'exactly(2)' inspection failed, because only 1 element
    satisfied the assertion block at index 1:
  at index 0, 1 did not equal 2,
  at index 2, 3 did not equal 2,
  at index 3, 4 did not equal 2,
  at index 4, 5 did not equal 2
in List(1, 2, 3, 4, 5)
        at ...
</pre></p><p>Like <a href=""><code>Inspectors</code></a>, objects used with inspector shorthands can be any type <code>T</code> for which a <code>Collecting[T, E]</code>
is available, which by default includes <code>GenTraversable</code>,
Java <code>Collection</code>, Java <code>Map</code>, <code>Array</code>s, and <code>String</code>s.
Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import MustMatchers._
import MustMatchers._

scala&gt; all (Array(1, 2, 3)) must be &lt; 5

scala&gt; import collection.JavaConverters._
import collection.JavaConverters._

scala&gt; val js = List(1, 2, 3).asJava
js: java.util.List[Int] = [1, 2, 3]

scala&gt; all (js) must be &lt; 5

scala&gt; val jmap = Map("a" -&gt; 1, "b" -&gt; 2).asJava
jmap: java.util.Map[String,Int] = {a=1, b=2}

scala&gt; atLeast(1, jmap) mustBe Entry("b", 2)

scala&gt; atLeast(2, "hello, world!") mustBe 'o'
</pre></p><p><a name="singleElementCollections"></a></p><h4> Single-element collections </h4><p>To assert both that a collection contains just one &quot;lone&quot; element as well as something else about that element, you can use
the <code>loneElement</code> syntax provided by trait <a href="LoneElement.html"><code>LoneElement</code></a>. For example, if a
<code>Set[Int]</code> must contain just one element, an <code>Int</code>
less than or equal to 10, you could write:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> LoneElement._
set.loneElement must be &lt;= <span class="stLiteral">10</span>
</pre></p><p>You can invoke <code>loneElement</code> on any type <code>T</code> for which an implicit <a href="enablers/Collecting.html"><code>Collecting[E, T]</code></a>
is available, where <code>E</code> is the element type returned by the <code>loneElement</code> invocation. By default, you can use <code>loneElement</code>
on <code>GenTraversable</code>, Java <code>Collection</code>, Java <code>Map</code>, <code>Array</code>, and <code>String</code>.</p><p><a name="javaCollectionsAndMaps"></a></p><h4> Java collections and maps </h4><p>You can use similar syntax on Java collections (<code>java.util.Collection</code>) and maps (<code>java.util.Map</code>).
For example, you can check whether a Java <code>Collection</code> or <code>Map</code> is <code>empty</code>,
like this:</p><p><pre class="stHighlighted">
javaCollection must be (<span class="stQuotedString">'empty</span>)
javaMap must be (<span class="stQuotedString">'empty</span>)
</pre></p><p>Even though Java's <code>List</code> type doesn't actually have a <code>length</code> or <code>getLength</code> method,
you can nevertheless check the length of a Java <code>List</code> (<code>java.util.List</code>) like this:</p><p><pre class="stHighlighted">
javaList must have length <span class="stLiteral">9</span>
</pre></p><p>You can check the size of any Java <code>Collection</code> or <code>Map</code>, like this:</p><p><pre class="stHighlighted">
javaMap must have size <span class="stLiteral">20</span>
javaSet must have size <span class="stLiteral">90</span>
</pre></p><p>In addition, you can check whether a Java <code>Collection</code> contains a particular
element, like this:</p><p><pre class="stHighlighted">
javaCollection must contain (<span class="stQuotedString">"five"</span>)
</pre></p><p>One difference to note between the syntax supported on Java and Scala collections is that
in Java, <code>Map</code> is not a subtype of <code>Collection</code>, and does not
actually define an element type. You can ask a Java <code>Map</code> for an &quot;entry set&quot;
via the <code>entrySet</code> method, which will return the <code>Map</code>'s key/value pairs
wrapped in a set of <code>java.util.Map.Entry</code>, but a <code>Map</code> is not actually
a collection of <code>Entry</code>. To make Java <code>Map</code>s easier to work with, however,
ScalaTest matchers allows you to treat a Java <code>Map</code> as a collection of <code>Entry</code>,
and defines a convenience implementation of <code>java.util.Map.Entry</code> in
<a href="Entry.html"><code>org.scalatest.Entry</code></a>. Here's how you use it:</p><p><pre class="stHighlighted">
javaMap must contain (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>))
javaMap must contain oneOf (<span class="stType">Entry</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>), <span class="stType">Entry</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>))
</pre></p><p>You can also just check whether a Java <code>Map</code> contains a particular key, or value, like this:</p><p><pre class="stHighlighted">
javaMap must contain key <span class="stLiteral">1</span>
javaMap must contain value <span class="stQuotedString">"Howdy"</span>
</pre></p><p><a name="stringsAndArraysAsCollections"></a></p><h4> <code>String</code>s and <code>Array</code>s as collections </h4><p>You can also use all the syntax described above for Scala and Java collections on <code>Array</code>s and
<code>String</code>s. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import MustMatchers._
import MustMatchers._

scala&gt; atLeast (2, Array(1, 2, 3)) must be &gt; 1

scala&gt; atMost (2, "halloo") mustBe 'o'

scala&gt; Array(1, 2, 3) mustBe sorted

scala&gt; "abcdefg" mustBe sorted

scala&gt; Array(1, 2, 3) must contain atMostOneOf (3, 4, 5)

scala&gt; "abc" must contain atMostOneOf ('c', 'd', 'e')
</pre></p><p><a name="beAsAnEqualityComparison"></a></p><h4> <code>be</code> as an equality comparison </h4><p>All uses of <code>be</code> other than those shown previously perform an equality comparison. They work
the same as <code>equal</code> when it is used with default equality. This redundancy between <code>be</code> and <code>equals</code> exists in part
because it enables syntax that sometimes sounds more natural. For example, instead of writing:</p><p><pre class="stHighlighted">
result must equal (<span class="stReserved">null</span>)
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
result must be (<span class="stReserved">null</span>)
</pre></p><p>(Hopefully you won't write that too much given <code>null</code> is error prone, and <code>Option</code>
is usually a better, well, option.)
As mentioned <a href="#checkingEqualityWithMatchers">previously</a>, the other difference between <code>equal</code>
and <code>be</code> is that <code>equal</code> delegates the equality check to an <code>Equality</code> typeclass, whereas
<code>be</code> always uses default equality.
Here are some other examples of <code>be</code> used for equality comparison:</p><p><pre class="stHighlighted">
sum must be (<span class="stLiteral">7.0</span>)
boring must be (<span class="stReserved">false</span>)
fun must be (<span class="stReserved">true</span>)
list must be (<span class="stType">Nil</span>)
option must be (<span class="stType">None</span>)
option must be (<span class="stType">Some</span>(<span class="stLiteral">1</span>))
</pre></p><p>As with <code>equal</code> used with default equality, using <code>be</code> on arrays results in <code>deep</code> being called on both arrays prior to
calling <code>equal</code>. As a result,
the following expression would <em>not</em> throw a <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>:</p><p><pre class="stHighlighted">
<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>) must be (<span class="stType">Array</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>)) <span class="stLineComment">// succeeds (i.e., does not throw TestFailedException)</span>
</pre></p><p>Because <code>be</code> is used in several ways in ScalaTest matcher syntax, just as it is used in many ways in English, one
potential point of confusion in the event of a failure is determining whether <code>be</code> was being used as an equality comparison or
in some other way, such as a property assertion. To make it more obvious when <code>be</code> is being used for equality, the failure
messages generated for those equality checks will include the word <code>equal</code> in them. For example, if this expression fails with a
<code>TestFailedException</code>:</p><p><pre class="stHighlighted">
option must be (<span class="stType">Some</span>(<span class="stLiteral">1</span>))
</pre></p><p>The detail message in that <code>TestFailedException</code> will include the words <code>"equal to"</code> to signify <code>be</code>
was in this case being used for equality comparison:</p><p><pre class="stHighlighted">
<span class="stType">Some</span>(<span class="stLiteral">2</span>) was not equal to <span class="stType">Some</span>(<span class="stLiteral">1</span>)
</pre></p><p><a name="beingNegative"></a></p><h4> Being negative </h4><p>If you wish to check the opposite of some condition, you can simply insert <code>not</code> in the expression.
Here are a few examples:</p><p><pre class="stHighlighted">
result must not be (<span class="stReserved">null</span>)
sum must not be &lt;= (<span class="stLiteral">10</span>)
mylist must not equal (yourList)
string must not startWith (<span class="stQuotedString">"Hello"</span>)
</pre></p><p><a name="checkingThatCodeDoesNotCompile"></a></p><h4> Checking that a snippet of code does not compile </h4><p>Often when creating libraries you may wish to ensure that certain arrangements of code that
represent potential &ldquo;user errors&rdquo; do not compile, so that your library is more error resistant.
ScalaTest <code>Matchers</code> trait includes the following syntax for that purpose:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: String = 1"</span> mustNot compile
</pre></p><p>If you want to ensure that a snippet of code does not compile because of a type error (as opposed
to a syntax error), use:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: String = 1"</span> mustNot typeCheck
</pre></p><p>Note that the <code>mustNot</code> <code>typeCheck</code> syntax will only succeed if the given snippet of code does not
compile because of a type error. A syntax error will still result in a thrown <code>TestFailedException</code>.</p><p>If you want to state that a snippet of code <em>does</em> compile, you can make that
more obvious with:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"val a: Int = 1"</span> must compile
</pre></p><p>Although the previous three constructs are implemented with macros that determine at compile time whether
the snippet of code represented by the string does or does not compile, errors
are reported as test failures at runtime.</p><p><a name="logicalExpressions"></a></p><h4> Logical expressions with <code>and</code> and <code>or</code> </h4><p>You can also combine matcher expressions with <code>and</code> and/or <code>or</code>, however,
you must place parentheses or curly braces around the <code>and</code> or <code>or</code> expression. For example,
this <code>and</code>-expression would not compile, because the parentheses are missing:</p><p><pre class="stHighlighted">
map must contain key (<span class="stQuotedString">"two"</span>) and not contain value (<span class="stLiteral">7</span>) <span class="stLineComment">// ERROR, parentheses missing!</span>
</pre></p><p>Instead, you need to write:</p><p><pre class="stHighlighted">
map must (contain key (<span class="stQuotedString">"two"</span>) and not contain value (<span class="stLiteral">7</span>))
</pre></p><p>Here are some more examples:</p><p><pre class="stHighlighted">
number must (be &gt; (<span class="stLiteral">0</span>) and be &lt;= (<span class="stLiteral">10</span>))
option must (equal (<span class="stType">Some</span>(<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>))) or be (<span class="stType">None</span>))
string must (
  equal (<span class="stQuotedString">"fee"</span>) or
  equal (<span class="stQuotedString">"fie"</span>) or
  equal (<span class="stQuotedString">"foe"</span>) or
  equal (<span class="stQuotedString">"fum"</span>)
)
</pre></p><p>Two differences exist between expressions composed of these <code>and</code> and <code>or</code> operators and the expressions you can write
on regular <code>Boolean</code>s using its <code>&amp;&amp;</code> and <code>||</code> operators. First, expressions with <code>and</code>
and <code>or</code> do not short-circuit. The following contrived expression, for example, would print <code>"hello, world!"</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"yellow"</span> must (equal (<span class="stQuotedString">"blue"</span>) and equal { println(<span class="stQuotedString">"hello, world!"</span>); <span class="stQuotedString">"green"</span> })
</pre></p><p>In other words, the entire <code>and</code> or <code>or</code> expression is always evaluated, so you'll see any side effects
of the right-hand side even if evaluating
only the left-hand side is enough to determine the ultimate result of the larger expression. Failure messages produced by these
expressions will &quot;short-circuit,&quot; however,
mentioning only the left-hand side if that's enough to determine the result of the entire expression. This &quot;short-circuiting&quot; behavior
of failure messages is intended
to make it easier and quicker for you to ascertain which part of the expression caused the failure. The failure message for the previous
expression, for example, would be:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"yellow"</span> did not equal <span class="stQuotedString">"blue"</span>
</pre></p><p>Most likely this lack of short-circuiting would rarely be noticeable, because evaluating the right hand side will usually not
involve a side effect. One situation where it might show up, however, is if you attempt to <code>and</code> a <code>null</code> check on a variable with an expression
that uses the variable, like this:</p><p><pre class="stHighlighted">
map must (not be (<span class="stReserved">null</span>) and contain key (<span class="stQuotedString">"ouch"</span>))
</pre></p><p>If <code>map</code> is <code>null</code>, the test will indeed fail, but with a <code>NullArgumentException</code>, not a
<code>TestFailedException</code>. Here, the <code>NullArgumentException</code> is the visible right-hand side effect. To get a
<code>TestFailedException</code>, you would need to check each assertion separately:</p><p><pre class="stHighlighted">
map must not be (<span class="stReserved">null</span>)
map must contain key (<span class="stQuotedString">"ouch"</span>)
</pre></p><p>If <code>map</code> is <code>null</code> in this case, the <code>null</code> check in the first expression will fail with
a <code>TestFailedException</code>, and the second expression will never be executed.</p><p>The other difference with <code>Boolean</code> operators is that although <code>&amp;&amp;</code> has a higher precedence than <code>||</code>,
<code>and</code> and <code>or</code>
have the same precedence. Thus although the <code>Boolean</code> expression <code>(a || b &amp;&amp; c)</code> will evaluate the <code>&amp;&amp;</code> expression
before the <code>||</code> expression, like <code>(a || (b &amp;&amp; c))</code>, the following expression:</p><p><pre class="stHighlighted">
traversable must (contain (<span class="stLiteral">7</span>) or contain (<span class="stLiteral">8</span>) and have size (<span class="stLiteral">9</span>))
</pre></p><p>Will evaluate left to right, as:</p><p><pre class="stHighlighted">
traversable must ((contain (<span class="stLiteral">7</span>) or contain (<span class="stLiteral">8</span>)) and have size (<span class="stLiteral">9</span>))
</pre></p><p>If you really want the <code>and</code> part to be evaluated first, you'll need to put in parentheses, like this:</p><p><pre class="stHighlighted">
traversable must (contain (<span class="stLiteral">7</span>) or (contain (<span class="stLiteral">8</span>) and have size (<span class="stLiteral">9</span>)))
</pre></p><p><a name="workingWithOptions"></a></p><h4> Working with <code>Option</code>s </h4><p>You can work with options using ScalaTest's equality, <code>empty</code>,
<code>defined</code>, and <code>contain</code> syntax.
For example, if you wish to check whether an option is <code>None</code>, you can write any of:</p><p><pre class="stHighlighted">
option mustEqual <span class="stType">None</span>
option mustBe <span class="stType">None</span>
option must === (<span class="stType">None</span>)
option mustBe empty
</pre></p><p>If you wish to check an option is defined, and holds a specific value, you can write any of:</p><p><pre class="stHighlighted">
option mustEqual <span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>)
option mustBe <span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>)
option must === (<span class="stType">Some</span>(<span class="stQuotedString">"hi"</span>))
</pre></p><p>If you only wish to check that an option is defined, but don't care what it's value is, you can write:</p><p><pre class="stHighlighted">
option mustBe defined
</pre></p><p>If you mix in (or import the members of) <a href="OptionValues.html"><code>OptionValues</code></a>,
you can write one statement that indicates you believe an option must be defined and then say something else about its value. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.OptionValues._
option.value must be &lt; <span class="stLiteral">7</span>
</pre></p><p>As mentioned previously, you can use also use ScalaTest's <code>contain</code>, <code>contain oneOf</code>, and
<code>contain noneOf</code> syntax with options:</p><p><pre class="stHighlighted">
<span class="stType">Some</span>(<span class="stLiteral">2</span>) must contain (<span class="stLiteral">2</span>)
<span class="stType">Some</span>(<span class="stLiteral">7</span>) must contain oneOf (<span class="stLiteral">5</span>, <span class="stLiteral">7</span>, <span class="stLiteral">9</span>)
<span class="stType">Some</span>(<span class="stLiteral">0</span>) must contain noneOf (<span class="stLiteral">7</span>, <span class="stLiteral">8</span>, <span class="stLiteral">9</span>)
</pre></p><p><a name="checkingArbitraryProperties"></a></p><h4> Checking arbitrary properties with <code>have</code> </h4><p>Using <code>have</code>, you can check properties of any type, where a <em>property</em> is an attribute of any
object that can be retrieved either by a public field, method, or JavaBean-style <code>get</code>
or <code>is</code> method, like this:</p><p><pre class="stHighlighted">
book must have (
  <span class="stQuotedString">'title</span> (<span class="stQuotedString">"Programming in Scala"</span>),
  <span class="stQuotedString">'author</span> (<span class="stType">List</span>(<span class="stQuotedString">"Odersky"</span>, <span class="stQuotedString">"Spoon"</span>, <span class="stQuotedString">"Venners"</span>)),
  <span class="stQuotedString">'pubYear</span> (<span class="stLiteral">2008</span>)
)
</pre></p><p>This expression will use reflection to ensure the <code>title</code>, <code>author</code>, and <code>pubYear</code> properties of object <code>book</code>
are equal to the specified values. For example, it will ensure that <code>book</code> has either a public Java field or method
named <code>title</code>, or a public method named <code>getTitle</code>, that when invoked (or accessed in the field case) results
in the string <code>"Programming in Scala"</code>. If all specified properties exist and have their expected values, respectively,
execution will continue. If one or more of the properties either does not exist, or exists but results in an unexpected value,
a <code>TestFailedException</code> will be thrown that explains the problem. (For the details on how a field or method is selected during this
process, see the documentation for <a href="Matchers$HavePropertyMatcherGenerator.html"><code>HavePropertyMatcherGenerator</code></a>.)</p><p>When you use this syntax, you must place one or more property values in parentheses after <code>have</code>, separated by commas, where a <em>property
value</em> is a symbol indicating the name of the property followed by the expected value in parentheses. The only exceptions to this rule is the syntax
for checking size and length shown previously, which does not require parentheses. If you forget and put parentheses in, however, everything will
still work as you'd expect. Thus instead of writing:</p><p><pre class="stHighlighted">
array must have length (<span class="stLiteral">3</span>)
set must have size (<span class="stLiteral">90</span>)
</pre></p><p>You can alternatively, write:</p><p><pre class="stHighlighted">
array must have (length (<span class="stLiteral">3</span>))
set must have (size (<span class="stLiteral">90</span>))
</pre></p><p>If a property has a value different from the specified expected value, a <code>TestFailedError</code> will be thrown
with a detailed message that explains the problem. For example, if you assert the following on
a <code>book</code> whose title is <code>Moby Dick</code>:</p><p><pre class="stHighlighted">
book must have (<span class="stQuotedString">'title</span> (<span class="stQuotedString">"A Tale of Two Cities"</span>))
</pre></p><p>You'll get a <code>TestFailedException</code> with this detail message:</p><p><pre>
The title property had value "Moby Dick", instead of its expected value "A Tale of Two Cities",
on object Book("Moby Dick", "Melville", 1851)
</pre></p><p>If you prefer to check properties in a type-safe manner, you can use a <code>HavePropertyMatcher</code>.
This would allow you to write expressions such as:</p><p><pre class="stHighlighted">
book must have (
  title (<span class="stQuotedString">"Programming in Scala"</span>),
  author (<span class="stType">List</span>(<span class="stQuotedString">"Odersky"</span>, <span class="stQuotedString">"Spoon"</span>, <span class="stQuotedString">"Venners"</span>)),
  pubYear (<span class="stLiteral">2008</span>)
)
</pre></p><p>These expressions would fail to compile if <code>must</code> is used on an inappropriate type, as determined
by the type parameter of the <code>HavePropertyMatcher</code> being used. (For example, <code>title</code> in this example
might be of type <code>HavePropertyMatcher[org.publiclibrary.Book]</code>. If used with an appropriate type, such an expression will compile
and at run time the property method or field will be accessed directly; <em>i.e.</em>, no reflection will be used.
See the documentation for <a href="matchers/HavePropertyMatcher.html"><code>HavePropertyMatcher</code></a> for more information.</p><p><a name="lengthSizeHavePropertyMatchers"></a></p><h4> Using <code>length</code> and <code>size</code> with <code>HavePropertyMatcher</code>s </h4><p>If you want to use <code>length</code> or <code>size</code> syntax with your own custom <code>HavePropertyMatcher</code>s, you
can do so, but you must write <code>(of [&ldquo;the type&rdquo;])</code> afterwords. For example, you could write:</p><p><pre class="stHighlighted">
book must have (
  title (<span class="stQuotedString">"A Tale of Two Cities"</span>),
  length (<span class="stLiteral">220</span>) (of [<span class="stType">Book</span>]),
  author (<span class="stQuotedString">"Dickens"</span>)
)
</pre></p><p>Prior to ScalaTest 2.0, &ldquo;<code>length</code> <code>(22)</code>&rdquo; yielded a <code>HavePropertyMatcher[Any, Int]</code> that used reflection to dynamically look
for a <code>length</code> field or <code>getLength</code> method. In ScalaTest 2.0, &ldquo;<code>length</code> <code>(22)</code>&rdquo; yields a
<code>MatcherFactory1[Any, Length]</code>, so it is no longer a <code>HavePropertyMatcher</code>. The <code>(of [&lt;type&gt;])</code> syntax converts the
the <code>MatcherFactory1[Any, Length]</code> to a <code>HavePropertyMatcher[&lt;type&gt;, Int]</code>.</p><p><a name="matchingAPattern"></a></p><h4> Checking that an expression matches a pattern </h4><p>ScalaTest's <a href="Inside.html"><code>Inside</code></a> trait allows you to make assertions after a pattern match.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Name</span>(first: <span class="stType">String</span>, middle: <span class="stType">String</span>, last: <span class="stType">String</span>)
<br/><span class="stReserved">val</span> name = <span class="stType">Name</span>(<span class="stQuotedString">"Jane"</span>, <span class="stQuotedString">"Q"</span>, <span class="stQuotedString">"Programmer"</span>)
<br/>inside(name) { <span class="stReserved">case</span> <span class="stType">Name</span>(first, _, _) =&gt;
  first must startWith (<span class="stQuotedString">"S"</span>)
}
</pre></p><p>You can use <code>inside</code> to just ensure a pattern is matched, without making any further assertions, but a better
alternative for that kind of assertion is <code>matchPattern</code>. The <code>matchPattern</code> syntax allows you
to express that you expect a value to match a particular pattern, no more and no less:</p><p><pre class="stHighlighted">
name must matchPattern { <span class="stReserved">case</span> <span class="stType">Name</span>(<span class="stQuotedString">"Sarah"</span>, _, _) =&gt; }
</pre></p><p><a name="usingCustomMatchers"></a></p><h4> Using custom matchers </h4><p>If none of the built-in matcher syntax (or options shown so far for extending the syntax) satisfy a particular need you have, you can create
custom <code>Matcher</code>s that allow
you to place your own syntax directly after <code>must</code>. For example, class <code>java.io.File</code> has a method <code>isHidden</code>, which
indicates whether a file of a certain path and name is hidden. Because the <code>isHidden</code> method takes no parameters and returns <code>Boolean</code>,
you can call it using <code>be</code> with a symbol or <code>BePropertyMatcher</code>, yielding assertions like:</p><p><pre class="stHighlighted">
file must be (<span class="stQuotedString">'hidden</span>)  <span class="stLineComment">// using a symbol</span>
file must be (hidden)   <span class="stLineComment">// using a BePropertyMatcher</span>
</pre></p><p>If it doesn't make sense to have your custom syntax follow <code>be</code>, you might want to create a custom <code>Matcher</code>
instead, so your syntax can follow <code>must</code> directly. For example, you might want to be able to check whether
a <code>java.io.File</code>'s name ends with a particular extension, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// using a plain-old Matcher</span>
file must endWithExtension (<span class="stQuotedString">"txt"</span>)
</pre></p><p>ScalaTest provides several mechanism to make it easy to create custom matchers, including ways to compose new matchers
out of existing ones complete with new error messages.  For more information about how to create custom
<code>Matcher</code>s, please see the documentation for the <a href="matchers/Matcher.html"><code>Matcher</code></a> trait.</p><p><a name="checkingForExpectedExceptions"></a></p><h4> Checking for expected exceptions </h4><p>Sometimes you need to test whether a method throws an expected exception under certain circumstances, such
as when invalid arguments are passed to the method. With <code>Matchers</code> mixed in, you can
check for an expected exception like this:</p><p><pre class="stHighlighted">
an [<span class="stType">IndexOutOfBoundsException</span>] must be thrownBy s.charAt(-<span class="stLiteral">1</span>)
</pre></p><p>If <code>charAt</code> throws an instance of <code>StringIndexOutOfBoundsException</code>,
this expression will result in that exception. But if <code>charAt</code> completes normally, or throws a different
exception, this expression will complete abruptly with a <code>TestFailedException</code>.</p><p>If you need to further inspect an expected exception, you can capture it using this syntax:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> thrown = the [<span class="stType">IndexOutOfBoundsException</span>] thrownBy s.charAt(-<span class="stLiteral">1</span>)
</pre></p><p>This expression returns the caught exception so that you can inspect it further if you wish, for
example, to ensure that data contained inside the exception has the expected values. Here's an
example:</p><p><pre class="stHighlighted">
thrown.getMessage must equal (<span class="stQuotedString">"String index out of range: -1"</span>)
</pre></p><p>If you prefer you can also capture and inspect an expected exception in one statement, like this:</p><p><pre class="stHighlighted">
the [<span class="stType">ArithmeticException</span>] thrownBy <span class="stLiteral">1</span> / <span class="stLiteral">0</span> must have message <span class="stQuotedString">"/ by zero"</span>
the [<span class="stType">IndexOutOfBoundsException</span>] thrownBy {
  s.charAt(-<span class="stLiteral">1</span>)
} must have message <span class="stQuotedString">"String index out of range: -1"</span>
</pre></p><p>You can also state that no exception must be thrown by some code, like this:</p><p><pre class="stHighlighted">
noException must be thrownBy <span class="stLiteral">0</span> / <span class="stLiteral">1</span>
</pre></p><p><a name="thosePeskyParens"></a></p><h4> Those pesky parens </h4><p>Perhaps the most tricky part of writing assertions using ScalaTest matchers is remembering
when you need or don't need parentheses, but bearing in mind a few simple rules  should help.
It is also reassuring to know that if you ever leave off a set of parentheses when they are
required, your code will not compile. Thus the compiler will help you remember when you need the parens.
That said, the rules are:</p><p>1. Although you don't always need them, you may choose to always put parentheses
around right-hand values, such as the <code>7</code> in <code>num must equal (7)</code>:</p><p><pre>
result must equal <span class="stRed">(</span>4<span class="stRed">)</span>
array must have length <span class="stRed">(</span>3<span class="stRed">)</span>
book must have (
  'title <span class="stRed">(</span>"Programming in Scala"<span class="stRed">)</span>,
  'author <span class="stRed">(</span>List("Odersky", "Spoon", "Venners")<span class="stRed">)</span>,
  'pubYear <span class="stRed">(</span>2008<span class="stRed">)</span>
)
option must be <span class="stRed">(</span>'defined<span class="stRed">)</span>
catMap must (contain key <span class="stRed">(</span>9<span class="stRed">)</span> and contain value <span class="stRed">(</span>"lives"<span class="stRed">)</span>)</span>
keyEvent must be an <span class="stRed">(</span>'actionKey<span class="stRed">)</span>
javaSet must have size <span class="stRed">(</span>90<span class="stRed">)</span>
</pre></p><p>2. Except for <code>length</code>, <code>size</code> and <code>message</code>, you must always put parentheses around
the list of one or more property values following a <code>have</code>:</p><p><pre>
file must (exist and have <span class="stRed">(</span>'name ("temp.txt")<span class="stRed">)</span>)
book must have <span class="stRed">(</span>
  title ("Programming in Scala"),
  author (List("Odersky", "Spoon", "Venners")),
  pubYear (2008)
<span class="stRed">)</span>
javaList must have length (9) // parens optional for length and size
</pre></p><p>3. You must always put parentheses around <code>and</code> and <code>or</code> expressions, as in:</p><p><pre>
catMap must <span class="stRed">(</span>contain key (9) and contain value ("lives")<span class="stRed">)</span>
number must <span class="stRed">(</span>equal (2) or equal (4) or equal (8)<span class="stRed">)</span>
</pre></p><p>4. Although you don't always need them, you may choose to always put parentheses
around custom <code>Matcher</code>s when they appear directly after <code>not</code>:</p><p><pre>
file must exist
file must not <span class="stRed">(</span>exist<span class="stRed">)</span>
file must (exist and have ('name ("temp.txt")))
file must (not <span class="stRed">(</span>exist<span class="stRed">)</span> and have ('name ("temp.txt"))
file must (have ('name ("temp.txt") or exist)
file must (have ('name ("temp.txt") or not <span class="stRed">(</span>exist<span class="stRed">)</span>)
</pre></p><p>That's it. With a bit of practice it  should become natural to you, and the compiler will always be there to tell you if you
forget a set of needed parentheses.</p><p><em>Note: ScalaTest's matchers are in part inspired by the matchers of <a href="http://rspec.info" target="_blank">RSpec</a>,
<a href="https://github.com/hamcrest/JavaHamcrest" target="_blank">Hamcrest</a>, and
<a href="http://etorreborre.github.io/specs2/" target="_blank">specs2</a>, and its &ldquo;<code>mustNot compile</code>&rdquo; syntax
by the <code>illTyped</code> macro of <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a>.</em></p></div></div>
    </li><li name="org.scalatest.NonImplicitAssertions" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NonImplicitAssertionsextendsAssertions"></a><a id="NonImplicitAssertions:NonImplicitAssertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#NonImplicitAssertionsextendsAssertions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that can be mixed into a Suite to disable the implicit conversions provided by default in trait Assertions, which trait Suite extends." href="NonImplicitAssertions.html"><span class="name">NonImplicitAssertions</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that can be mixed into a <code>Suite</code> to disable the implicit conversions provided by default in trait
<a href="Assertions.html"><code>Assertions</code></a>, which trait <code>Suite</code> extends.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that can be mixed into a <code>Suite</code> to disable the implicit conversions provided by default in trait
<a href="Assertions.html"><code>Assertions</code></a>, which trait <code>Suite</code> extends.</p><p>This trait can be used to quickly solve a problem in which ScalaTest's default implicit conversion is clashing with those of some other library
you need to use in your tests. After mixing in this trait, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MySuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">NonImplicitAssertions</span> {
  <span class="stLineComment">// ... </span>
}
</pre></p><p>You can write tests using <code>assert</code> (without triple equals), <code>assertResult</code>, <code>assertThrows</code>,
<code>intercept</code>, <code>assertCompiles</code>, <code>assertDoesNotCompile</code>, and <code>assertTypeError</code>:</p><p><pre class="stHighlighted">
assert(a &lt; <span class="stLiteral">7</span>)
<br/>assertResult(<span class="stLiteral">2</span>) { <span class="stLiteral">1</span> + <span class="stLiteral">1</span> }
<br/>assertThrows[<span class="stType">IndexOutOfBoundsException</span>] {
  <span class="stQuotedString">"hi"</span>.charAt(-<span class="stLiteral">1</span>)
}
<br/><span class="stReserved">val</span> caught =
  intercept[<span class="stType">IndexOutOfBoundsException</span>] {
    <span class="stQuotedString">"hi"</span>.charAt(-<span class="stLiteral">1</span>)
  }
<br/>assertDoesNotCompile(<span class="stQuotedString">"val a: String = 1"</span>)
<br/>assertTypeError(<span class="stQuotedString">"val a: String = 1"</span>)
<br/>assertCompiles(<span class="stQuotedString">"val a: Int = 1"</span>)
</pre>
</p></div></div>
    </li><li name="org.scalatest.Notifier" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NotifierextendsAnyRef"></a><a id="Notifier:Notifier"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#NotifierextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing an apply method to which status updates about a running suite of tests can be reported." href="Notifier.html"><span class="name">Notifier</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing an <code>apply</code> method to which status updates about a running suite of tests can be reported.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an <code>apply</code> method to which status updates about a running suite of tests can be reported.</p><p>An <code>Notifier</code> is essentially
used to wrap a <code>Reporter</code> and provide easy ways to send status updates
to that <code>Reporter</code> via an <code>NoteProvided</code> event.
<code>Notifier</code> contains an <code>apply</code> method that takes a string and
an optional payload object of type <code>Any</code>.
The <code>Notifier</code> will forward the passed alert <code>message</code> string to the
<a href="Reporter.html"><code>Reporter</code></a> as the <code>message</code> parameter, and the optional
payload object as the <code>payload</code> parameter, of an <a href="NoteProvided.html"><code>NoteProvided</code></a> event.</p><p>For insight into the differences between <code>Notifier</code>, <code>Alerter</code>, and <code>Informer</code>, see the
main documentation for trait <a href="Notifying.html"><code>Notifying</code></a>.</p></div></div>
    </li><li name="org.scalatest.Notifying" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NotifyingextendsAnyRef"></a><a id="Notifying:Notifying"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#NotifyingextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains the note method, which can be used to send a status notification to the reporter." href="Notifying.html"><span class="name">Notifying</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains the <code>note</code> method, which can be used to send a status notification to the reporter.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains the <code>note</code> method, which can be used to send a status notification to the reporter.</p><p>The difference between <code>note</code> and the <code>info</code> method of <a href="Informer.html"><code>Informer</code></a> is that
<code>info</code> messages provided during a test are recorded and sent as part of test completion event, whereas
<code>note</code> messages are sent right away as <a href="events/NoteProvided.html"><code>NoteProvided</code></a> messages. For long-running tests,
<code>note</code> allows you to send &quot;status notifications&quot; to the reporter right away, so users can track the
progress of the long-running tests. By contrast, <code>info</code> messages will only be seen by the user after the
test has completed, and are more geared towards specification (such as <a href="GivenWhenThen.html">Given/When/Then</a> messages) than notification.</p><p>The difference between <code>note</code> and the <code>alert</code> method of <a href="Alerting.html"><code>Alerting</code></a> is
that <code>alert</code> is intended to be used
for warnings or notifications of potential problems, whereas <code>note</code> is just for status notifications.
In string reporters for which ANSI color is enabled, <code>note</code> notifications are shown in green and <code>alert</code> notifications
in yellow.</p></div></div>
    </li><li name="org.scalatest.OneInstancePerTest" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OneInstancePerTestextendsSuiteMixin"></a><a id="OneInstancePerTest:OneInstancePerTest"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OneInstancePerTestextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that facilitates a style of testing in which each test is run in its own instance of the suite class to isolate each test from the side effects of the other tests in the suite." href="OneInstancePerTest.html"><span class="name">OneInstancePerTest</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that facilitates a style of testing in which each test is run in its own instance
of the suite class to isolate each test from the side effects of the other tests in the
suite.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that facilitates a style of testing in which each test is run in its own instance
of the suite class to isolate each test from the side effects of the other tests in the
suite.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>: Trait <code>OneInstancePerTest</code> is intended primarily to serve as a supertrait for
<a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a> and the <a href="path/package.html">path traits</a>, to
facilitate porting JUnit tests to ScalaTest, and to make it easy for users who prefer JUnit's approach to isolation to obtain similar
behavior in ScalaTest.
</td></tr></table></p><p>If you mix this trait into a <a href="Suite.html"><code>Suite</code></a>, you can initialize shared reassignable
fixture variables as well as shared mutable fixture objects in the constructor of the
class. Because each test will run in its own instance of the class, each test will
get a fresh copy of the instance variables. This is the approach to test isolation taken,
for example, by the JUnit framework. <code>OneInstancePerTest</code> can, therefore,
be handy when porting JUnit tests to ScalaTest.</p><p>Here's an example of <code>OneInstancePerTest</code> being used in a <code>FunSuite</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FunSuite
<span class="stReserved">import</span> org.scalatest.OneInstancePerTest
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">MySuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">OneInstancePerTest</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  test(<span class="stQuotedString">"easy"</span>) {
    builder.append(<span class="stQuotedString">"easy!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">"sweet"</span>
  }
<br/>  test(<span class="stQuotedString">"fun"</span>) {
    builder.append(<span class="stQuotedString">"fun!"</span>)
    assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p><p><code>OneInstancePerTest</code> is supertrait to <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a>, in which
running each test in its own instance is intended to make it easier to write suites of tests that run in parallel (by reducing the likelihood
of concurrency bugs in those suites.) <code>OneInstancePerTest</code> is also supertrait to the <em>path</em> traits,
<a href="path/FunSpec.html"><code>path.FunSpec</code></a> and <a href="path/FreeSpec.html"><code>path.FreeSpec</code></a>, to make it obvious
these traits run each test in a new, isolated instance.</p><p>For the details on how <code>OneInstancePerTest</code> works, see the documentation for methods <code>runTests</code> and <code>runTest</code>,
which this trait overrides.</p></div></div>
    </li><li name="org.scalatest.OptionValues" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OptionValuesextendsAnyRef"></a><a id="OptionValues:OptionValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OptionValuesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides an implicit conversion that adds a value method to Option, which will return the value of the option if it is defined, or throw TestFailedException if not." href="OptionValues.html"><span class="name">OptionValues</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides an implicit conversion that adds a <code>value</code> method
to <code>Option</code>, which will return the value of the option if it is defined,
or throw <code>TestFailedException</code> if not.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides an implicit conversion that adds a <code>value</code> method
to <code>Option</code>, which will return the value of the option if it is defined,
or throw <code>TestFailedException</code> if not.</p><p>This construct allows you to express in one statement that an option should be defined
and that its value should meet some expectation. Here's an example:</p><p><pre class="stHighlighted">
opt.value should be &gt; <span class="stLiteral">9</span>
</pre></p><p>Or, using an assertion instead of a matcher expression:</p><p><pre class="stHighlighted">
assert(opt.value &gt; <span class="stLiteral">9</span>)
</pre></p><p>Were you to simply invoke <code>get</code> on the <code>Option</code>,
if the option wasn't defined, it would throw a <code>NoSuchElementException</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> opt: <span class="stType">Option[Int]</span> = <span class="stType">None</span>
<br/>opt.get should be &gt; <span class="stLiteral">9</span> <span class="stLineComment">// opt.get throws NoSuchElementException</span>
</pre></p><p>The <code>NoSuchElementException</code> would cause the test to fail, but without providing a <a href="exceptions/StackDepth.html">stack depth</a> pointing
to the failing line of test code. This stack depth, provided by <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a> (and a
few other ScalaTest exceptions), makes it quicker for
users to navigate to the cause of the failure. Without <code>OptionValues</code>, to get
a stack depth exception you would need to make two statements, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> opt: <span class="stType">Option[Int]</span> = <span class="stType">None</span>
<br/>opt should be (<span class="stQuotedString">'defined</span>) <span class="stLineComment">// throws TestFailedException</span>
opt.get should be &gt; <span class="stLiteral">9</span>
</pre></p><p>The <code>OptionValues</code> trait allows you to state that more concisely:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> opt: <span class="stType">Option[Int]</span> = <span class="stType">None</span>
<br/>opt.value should be &gt; <span class="stLiteral">9</span> <span class="stLineComment">// opt.value throws TestFailedException</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Outcome" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OutcomeextendsProductwithSerializable"></a><a id="Outcome:Outcome"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OutcomeextendsProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Superclass for the possible outcomes of running a test." href="Outcome.html"><span class="name">Outcome</span></a><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Superclass for the possible outcomes of running a test.</p><div class="fullcomment"><div class="comment cmt"><p>Superclass for the possible outcomes of running a test.</p><p><code>Outcome</code> is the result type of the <code>withFixture</code> methods of traits
<a href="Suite.html#withFixture"><code>Suite</code></a> and <a href="fixture/Suite.html#withFixture"><code>fixture.Suite</code></a>, as well as their
<a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> and <a href="fixture/Suite$OneArgTest.html"><code>OneArgTest</code></a> function types.
The four possible outcomes are:</p><ul><li><a href="Succeeded$.html"><code>Succeeded</code></a> - indicates a test succeeded</li><li><a href="Failed.html"><code>Failed</code></a> - indicates a test failed and contains an exception describing the failure</li><li><a href="Canceled.html"><code>Canceled</code></a> - indicates a test was canceled and contains an exception describing the cancelation</li><li><a href="Pending$.html"><code>Pending</code></a> - indicates a test was pending</li></ul><p>Note that &quot;ignored&quot; does not appear as a type of <code>Outcome</code>, because tests are
marked as ignored on the outside and skipped over as the suite executes. So an ignored test never runs, and therefore
never has an outcome. By contrast, a test is determined to be pending by running the test
and observing the actual outcome. If the test body completes abruptly with a <code>TestPendingException</code>,
then the outcome was that the test was pending.</p></div></div>
    </li><li name="org.scalatest.OutcomeOf" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OutcomeOfextendsAnyRef"></a><a id="OutcomeOf:OutcomeOf"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OutcomeOfextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that contains the outcomeOf method, which executes a passed code block and transforms the outcome into an Outcome, using the same mechanism used by ScalaTest to produce an Outcome when executing a test." href="OutcomeOf.html"><span class="name">OutcomeOf</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that contains the <code>outcomeOf</code> method, which executes a passed code block and
transforms the outcome into an <a href="Outcome.html"><code>Outcome</code></a>, using the
same mechanism used by ScalaTest to produce an <code>Outcome</code> when executing
a test.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains the <code>outcomeOf</code> method, which executes a passed code block and
transforms the outcome into an <a href="Outcome.html"><code>Outcome</code></a>, using the
same mechanism used by ScalaTest to produce an <code>Outcome</code> when executing
a test.</p><p>For an example of <code>outcomeOf</code> in action, see the documentation for
class <a href="prop/TableFor2.html"><code>TableFor2</code></a>.</p></div></div>
    </li><li name="org.scalatest.ParallelTestExecution" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ParallelTestExecutionextendsOneInstancePerTest"></a><a id="ParallelTestExecution:ParallelTestExecution"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ParallelTestExecutionextendsOneInstancePerTest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that causes that the tests of any suite it is mixed into to be run in parallel if a Distributor is passed to runTests." href="ParallelTestExecution.html"><span class="name">ParallelTestExecution</span></a><span class="result"> extends <a href="OneInstancePerTest.html" class="extype" name="org.scalatest.OneInstancePerTest">OneInstancePerTest</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that causes that the tests of any suite it is mixed into to be run in parallel if
a <code>Distributor</code> is passed to <code>runTests</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that causes that the tests of any suite it is mixed into to be run in parallel if
a <code>Distributor</code> is passed to <code>runTests</code>.</p><p>ScalaTest's normal approach for running suites of tests in parallel is to run different suites in parallel,
but the tests of any one suite sequentially. This approach should provide sufficient distribution of the work load
in most cases, but some suites may encapsulate multiple long-running tests. Such suites may dominate the execution
time of the run. If so, mixing in this trait into just those suites will allow their long-running tests to run in parallel with each
other, thereby helping to reduce the total time required to run an entire run.</p><p>To make it easier for users to write tests that run in parallel, this trait runs each test in its own instance of the class.
Running each test in its own instance enables tests to use the same instance <code>vars</code> and mutable objects referenced from
instance variables without needing to synchronize. Although ScalaTest provides functional approaches to
factoring out common test code that can help avoid such issues, running each test in its own instance is an insurance policy that makes
running tests in parallel easier and less error prone.</p><p>For the details on how <code>ParallelTestExecution</code> works, see the documentation for methods <code>run</code>, <code>runTests</code>, and <code>runTest</code>,
which this trait overrides.</p><p>Note: This trait's implementation of <code>runTest</code> is <code>final</code>, to ensure that behavior
related to individual tests are executed by the same thread that executes the actual test. This means,
for example, that you won't be allowed to write <code>...with ParallelTestExecution with BeforeAndAfter</code>.
Instead, you'd need to put <code>ParallelTestExecution</code> last, as
in: <code>with BeforeAndAfter with ParallelTestExecution</code>. For more details, see the documentation
for the <code>runTest</code> method.</p></div></div>
    </li><li name="org.scalatest.PartialFunctionValues" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PartialFunctionValuesextendsAnyRef"></a><a id="PartialFunctionValues:PartialFunctionValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PartialFunctionValuesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides an implicit conversion that adds a valueAt method to PartialFunction, which will return the value (result) of the function applied to the argument passed to valueAt, or throw TestFailedException if the partial function is not defined at the argument." href="PartialFunctionValues.html"><span class="name">PartialFunctionValues</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides an implicit conversion that adds a <code>valueAt</code> method
to <code>PartialFunction</code>, which will return the value (result) of the function applied to the argument passed to <code>valueAt</code>,
or throw <code>TestFailedException</code> if the partial function is not defined at the argument.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides an implicit conversion that adds a <code>valueAt</code> method
to <code>PartialFunction</code>, which will return the value (result) of the function applied to the argument passed to <code>valueAt</code>,
or throw <code>TestFailedException</code> if the partial function is not defined at the argument.</p><p>This construct allows you to express in one statement that a partial function should be defined for a particular input,
and that its result value should meet some expectation. Here's an example:</p><p><pre class="stHighlighted">
pf.valueAt(<span class="stQuotedString">"IV"</span>) should equal (<span class="stLiteral">4</span>)
</pre></p><p>Or, using an assertion instead of a matcher expression:</p><p><pre class="stHighlighted">
assert(pf.valueAt(<span class="stQuotedString">"IV"</span>) === <span class="stLiteral">4</span>)
</pre></p><p>Were you to simply invoke <code>apply</code> on the <code>PartialFunction</code>, passing in an input value,
if the partial function wasn't defined at that input, it would throw some exception, but likely not one
that provides a <a href="exceptions/StackDepth.html">stack depth</a>:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Note: a Map[K, V] is a PartialFunction[K, V]</span>
<span class="stReserved">val</span> pf: <span class="stType">PartialFunction[String, Int]</span> = <span class="stType">Map</span>(<span class="stQuotedString">"I"</span> -&gt; <span class="stLiteral">1</span>, <span class="stQuotedString">"II"</span> -&gt; <span class="stLiteral">2</span>, <span class="stQuotedString">"III"</span> -&gt; <span class="stLiteral">3</span>, <span class="stQuotedString">"IV"</span> -&gt; <span class="stLiteral">4</span>)
<br/>pf(<span class="stQuotedString">"V"</span>) should equal (<span class="stLiteral">5</span>) <span class="stLineComment">// pf("V") throws NoSuchElementException</span>
</pre></p><p>The <code>NoSuchElementException</code> thrown in this situation would cause the test to fail, but without providing a stack depth pointing
to the failing line of test code. This stack depth, provided by <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a> (and a
few other ScalaTest exceptions), makes it quicker for
users to navigate to the cause of the failure. Without <code>PartialFunctionValues</code>, to get
a stack depth exception you would need to make two statements, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> pf: <span class="stType">PartialFunction[String, Int]</span> = <span class="stType">Map</span>(<span class="stQuotedString">"I"</span> -&gt; <span class="stLiteral">1</span>, <span class="stQuotedString">"II"</span> -&gt; <span class="stLiteral">2</span>, <span class="stQuotedString">"III"</span> -&gt; <span class="stLiteral">3</span>, <span class="stQuotedString">"IV"</span> -&gt; <span class="stLiteral">4</span>)
<br/>pf.isDefinedAt(<span class="stQuotedString">"V"</span>) should be (<span class="stReserved">true</span>) <span class="stLineComment">// throws TestFailedException</span>
pf(<span class="stQuotedString">"V"</span>) should equal (<span class="stLiteral">5</span>)
</pre></p><p>The <code>PartialFunctionValues</code> trait allows you to state that more concisely:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> pf: <span class="stType">PartialFunction[String, Int]</span> = <span class="stType">Map</span>(<span class="stQuotedString">"I"</span> -&gt; <span class="stLiteral">1</span>, <span class="stQuotedString">"II"</span> -&gt; <span class="stLiteral">2</span>, <span class="stQuotedString">"III"</span> -&gt; <span class="stLiteral">3</span>, <span class="stQuotedString">"IV"</span> -&gt; <span class="stLiteral">4</span>)
<br/>pf.valueAt(<span class="stQuotedString">"V"</span>) should equal (<span class="stLiteral">5</span>) <span class="stLineComment">// pf.valueAt("V") throws TestFailedException</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Payloads" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PayloadsextendsAnyRef"></a><a id="Payloads:Payloads"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PayloadsextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait facilitating the inclusion of a payload in a thrown ScalaTest exception." href="Payloads.html"><span class="name">Payloads</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait facilitating the inclusion of a payload in a thrown ScalaTest exception.</p><div class="fullcomment"><div class="comment cmt"><p>Trait facilitating the inclusion of a payload in a thrown ScalaTest exception.</p><p>This trait includes a <code>withPayload</code> construct
that enables a payload object (or modified
payload object) to be included as the payload of a thrown exception.</p><p>Many ScalaTest events include an optional &quot;payload&quot; field that can be used
to pass information to a custom reporter. This trait facilitates such customization,
by making it easy to insert a payload into a thrown exception, such as a <code>TestFailedException</code>.
The thrown exception must mix in <code>Payload</code>.
ScalaTest looks for trait <code>Payload</code> and fires any payloads it finds in the relevant ScalaTest event
stimulated by the exception, such as a <a href="events/TestFailed.html"><code>TestFailed</code></a> event stimulated by a <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>.
Here's an example in which a GUI snapshot is included as a payload when a test fails:</p><p><pre class="stHighlighted">
withPayload(generateGUISnapshot()) {
  <span class="stLiteral">1</span> + <span class="stLiteral">1</span> should === (<span class="stLiteral">3</span>)
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.PendingStatement" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PendingStatementextendsAnyRef"></a><a id="PendingStatement:PendingStatement"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PendingStatementextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait mixed into the result type of the pending statement of trait Assertions, which always throws TestPendingException." href="PendingStatement.html"><span class="name">PendingStatement</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait mixed into the result type of the <code>pending</code> statement of trait <code>Assertions</code>, which always throws <code>TestPendingException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait mixed into the result type of the <code>pending</code> statement of trait <code>Assertions</code>, which always throws <code>TestPendingException</code>.</p><p>This type is used primarily to facilitate the <code>is (pending)</code> syntax of
traits <a href="FlatSpec.html"><code>FlatSpec</code></a>, <a href="WordSpec.html"><code>WordSpec</code></a>, and
<a href="FlatSpec.html"><code>FLatSpec</code></a> as well the
<code>is (pending)</code> or <code>(pending)</code> syntax of sibling traits
in the <code>org.scalatest.fixture</code> package. Because the <code>pending</code>
method in <code>Assertions</code> always completes abruptly with an exception, its
type would be inferred to be <code>Nothing</code>, which is a relatively common
type. To make sure syntax like <code>is (pending)</code> only works with
method <code>pending</code>, it is helpful to have a specially named
&quot;<code>Nothing</code>&quot; type.</p></div></div>
    </li><li name="org.scalatest.PrivateMethodTester" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PrivateMethodTesterextendsAnyRef"></a><a id="PrivateMethodTester:PrivateMethodTester"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PrivateMethodTesterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that facilitates the testing of private methods." href="PrivateMethodTester.html"><span class="name">PrivateMethodTester</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that facilitates the testing of private methods.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that facilitates the testing of private methods.</p><p>To test a private method, mix in trait <code>PrivateMethodTester</code> and
create a <code>PrivateMethod</code> object, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> decorateToStringValue = <span class="stType">PrivateMethod[String]</span>(<span class="stQuotedString">'decorateToStringValue</span>)
</pre></p><p>The type parameter on <code>PrivateMethod</code>, in this case <code>String</code>, is the result type of the private method
you wish to invoke. The symbol passed to the <code>PrivateMethod.apply</code> factory method, in this
case <code>'decorateToStringValue</code>, is the name of the private method to invoke. To test
the private method, use the <code>invokePrivate</code> operator, like this:</p><p><pre class="stHighlighted">
targetObject invokePrivate decorateToStringValue(<span class="stLiteral">1</span>)
</pre></p><p>Here, <code>targetObject</code> is a variable or singleton object name referring to the object whose
private method you want to test. You pass the arguments to the private method in the parentheses after
the <code>PrivateMethod</code> object.
The result type of an <code>invokePrivate</code> operation will be the type parameter of the <code>PrivateMethod</code>
object, thus you need not cast the result to use it. In other words, after creating a <code>PrivateMethod</code> object, the
syntax to invoke the private method
looks like a regular method invocation, but with the dot (<code>.</code>) replaced by <code>invokePrivate</code>.
The private method is invoked dynamically via reflection, so if you have a typo in the method name symbol, specify the wrong result type,
or pass invalid parameters, the <code>invokePrivate</code> operation will compile, but throw an exception at runtime.</p><p>One limitation to be aware of is that you can't use <code>PrivateMethodTester</code> to test a private method
declared in a trait, because the class the trait gets mixed into will not declare that private method. Only the
class generated to hold method implementations for the trait will have that private method. If you want to
test a private method declared in a trait, and that method does not use any state of that trait, you can move
the private method to a companion object for the trait and test it using <code>PrivateMethodTester</code> that
way. If the private trait method you want to test uses the trait's state, your best options are to test it
indirectly via a non-private trait method that calls the private method, or make the private method package access
and test it directly via regular static method invocations.</p><p>Also, if you want to use <code>PrivateMethodTester</code> to invoke a parameterless private method, you'll need to use
empty parens. Instead of:</p><p><pre class="stHighlighted">
targetObject invokePrivate privateParameterlessMethod
</pre></p><p>You'll need to write:</p><p><pre class="stHighlighted">
targetObject invokePrivate privateParameterlessMethod()
</pre>
</p></div></div>
    </li><li name="org.scalatest.PropSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PropSpecextendsPropSpecLike"></a><a id="PropSpec:PropSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PropSpecextendsPropSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A suite of property-based tests." href="PropSpec.html"><span class="name">PropSpec</span></a><span class="result"> extends <a href="PropSpecLike.html" class="extype" name="org.scalatest.PropSpecLike">PropSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">A suite of property-based tests.</p><div class="fullcomment"><div class="comment cmt"><p>A suite of property-based tests.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Class <code>PropSpec</code> is a good fit for teams that want to write tests exclusively in terms of property checks, and is also a good choice
for writing the occasional <a href="#testMatrix">test matrix</a> when a different style trait is chosen as the main unit testing style.
</td></tr></table></p><p>Here's an example <code>PropSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> scala.collection.immutable._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      BitSet.empty,
      HashSet.empty[<span class="stType">Int</span>],
      TreeSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an empty Set should have size 0"</span>) {
    forAll(examples) { set =&gt;
      set.size should be (<span class="stLiteral">0</span>)
    }
  }
<br/>  property(<span class="stQuotedString">"invoking head on an empty set should produce NoSuchElementException"</span>) {
    forAll(examples) { set =&gt;
      a [<span class="stType">NoSuchElementException</span>] should be thrownBy { set.head }
    }
  }
}
</pre></p><p>You can run a <code>PropSpec</code> by invoking <code>execute</code> on it.
This method, which prints test results to the standard output, is intended to serve as a
convenient way to run tests from within the Scala interpreter. For example,
to run <code>SetSpec</code> from within the Scala interpreter, you could write:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>And you would see:</p><p><pre class="stREPL">
<span class="stGreen">SetSpec:
- an empty Set should have size 0
- invoking head on an empty Set should produce NoSuchElementException</span>
</pre></p><p>Or, to run just the &ldquo;<code>an empty Set should have size 0</code>&rdquo; method, you could pass that test's name, or any unique substring of the
name, such as <code>"size 0"</code> or even just <code>"0"</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec, "size 0")
<span class="stGreen">SetSpec:
- an empty Set should have size 0</span>
</pre></p><p>You can also pass to <code>execute</code> a <a href="ConfigMap.html"><em>config map</em></a> of key-value
pairs, which will be passed down into suites and tests, as well as other parameters that configure the run itself.
For more information on running in the Scala interpreter, see the documentation for <code>execute</code> (below) and the
<a href="Shell.html">ScalaTest shell</a>.</p><p>The <code>execute</code> method invokes a <code>run</code> method that takes two
parameters. This <code>run</code> method, which actually executes the suite, will usually be invoked by a test runner, such
as <a href="run$.html"><code>run</code></a>, <a href="tools/Runner$.html"><code>tools.Runner</code></a>, a build tool, or an IDE.</p><p>&ldquo;<code>property</code>&rdquo; is a method, defined in <code>PropSpec</code>, which will be invoked
by the primary constructor of <code>SetSpec</code>. You specify the name of the test as
a string between the parentheses, and the test code itself between curly braces.
The test code is a function passed as a by-name parameter to <code>property</code>, which registers
it for later execution.</p><p>A <code>PropSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered with the <code>property</code> method while the <code>PropSpec</code> is
in its registration phase. Any attempt to register a test after the <code>PropSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>PropSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The recommended style
of using <code>PropSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>PropSpec</code> provides registration
methods that start with <code>ignore</code> instead of <code>property</code>. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.suite.ignore
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> scala.collection.immutable._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      BitSet.empty,
      HashSet.empty[<span class="stType">Int</span>],
      TreeSet.empty[<span class="stType">Int</span>]
    )
<br/>  ignore(<span class="stQuotedString">"an empty Set should have size 0"</span>) {
    forAll(examples) { set =>
      set.size should be (<span class="stLiteral">0</span>)
    }
  }
<br/>  property(<span class="stQuotedString">"invoking head on an empty set should produce NoSuchElementException"</span>) {
    forAll(examples) { set =>
      a [<span class="stType">NoSuchElementException</span>] should be thrownBy { set.head }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">SetSuite:</span>
<span class="stYellow">- an empty Set should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">- invoking head on an empty Set should produce NoSuchElementException</span>
</pre></p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>PropSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>PropSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information
to the current <code>Reporter</code> is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.
Here's an example that shows both a direct use as well as an indirect use through the methods
of <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec.info
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> collection.mutable
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      mutable.BitSet.empty,
      mutable.HashSet.empty[<span class="stType">Int</span>],
      mutable.LinkedHashSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an element can be added to an empty mutable Set"</span>) {
<br/>    forAll(examples) { set =&gt;
<br/>      info(<span class="stQuotedString">"&mdash;&mdash;&mdash;&mdash;&mdash;-"</span>)
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable "</span> + set.getClass.getSimpleName)
      assert(set.isEmpty)
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stLiteral">99</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stLiteral">99</span>))
    }
  }
}
</pre></p><p>If you run this <code>PropSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
- an element can be added to an empty mutable Set
  + ----------------
  + Given an empty mutable BitSet
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + ----------------
  + Given an empty mutable HashSet
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + ----------------
  + Given an empty mutable LinkedHashSet
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element</span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>PropSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>PropSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec.markup
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> collection.mutable
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      mutable.BitSet.empty,
      mutable.HashSet.empty[<span class="stType">Int</span>],
      mutable.LinkedHashSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an element can be added to an empty mutable Set"</span>) {
<br/>    forAll(examples) { set =>
<br/>      info(<span class="stQuotedString">"&mdash;&mdash;&mdash;&mdash;&mdash;-"</span>)
<br/>      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable "</span> + set.getClass.getSimpleName)
      assert(set.isEmpty)
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stLiteral">99</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stLiteral">99</span>))
    }
<br/>    markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/propSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec.note
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> collection.mutable
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      mutable.BitSet.empty,
      mutable.HashSet.empty[<span class="stType">Int</span>],
      mutable.LinkedHashSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an element can be added to an empty mutable Set"</span>) {
<br/>    info(<span class="stQuotedString">"info is recorded"</span>)
    markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
    note(<span class="stQuotedString">"notes are sent immediately"</span>)
    alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>    forAll(examples) { set =>
<br/>      assert(set.isEmpty)
      set += <span class="stLiteral">99</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stLiteral">99</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- an element can be added to an empty mutable Set
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <a href="exceptions/TestPendingException.html"><code>TestPendingException</code></a>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run.
(The code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality, has not yet been implemented.</p><p>You can mark tests pending in <code>PropSpec</code> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> scala.collection.immutable._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      BitSet.empty,
      HashSet.empty[<span class="stType">Int</span>],
      TreeSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an empty Set should have size 0"</span>) (pending)
<br/>  property(<span class="stQuotedString">"invoking head on an empty set should produce NoSuchElementException"</span>) {
    forAll(examples) { set =&gt;
      a [<span class="stType">NoSuchElementException</span>] should be thrownBy { set.head }
    }
  }
}
</pre></p><p>(Note: &quot;<code>(pending)</code>&quot; is the body of the test. Thus the test contains just one statement, an invocation
of the <code>pending</code> method, which throws <code>TestPendingException</code>.)
If you run this version of <code>SetSuite</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSuite)
</pre></p><p>It will run both tests, but report that first test is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">SetSuite:</span>
<span class="stYellow">- An empty Set should have size 0 (pending)</span>
<span class="stGreen">- Invoking head on an empty Set should produce NoSuchElementException</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait.</p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>PropSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>PropSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>PropSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified names,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>PropSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>PropSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> prop._
<span class="stReserved">import</span> tagobjects.Slow
<span class="stReserved">import</span> scala.collection.immutable._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  <span class="stReserved">val</span> examples =
    <span class="stType">Table</span>(
      <span class="stQuotedString">"set"</span>,
      BitSet.empty,
      HashSet.empty[<span class="stType">Int</span>],
      TreeSet.empty[<span class="stType">Int</span>]
    )
<br/>  property(<span class="stQuotedString">"an empty Set should have size 0"</span>, <span class="stType">Slow</span>) {
    forAll(examples) { set =&gt;
      set.size should be (<span class="stLiteral">0</span>)
    }
  }
<br/>  property(<span class="stQuotedString">"invoking head on an empty set should produce NoSuchElementException"</span>,
      <span class="stType">Slow</span>, <span class="stType">DbTest</span>) {
<br/>    forAll(examples) { set =&gt;
      a [<span class="stType">NoSuchElementException</span>] should be thrownBy { set.head }
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <code>Filter</code>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The techniques in <code>PropSpec</code> are identical to those in <code>FunSuite</code>, but with &ldquo;<code>test</code>&rdquo;
replaced by &ldquo;<code>property</code>&rdquo;. The following table summarizes the options with a link to the relevant
documentation for trait <code>FunSuite</code>:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="FunSuite.html#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="testMatrix"></a></p><h6> Using <code>PropSpec</code> to implement a test matrix </h6><p>Using fixture-context objects in a <code>PropSpec</code> is a good way to implement a test matrix.
What is the matrix? A test matrix is a series of tests that you need to run on a series of subjects. For example, The Scala API contains
many implementations of trait <code>Set</code>. Every implementation must obey the contract of <code>Set</code>.
One property of any <code>Set</code> is that an empty <code>Set</code> should have size 0, another is that
invoking head on an empty <code>Set</code> should give you a <code>NoSuchElementException</code>, and so on. Already you have a matrix,
where rows are the properties and the columns are the set implementations:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">&nbsp;</th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><code>BitSet</code></th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><code>HashSet</code></th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black"><code>TreeSet</code></th></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">An empty Set should have size 0</td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">Invoking head on an empty set should produce NoSuchElementException</td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><span class="stGreen">pass</span></td></td></tr>
</table></p><p>One way to implement this test matrix is to define a trait to represent the columns (in this case, <code>BitSet</code>, <code>HashSet</code>,
and <code>TreeSet</code>) as elements in a single-dimensional <code>Table</code>. Each element in the <code>Table</code> represents
one <code>Set</code> implementation. Because different properties may require different fixture instances for those implementations, you
can define a trait to hold the examples, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">SetExamples</span> <span class="stReserved">extends</span> <span class="stType">Tables</span> {
<br/>  <span class="stReserved">def</span> examples = <span class="stType">Table</span>(<span class="stQuotedString">"set"</span>, bitSet, hashSet, treeSet)
<br/>  <span class="stReserved">def</span> bitSet: <span class="stType">BitSet</span>
  <span class="stReserved">def</span> hashSet: <span class="stType">HashSet[Int]</span>
  <span class="stReserved">def</span> treeSet: <span class="stType">TreeSet[Int]</span>
}
</pre></p><p>Given this trait, you could provide empty sets in one implementation of <code>SetExamples</code>, and non-empty sets in another.
Here's how you might provide empty set examples:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">EmptySetExamples</span> <span class="stReserved">extends</span> <span class="stType">SetExamples</span> {
  <span class="stReserved">def</span> bitSet = BitSet.empty
  <span class="stReserved">def</span> hashSet = HashSet.empty[<span class="stType">Int</span>]
  <span class="stReserved">def</span> treeSet = TreeSet.empty[<span class="stType">Int</span>]
}
</pre></p><p>And here's how you might provide set examples with one item each:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">SetWithOneItemExamples</span> <span class="stReserved">extends</span> <span class="stType">SetExamples</span> {
  <span class="stReserved">def</span> bitSet = <span class="stType">BitSet</span>(<span class="stLiteral">1</span>)
  <span class="stReserved">def</span> hashSet = <span class="stType">HashSet</span>(<span class="stLiteral">1</span>)
  <span class="stReserved">def</span> treeSet = <span class="stType">TreeSet</span>(<span class="stLiteral">1</span>)
}
</pre></p><p>Armed with these example classes, you can define checks of properties that require
empty or non-empty set fixtures by using instances of these classes as fixture-context
objects. In other words, the columns of the test matrix are implemented as elements of
a one-dimensional table of fixtures, the rows are implemented as <code>property</code>
clauses of a <code>PropSpec</code>.</p><p>Here's a complete example that checks the two properties mentioned previously:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.propspec.matrix
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.prop._
<span class="stReserved">import</span> scala.collection.immutable._
<br/><span class="stReserved">trait</span> <span class="stType">SetExamples</span> <span class="stReserved">extends</span> <span class="stType">Tables</span> {
<br/>  <span class="stReserved">def</span> examples = <span class="stType">Table</span>(<span class="stQuotedString">"set"</span>, bitSet, hashSet, treeSet)
<br/>  <span class="stReserved">def</span> bitSet: <span class="stType">BitSet</span>
  <span class="stReserved">def</span> hashSet: <span class="stType">HashSet[Int]</span>
  <span class="stReserved">def</span> treeSet: <span class="stType">TreeSet[Int]</span>
}
<br/><span class="stReserved">class</span> <span class="stType">EmptySetExamples</span> <span class="stReserved">extends</span> <span class="stType">SetExamples</span> {
  <span class="stReserved">def</span> bitSet = BitSet.empty
  <span class="stReserved">def</span> hashSet = HashSet.empty[<span class="stType">Int</span>]
  <span class="stReserved">def</span> treeSet = TreeSet.empty[<span class="stType">Int</span>]
}
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">PropSpec</span> <span class="stReserved">with</span> <span class="stType">TableDrivenPropertyChecks</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> {
<br/>  property(<span class="stQuotedString">"an empty Set should have size 0"</span>) {
    <span class="stReserved">new</span> <span class="stType">EmptySetExamples</span> {
      forAll(examples) { set =&gt;
        set.size should be (<span class="stLiteral">0</span>)
      }
    }
  }
<br/>  property(<span class="stQuotedString">"invoking head on an empty set should produce NoSuchElementException"</span>) {
    <span class="stReserved">new</span> <span class="stType">EmptySetExamples</span> {
      forAll(examples) { set =&gt;
        a [<span class="stType">NoSuchElementException</span>] should be thrownBy { set.head }
      }
    }
  }
}
</pre></p><p>One benefit of this approach is that the compiler will help you when you need to add either a new row
or column to the matrix. In either case, you'll need to ensure all cells are checked to get your code to compile.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. That is to say, you may want to write tests that are &quot;shared&quot;
by different fixture objects.
You accomplish this in a <code>PropSpec</code> in the same way you would do it in a <code>FunSuite</code>, except instead of <code>test</code>
you say <code>property</code>, and instead of <code>testsFor</code> you say <code>propertiesFor</code>.
For more information, see the <a href="FunSuite.html#sharedTests">Shared tests</a> section of <code>FunSuite</code>'s
documentation.</p></div></div>
    </li><li name="org.scalatest.PropSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PropSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="PropSpecLike:PropSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PropSpecLikeextendsTestSuitewithTestRegistrationwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class PropSpec, which represents a suite of property-based tests." href="PropSpecLike.html"><span class="name">PropSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>PropSpec</code>, which represents
a suite of property-based tests.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>PropSpec</code>, which represents
a suite of property-based tests.</p><p><a href="PropSpec.html"><code>PropSpec</code></a> is a class, not a trait,
to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the
behavior of <code>PropSpec</code> into some other class, you can use this
trait instead, because class <code>PropSpec</code> does nothing more than
extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="PropSpec.html">detailed
overview of <code>PropSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.RandomTestOrder" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RandomTestOrderextendsOneInstancePerTest"></a><a id="RandomTestOrder:RandomTestOrder"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#RandomTestOrderextendsOneInstancePerTest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that causes tests to be run in pseudo-random order." href="RandomTestOrder.html"><span class="name">RandomTestOrder</span></a><span class="result"> extends <a href="OneInstancePerTest.html" class="extype" name="org.scalatest.OneInstancePerTest">OneInstancePerTest</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that causes tests to be run in pseudo-random order.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that causes tests to be run in pseudo-random order.</p><p>Although the tests are run in pseudo-random order, events will be fired in the &ldquo;normal&rdquo; order for the <code>Suite</code>
that mixes in this trait, as determined by <code>runTests</code>.</p><p>The purpose of this trait is to reduce the likelihood of unintentional order dependencies between tests
in the same test class.</p></div></div>
    </li><li name="org.scalatest.RecoverMethods" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RecoverMethodsextendsAnyRef"></a><a id="RecoverMethods:RecoverMethods"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#RecoverMethodsextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Offers two methods for transforming futures when exceptions are expected." href="RecoverMethods.html"><span class="name">RecoverMethods</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Offers two methods for transforming futures when exceptions are expected.</p><div class="fullcomment"><div class="comment cmt"><p>Offers two methods for transforming futures when exceptions are expected.</p><p>This trait offers two methods for testing for expected exceptions in the context of
futures: <code>recoverToSucceededIf</code> and <code>recoverToExceptionIf</code>.
Because this trait is mixed into trait <code>AsyncTestSuite</code>, both of its methods are
available by default in any async-style suite.</p><p>If you just want to ensure that a future fails with a particular exception type, and do
not need to inspect the exception further, use <code>recoverToSucceededIf</code>:</p><p><pre class="stHighlighted">
recoverToSucceededIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[Assertion]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>The <code>recoverToSucceededIf</code> method performs a job similar to
<a href="Assertions.html#expectedExceptions"><code>assertThrows</code></a>, except
in the context of a future. It transforms a <code>Future</code> of any type into a
<code>Future[Assertion]</code> that succeeds only if the original future fails with the specified
exception. Here's an example in the REPL:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.RecoverMethods._
import org.scalatest.RecoverMethods._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new IllegalStateException }
     | }
res0: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res0.value
res1: Option[scala.util.Try[org.scalatest.Assertion]] = Some(Success(Succeeded))
</pre></p><p>Otherwise it fails with an error message similar to those given by <code>assertThrows</code>:</p><p><pre class="stREPL">
scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { throw new RuntimeException }
     | }
res2: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res2.value
res3: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but java.lang.RuntimeException
      was thrown))

scala&gt; recoverToSucceededIf[IllegalStateException] {
     |   Future { 42 }
     | }
res4: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res4.value
res5: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: Expected exception
      java.lang.IllegalStateException to be thrown, but no exception was thrown))
</pre></p><p>The <code>recoverToExceptionIf</code> method differs from the <code>recoverToSucceededIf</code> in
its behavior when the assertion succeeds: <code>recoverToSucceededIf</code> yields a <code>Future[Assertion]</code>,
whereas <code>recoverToExceptionIf</code> yields a <code>Future[T]</code>, where <code>T</code> is the
expected exception type.</p><p><pre class="stHighlighted">
recoverToExceptionIf[<span class="stType">IllegalStateException</span>] { <span class="stLineComment">// Result type: Future[IllegalStateException]</span>
  emptyStackActor ? <span class="stType">Peek</span>
}
</pre></p><p>In other words, <code>recoverToExpectionIf</code> is to
<a href="Assertions.html#expectedExceptions"><code>intercept</code></a> as
<code>recovertToSucceededIf</code> is to <code>assertThrows</code>. The first one allows you to perform further
assertions on the expected exception. The second one gives you a result type that will satisfy the type checker
at the end of the test body. Here's an example showing <code>recoverToExceptionIf</code> in the REPL:</p><p><pre class="stREPL">
scala&gt; val futureEx =
     |   recoverToExceptionIf[IllegalStateException] {
     |     Future { throw new IllegalStateException("hello") }
     |   }
futureEx: scala.concurrent.Future[IllegalStateException] = ...

scala&gt; futureEx.value
res6: Option[scala.util.Try[IllegalStateException]] =
    Some(Success(java.lang.IllegalStateException: hello))

scala&gt; futureEx map { ex =&gt; assert(ex.getMessage == "world") }
res7: scala.concurrent.Future[org.scalatest.Assertion] = ...

scala&gt; res7.value
res8: Option[scala.util.Try[org.scalatest.Assertion]] =
    Some(Failure(org.scalatest.exceptions.TestFailedException: "[hello]" did not equal "[world]"))
</pre>
</p></div></div>
    </li><li name="org.scalatest.Reporter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ReporterextendsAnyRef"></a><a id="Reporter:Reporter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ReporterextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose instances collect the results of a running suite of tests and presents those results in some way to the user." href="Reporter.html"><span class="name">Reporter</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose instances collect the results of a running
suite of tests and presents those results in some way to the user.</p><div class="fullcomment"><div class="comment cmt"><p>Trait whose instances collect the results of a running
suite of tests and presents those results in some way to the user. Instances of this trait can
be called &quot;report functions&quot; or &quot;reporters.&quot;</p><p>Reporters receive test results via fifteen events.
Each event is fired to pass a particular kind of information to
the reporter. The events are:</p><ul><li><a href="events/DiscoveryStarting.html"><code>DiscoveryStarting</code></a></li><li><a href="events/DiscoveryCompleted.html"><code>DiscoveryCompleted</code></a></li><li><a href="events/RunStarting.html"><code>RunStarting</code></a></li><li><a href="events/RunStopped.html"><code>RunStopped</code></a></li><li><a href="events/RunAborted.html"><code>RunAborted</code></a></li><li><a href="events/RunCompleted.html"><code>RunCompleted</code></a></li><li><a href="events/ScopeOpened.html"><code>ScopeOpened</code></a></li><li><a href="events/ScopeClosed.html"><code>ScopeClosed</code></a></li><li><a href="events/ScopePending.html"><code>ScopePending</code></a></li><li><a href="events/TestStarting.html"><code>TestStarting</code></a></li><li><a href="events/TestSucceeded.html"><code>TestSucceeded</code></a></li><li><a href="events/TestFailed.html"><code>TestFailed</code></a></li><li><a href="events/TestCanceled.html"><code>TestCanceled</code></a></li><li><a href="events/TestIgnored.html"><code>TestIgnored</code></a></li><li><a href="events/TestPending.html"><code>TestPending</code></a></li><li><a href="events/SuiteStarting.html"><code>SuiteStarting</code></a></li><li><a href="events/SuiteCompleted.html"><code>SuiteCompleted</code></a></li><li><a href="events/SuiteAborted.html"><code>SuiteAborted</code></a></li><li><a href="events/InfoProvided.html"><code>InfoProvided</code></a></li><li><a href="events/MarkupProvided.html"><code>MarkupProvided</code></a></li><li><a href="events/AlertProvided.html"><code>AlertProvided</code></a></li><li><a href="events/NoteProvided.html"><code>NoteProvided</code></a></li></ul><p>Reporters may be implemented such that they only present some of the reported events to the user. For example, you could
define a reporter class that does nothing in response to <code>SuiteStarting</code> events.
Such a class would always ignore <code>SuiteStarting</code> events.</p><p>The term <em>test</em> as used in the <code>TestStarting</code>, <code>TestSucceeded</code>,
and <code>TestFailed</code> event names
is defined abstractly to enable a wide range of test implementations.
ScalaTest's style traits (subclasse of trait <a href="Suite.html"><code>Suite</code></a>) fire
<code>TestStarting</code> to indicate they are about to invoke one
of their tests, <code>TestSucceeded</code> to indicate a test returned normally,
and <code>TestFailed</code> to indicate a test completed abruptly with an exception.
Although the execution of a <code>Suite</code> subclass's tests will likely be a common event
reported via the
<code>TestStarting</code>, <code>TestSucceeded</code>, and <code>TestFailed</code> events, because
of the abstract definition of &ldquo;test&rdquo; used by the
the event classes, these events are not limited to this use. Information about any conceptual test
may be reported via the <code>TestStarting</code>, <code>TestSucceeded</code>, and
<code>TestFailed</code> events.</p><p>Likewise, the term <em>suite</em> as used in the <code>SuiteStarting</code>, <code>SuiteAborted</code>,
and <code>SuiteCompleted</code> event names
is defined abstractly to enable a wide range of suite implementations.
Object <a href="tools/Runner$.html"><code>Runner</code></a> fires <code>SuiteStarting</code> to indicate it is about to invoke
<code>run</code> on a
<code>Suite</code>, <code>SuiteCompleted</code> to indicate a <code>Suite</code>'s
<code>run</code> method returned normally,
and <code>SuiteAborted</code> to indicate a <code>Suite</code>'s <code>run</code>
method completed abruptly with an exception.
Similarly, class <code>Suite</code> fires <code>SuiteStarting</code> to indicate it is about to invoke
<code>run</code> on a
nested <code>Suite</code>, <code>SuiteCompleted</code> to indicate a nested <code>Suite</code>'s
<code>run</code> method returned normally,
and <code>SuiteAborted</code> to indicate a nested <code>Suite</code>'s <code>run</code>
method completed abruptly with an exception.
Although the execution of a <code>Suite</code>'s <code>run</code> method will likely be a
common event reported via the
<code>SuiteStarting</code>, <code>SuiteAborted</code>, and <code>SuiteCompleted</code> events, because
of the abstract definition of &quot;suite&quot; used by the
event classes, these events are not limited to this use. Information about any conceptual suite
may be reported via the <code>SuiteStarting</code>, <code>SuiteAborted</code>, and
<code>SuiteCompleted</code> events.</p><h4> Extensibility </h4><p>You can create classes that extend <code>Reporter</code> to report test results in custom ways, and to
report custom information passed as an event &quot;payload.&quot;
<code>Reporter</code> classes can handle events in any manner, including doing nothing.</p></div></div>
    </li><li name="org.scalatest.ResourcefulReporter" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ResourcefulReporterextendsReporter"></a><a id="ResourcefulReporter:ResourcefulReporter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ResourcefulReporterextendsReporter" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Subtrait of Reporter that contains a dispose method for releasing any finite, non-memory resources, such as file handles, held by the Reporter." href="ResourcefulReporter.html"><span class="name">ResourcefulReporter</span></a><span class="result"> extends <a href="Reporter.html" class="extype" name="org.scalatest.Reporter">Reporter</a></span>
      </span>
      
      <p class="shortcomment cmt">Subtrait of <code>Reporter</code> that contains a <code>dispose</code> method for
releasing any finite, non-memory resources, such as file handles, held by the
<code>Reporter</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Subtrait of <code>Reporter</code> that contains a <code>dispose</code> method for
releasing any finite, non-memory resources, such as file handles, held by the
<code>Reporter</code>. <a href="tools/Runner$.html"><code>Runner</code></a> will invoke <code>dispose</code> on
any <code>ResourcefulReporter</code> when it no longer needs the <code>Reporter</code>.
</p></div></div>
    </li><li name="org.scalatest.Retries" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RetriesextendsAnyRef"></a><a id="Retries:Retries"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#RetriesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides methods that can be used in withFixture implementations to retry tests in various scenarios." href="Retries.html"><span class="name">Retries</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides methods that can be used in <code>withFixture</code> implementations to retry tests in various scenarios.</p><div class="fullcomment"><div class="comment cmt"><p>Provides methods that can be used in <code>withFixture</code> implementations to retry tests in various scenarios.</p><p>Trait <code>Retries</code> is intended to help you deal with &ldquo;flickers&rdquo;&mdash;tests that usually pass, but
occasionally fail. The best way to deal with such tests is to fix them so they always pass. Sometimes, however, this is
not practical. In such cases, flickers can waste your time by forcing you to investigate test failures that turn
out to be flickers. Or worse, like the boy who cried wolf, the flickers may train you an your colleagues to not pay attention
to failures such that you don't notice real problems, at least not in a timely manner.</p><p>Trait <code>Retries</code> offers methods that will retry a failed and/or canceled test once, on the same thread,
with or without a delay. These methods take a block that results in <a href="Outcome.html"><code>Outcome</code></a>,
and are intended to be used in <code>withFixture</code> methods. You should be very selective about which tests you
retry, retrying those for which you have good evidence to conclude they are flickers. Thus it is recommended you
only retry tests that are tagged with <code>Retryable</code>, and only tag tests as such once they have flickered
consistently for a while, and only after you invested a reasonable effort into fixing them properly.</p><p>Here's an example showing how you might use <code>Retries</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.tagobjects.retryable
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> tagobjects.Retryable
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Retries</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">if</span> (isRetryable(test))
      withRetry { <span class="stReserved">super</span>.withFixture(test) }
    <span class="stReserved">else</span>
      <span class="stReserved">super</span>.withFixture(test)
  }
<br/>  <span class="stQuotedString">"An empty Set"</span> should <span class="stQuotedString">"have size 0"</span> taggedAs(<span class="stType">Retryable</span>) in {
    assert(Set.empty.size === <span class="stLiteral">0</span>)
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.Sequential" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SequentialextendsSuitewithSequentialNestedSuiteExecution"></a><a id="Sequential:Sequential"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SequentialextendsSuitewithSequentialNestedSuiteExecution" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A Suite class mixing in SequentialNestedSuiteExecution that takes zero to many Suites, which will be returned from its nestedSuites method." href="Sequential.html"><span class="name">Sequential</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a> with <a href="SequentialNestedSuiteExecution.html" class="extype" name="org.scalatest.SequentialNestedSuiteExecution">SequentialNestedSuiteExecution</a></span>
      </span>
      
      <p class="shortcomment cmt">A <code>Suite</code> class mixing in <a href="SequentialNestedSuiteExecution.html"><code>SequentialNestedSuiteExecution</code></a> that takes
zero to many <code>Suite</code>s, which will be returned from its <code>nestedSuites</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>Suite</code> class mixing in <a href="SequentialNestedSuiteExecution.html"><code>SequentialNestedSuiteExecution</code></a> that takes
zero to many <code>Suite</code>s, which will be returned from its <code>nestedSuites</code> method.</p><p>For example, you can define a suite that always executes a list of
nested suites like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StepsSuite</span> <span class="stReserved">extends</span> <span class="stType">Sequential</span>(
  <span class="stReserved">new</span> <span class="stType">Step1Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step2Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step3Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step4Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step5Suite</span>
)
</pre></p><p>When <code>StepsSuite</code> is executed, it will execute its
nested suites in the passed order: <code>Step1Suite</code>, <code>Step2Suite</code>,
<code>Step3Suite</code>, <code>Step4Suite</code>, and <code>Step5Suite</code>.
Because <code>Sequential</code> extends <code>SequentialNestedSuiteExecution</code>,
the distributor passed to <code>runNestedSuites</code> will always be <code>None</code>.
So not only will the suites passed to the constructor be executed sequentially, any
tests and nested suites of the passed suites will also be executed sequentually.</p><p>The difference between <code>Sequential</code> and <a href="Stepwise.html"><code>Stepwise</code></a>
is that although <code>Stepwise</code> executes its own nested suites sequentially, it passes
whatever distributor was passed to it to those nested suites. Thus the nested suites could run their own nested
suites and tests in parallel if that distributor is defined. By contrast, <code>Sequential</code> always
passes <code>None</code> for the distributor to the nested suites, so any and every test and nested suite
contained within the nested suites passed to the <code>Sequential</code> construtor will be executed sequentially.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NullArgumentException"><code>NullArgumentException</code></span> if <code>suitesToNest</code>, or any suite
it contains, is <code>null</code>.</p></span></dd></dl></div>
    </li><li name="org.scalatest.SequentialNestedSuiteExecution" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SequentialNestedSuiteExecutionextendsSuiteMixin"></a><a id="SequentialNestedSuiteExecution:SequentialNestedSuiteExecution"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SequentialNestedSuiteExecutionextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites." href="SequentialNestedSuiteExecution.html"><span class="name">SequentialNestedSuiteExecution</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if
a <code>Distributor</code> is passed to <code>runNestedSuites</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if
a <code>Distributor</code> is passed to <code>runNestedSuites</code>. This trait overrides the
<code>runNestedSuites</code> method and fowards every parameter passed to it to a superclass invocation
of <code>runNestedSuites</code>, except it always passes <code>None</code> for the <code>Distributor</code>.
Mix in this trait into any suite whose nested suites need to be run sequentially even with the rest of the
run is being executed concurrently.
</p></div></div>
    </li><li name="org.scalatest.SeveredStackTraces" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SeveredStackTracesextendsTestSuiteMixin"></a><a id="SeveredStackTraces:SeveredStackTraces"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SeveredStackTracesextendsTestSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that causes StackDepth exceptions thrown by a running test (such as TestFailedExceptions) to have the exception's stack trace severed at the stack depth." href="SeveredStackTraces.html"><span class="name">SeveredStackTraces</span></a><span class="result"> extends <a href="TestSuiteMixin.html" class="extype" name="org.scalatest.TestSuiteMixin">TestSuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that causes <a href="exceptions/StackDepth.html"><code>StackDepth</code></a> exceptions thrown by a running test (such as <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>s) to have
the exception's stack trace severed at the stack depth.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that causes <a href="exceptions/StackDepth.html"><code>StackDepth</code></a> exceptions thrown by a running test (such as <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>s) to have
the exception's stack trace severed at the stack depth. Because the stack depth indicates the exact line of code that caused
the exception to be thrown, the severed stack trace will show that offending line of code on top. This can make the line
of test code that discovered a problem to be more easily found in IDEs and tools that don't make use of
ScalaTest's <code>StackDepth</code> exceptions directly.
</p></div></div>
    </li><li name="org.scalatest.Shell" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ShellextendsAnyRef"></a><a id="Shell:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ShellextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose instances provide a run method and configuration fields that implement the ScalaTest shell: its DSL for the Scala interpreter." href="Shell.html"><span class="name">Shell</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose instances provide a <a href="run$.html"><code>run</code></a> method and configuration fields that implement
the <em>ScalaTest shell</em>: its DSL for the Scala interpreter.</p><div class="fullcomment"><div class="comment cmt"><p>Trait whose instances provide a <a href="run$.html"><code>run</code></a> method and configuration fields that implement
the <em>ScalaTest shell</em>: its DSL for the Scala interpreter.</p><p>The main command of the ScalaTest shell is <code>run</code>, which you can use to run a suite of tests.
The shell also provides several commands for configuring a call to <code>run</code>:</p><ul><li><code>color</code> (the default) - display results in color (green for success; red for failure; yellow for warning; blue for statistics)</li><li><code>nocolor</code> - display results without color</li><li><code>durations</code> - display durations of (<em>i.e.</em>, how long it took to run) tests and suites</li><li><code>nodurations</code> (the default) - do not display durations of tests and suites</li><li><code>shortstacks</code> - display short (<em>i.e.</em>, truncated to show just the most useful portion) stack traces for all exceptions</li><li><code>fullstacks</code> - display full stack trackes for all exceptions</li><li><code>nostacks</code> (the default) - display no stack trace for <code>StackDepth</code> exceptions and a short stack trace for non-<code>StackDepth</code>
  exceptions</li><li><code>stats</code> - display statistics before and after the run, such as expected test count before the run and tests succeeded, failed, pending,
<em>etc.</em>, counts after the run</li><li><code>nostats</code> (the default) not display statistics before or after the run</li></ul><p>The default configuration is <code>color</code>, <code>nodurations</code>, <code>nostacks</code>, and <code>nostats</code>.</p><p>All of these commands are fields of trait <code>org.scalatest.Shell</code>. Each configuration command is a field that refers to
another <code>Shell</code> instance with every configuration parameter
the same except for the one you've asked to change. For example, <code>durations</code> provides a
<code>Shell</code> instance that has every parameter configured the same way, except with durations enabled. When you invoke
<code>run</code> on that, you will get a run with durations enabled and every other configuration parameter at its default value.</p><p>The other useful &quot;command&quot;
to know about, though not technically part of the shell, is the <code>apply</code> factory method in the <a href="Suites$.html"><code>Suites</code></a>
singleton object. This allows you to easily create composite suites out of nested suites, which you can then pass to <code>run</code>. This
will be demonstrated later in this documentation.</p><h4> Using the ScalaTest shell </h4><p>The package object of the <code>org.scalatest</code> package, although it does not extend <code>Shell</code>, declares all the
same members as <code>Shell</code>. Its <code>run</code> method runs with all the <code>Shell</code> configuration parameters set
to their default values. A good way to use the ScalaTest shell, therefore, is to import the members of package <code>org.scalatest</code>:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> import org.scalatest._
import org.scalatest._</span>
</pre></p><p>One thing importing <code>org.scalatest._</code> allows you to do is access any of ScalaTest's classes and traits by shorter
names, for example:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> class ArithmeticSuite extends FunSuite with matchers.Matchers {
     |   test("addition works") {
     |     1 + 1 should equal (2)
     |   }
     |   ignore("subtraction works") {
     |     1 - 1 should equal (0)
     |   }
     |   test("multiplication works") {
     |     1 * 1 should equal (2)
     |   }
     |   test("division works") (pending)
     | }
defined class ArithmeticSuite</span>
</pre></p><p>But importing <code>org.scalatest._</code> also brings into scope the commands of the <code>Shell</code>, so you can, for
example, invoke <code>run</code> without qualification:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> run(new ArithmeticSuite)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED ***
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
</pre></p><h4> Configuring a single run </h4><p>To configure a single run, you can prefix run by one or more configuration commands, separated by dots. For example, to enable
durations during a single run, you would write:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> durations.run(new ArithmeticSuite)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (102 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (36 milliseconds)
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
</pre></p><p>To enable statistics during a single run, you would write:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> stats.run(new ArithmeticSuite)</span>
<span style="color: #00dddd">Run starting. Expected test count is: 3</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED ***
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00dddd">Run completed in 386 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 1, failed 1, ignored 1, pending 1</span>
<span style="color: #dd2233">*** 1 TEST FAILED ***</span>
</pre></p><p>And to enable both durations and statistics during a single run, you could write:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> durations.stats.run(new ArithmeticSuite)</span>
<span style="color: #00dddd">Run starting. Expected test count is: 3</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (102 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED (36 milliseconds)***
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00dddd">Run completed in 386 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 1, failed 1, ignored 1, pending 1</span>
<span style="color: #dd2233">*** 1 TEST FAILED ***</span>
</pre></p><p>The order doesn't matter when you are chaining multiple configuration commands. You'll get the same
result whether you write <code>durations.stats.run</code> or <code>stats.durations.run</code>.</p><p>To disable color, use <code>nocolor</code>:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> nocolor.run(new ArithmeticSuite)
ArithmeticSuite:
- addition works
- subtraction works !!! IGNORED !!!
- multiplication works *** FAILED ***
  1 did not equal 2 (<console>:16)
- division works (pending)</span>
</pre></p><p>To enable short stack traces during a single run, use <code>shortstacks</code>:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> shortstacks.run(new ArithmeticSuite)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (101 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (33 milliseconds)
  1 did not equal 2 (<console>:16)
  org.scalatest.exceptions.TestFailedException:
  ...
  at line2$object$$iw$$iw$$iw$$iw$ArithmeticSuite$$anonfun$3.apply$mcV$sp(<console>:16)
  at line2$object$$iw$$iw$$iw$$iw$ArithmeticSuite$$anonfun$3.apply(<console>:16)
  at line2$object$$iw$$iw$$iw$$iw$ArithmeticSuite$$anonfun$3.apply(<console>:16)
  at org.scalatest.FunSuite$$anon$1.apply(FunSuite.scala:992)
  at org.scalatest.Suite$class.withFixture(Suite.scala:1661)
  at line2$object$$iw$$iw$$iw$$iw$ArithmeticSuite.withFixture(<console>:8)
  at org.scalatest.FunSuite$class.invokeWithFixture$1(FunSuite.scala:989)
  ...</span>
<span style="color: #cfc923">- division works (pending)</span>
</pre></p><h4> Changing the default configuration </h4><p>If you want to change the default for multiple runs, you can import the members of your favorite <code>Shell</code> configuration. For example,
if you <em>always</em> like to run with durations and statistics enabled, you could write:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> import stats.durations._
import stats.durations._</span>
</pre></p><p>Now anytime you run statistics and durations will, by default, be enabled:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> run(new ArithmeticSuite)</span>
<span style="color: #00dddd">Run starting. Expected test count is: 3</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (9 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (10 milliseconds)
  1 did not equal 2 (<console>:18)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00dddd">Run completed in 56 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 1, failed 1, ignored 1, pending 1</span>
<span style="color: #dd2233">*** 1 TEST FAILED ***</span>
</pre></p><h4> Running multiple suites </h4><p>If you want to run multiple suites, you can use the factory method in the <a href="Suites$.html"><code>Suites</code></a>
singleton object. If you wrap a comma-separated list of suite instances inside <code>Suites(...)</code>, for example,
you'll get a suite instance that contains no tests, but whose nested suites includes the suite instances you placed between
the parentheses. You can place <code>Suites</code> inside <code>Suites</code> to any level of depth, creating a tree of
suites to pass to <code>run</code>. Here's a (contrived) example in which <code>ArithmeticSuite</code> is executed four times:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> run(Suites(new ArithmeticSuite, new ArithmeticSuite, Suites(new ArithmeticSuite, new ArithmeticSuite)))</span>
<span style="color: #00dddd">Run starting. Expected test count is: 12</span>
<span style="color: #00cc00">Suites:
ArithmeticSuite:
- addition works (0 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (1 millisecond)
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (1 millisecond)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (0 milliseconds)
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00cc00">Suites:
ArithmeticSuite:
- addition works (0 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (0 milliseconds)
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works (0 milliseconds)</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED *** (0 milliseconds)
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
<span style="color: #00dddd">Run completed in 144 milliseconds.
Total number of tests run: 8
Suites: completed 6, aborted 0
Tests: succeeded 4, failed 4, ignored 4, pending 4</span>
<span style="color: #dd2233">*** 4 TESTS FAILED ***</span>
</pre></p><h4> Running a single test </h4><p>The <code>run</code> command also allows you to specify the name of a test to run and/or a config map. You can run
a particular test in a suite, for example, by specifying the test name after the suite instance in your call to <code>run</code>, like this:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala> run(new ArithmeticSuite, "addition works")</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.StatefulStatus" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StatefulStatusextendsStatuswithSerializable"></a><a id="StatefulStatus:StatefulStatus"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StatefulStatusextendsStatuswithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Status implementation that can change its state over time." href="StatefulStatus.html"><span class="name">StatefulStatus</span></a><span class="result"> extends <a href="Status.html" class="extype" name="org.scalatest.Status">Status</a> with <span class="extype" name="java.io.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Status implementation that can change its state over time.</p><div class="fullcomment"><div class="comment cmt"><p>Status implementation that can change its state over time.</p><p>A <code>StatefulStatus</code> begins its life in a successful state, and will remain successful unless <code>setFailed</code> is called.
Once <code>setFailed</code> is called, the status will remain at failed. The <code>setFailed</code> method can be called multiple times (even
though invoking it once is sufficient to permanently set the status to failed), but only up until <code>setCompleted</code> has been called.
After <code>setCompleted</code> has been called, any invocation of <code>setFailed</code> will be greeted with an <code>IllegalStateException</code>.</p><p>Instances of this class are thread safe.</p></div></div>
    </li><li name="org.scalatest.Status" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StatusextendsAnyRef"></a><a id="Status:Status"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StatusextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="The result status of running a test or a suite, which is used to support parallel and asynchronous execution of tests." href="Status.html"><span class="name">Status</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">The result status of running a test or a suite, which is used to support parallel and asynchronous execution of tests.</p><div class="fullcomment"><div class="comment cmt"><p>The result status of running a test or a suite, which is used to support parallel and asynchronous execution of tests.</p><p>This trait is the result type of the &quot;run&quot; lifecycle methods of trait <a href="Suite.html#lifecycle-methods"><code>Suite</code></a>:
<code>run</code>, <code>runNestedSuites</code>, <code>runTests</code>, and <code>runTest</code>. It can be used to determine whether
a test or suite has completed, and if so, whether it succeeded, and if not, whether an exception was thrown that was
not yet reported via a ScalaTest event. A <code>Status</code> is like a domain-specific <code>Future[Boolean]</code>, where:</p><ul><li>an activity in which no test failed and no suite aborted is represented by <code>Success(true)</code></li><li>an activity during which at least one test failed or one suite aborted, but all exceptions that occured
    were reported by a ScalaTest events (such as <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a>)
    is represented by <code>Success(false)</code></li><li>an activity during which at least one test failed or one suite aborted and at least one exception occurred that was
    <em>not</em> reported via a ScalaTest event is represented by <code>Failure(unreportedException)</code></li></ul><p>Note that pending and canceled tests will not cause a <code>Status</code> to fail. Only failed tests
and aborted suites will cause a <code>Status</code> to fail.</p><p>One use case of <code>Status</code> is to ensure that &quot;after&quot; code (such as an <code>afterEach</code> or <code>afterAll</code> method)
does not execute until after the relevant entity (one test, one suite, or all of a suite's tests or nested suites) has completed.
Another use case is to implement the default behavior of asynchronous styles, in which subsequent each test does not begin
execution until after the previous test has completed.</p></div></div>
    </li><li name="org.scalatest.Stepwise" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StepwiseextendsSuitewithStepwiseNestedSuiteExecution"></a><a id="Stepwise:Stepwise"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StepwiseextendsSuitewithStepwiseNestedSuiteExecution" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A Suite class that takes zero to many Suites, which will be returned from its nestedSuites method and executed in &amp;ldquo;stepwise&amp;rdquo; fashion by its runNestedSuites method." href="Stepwise.html"><span class="name">Stepwise</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a> with <a href="StepwiseNestedSuiteExecution.html" class="extype" name="org.scalatest.StepwiseNestedSuiteExecution">StepwiseNestedSuiteExecution</a></span>
      </span>
      
      <p class="shortcomment cmt">A <code>Suite</code> class that takes zero to many <code>Suite</code>s,
which will be returned from its <code>nestedSuites</code> method and
executed in &ldquo;stepwise&rdquo; fashion by its <code>runNestedSuites</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>Suite</code> class that takes zero to many <code>Suite</code>s,
which will be returned from its <code>nestedSuites</code> method and
executed in &ldquo;stepwise&rdquo; fashion by its <code>runNestedSuites</code> method.</p><p>For example, you can define a suite that always executes a list of
nested suites like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StepsSuite</span> <span class="stReserved">extends</span> <span class="stType">Stepwise</span>(
  <span class="stReserved">new</span> <span class="stType">Step1Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step2Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step3Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step4Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step5Suite</span>
)
</pre></p><p>When <code>StepsSuite</code> is executed, regardless of whether a <a href="Distributor.html"><code>Distributor</code></a>
is passed, it will execute its
nested suites sequentially in the passed order: <code>Step1Suite</code>, <code>Step2Suite</code>,
<code>Step3Suite</code>, <code>Step4Suite</code>, and <code>Step5Suite</code>.</p><p>The difference between <code>Stepwise</code> and <a href="Sequential.html"><code>Sequential</code></a>
is that although <code>Stepwise</code> executes its own nested suites sequentially, it passes
whatever distributor was passed to it to those nested suites. Thus the nested suites could run their own nested
suites and tests in parallel if that distributor is defined. By contrast, <code>Sequential</code> always
passes <code>None</code> for the distributor to the nested suites, so any and every test and nested suite
contained within the nested suites passed to the <code>Sequential</code> construtor will be executed sequentially.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NullArgumentException"><code>NullArgumentException</code></span> if <code>suitesToNest</code>, or any suite
it contains, is <code>null</code>.</p></span></dd></dl></div>
    </li><li name="org.scalatest.StepwiseNestedSuiteExecution" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StepwiseNestedSuiteExecutionextendsSuiteMixin"></a><a id="StepwiseNestedSuiteExecution:StepwiseNestedSuiteExecution"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StepwiseNestedSuiteExecutionextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if a Distributor is passed to runNestedSuites." href="StepwiseNestedSuiteExecution.html"><span class="name">StepwiseNestedSuiteExecution</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if
a <a href="Distributor.html"><code>Distributor</code></a> is passed to <code>runNestedSuites</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that causes the nested suites of any suite it is mixed into to be run sequentially even if
a <a href="Distributor.html"><code>Distributor</code></a> is passed to <code>runNestedSuites</code>. This trait overrides the
<code>runNestedSuites</code> method and fowards every parameter passed to it to a superclass invocation
of <code>runNestedSuites</code>, except it always passes <code>None</code> for the <code>Distributor</code>.
Mix in this trait into any suite whose nested suites need to be run sequentially even with the rest of the
run is being executed concurrently.
</p></div></div>
    </li><li name="org.scalatest.Stopper" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StopperextendsAnyRef"></a><a id="Stopper:Stopper"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StopperextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose instances can accept a stop request and indicate whether a stop has already been requested." href="Stopper.html"><span class="name">Stopper</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose instances can accept a stop request and indicate whether a stop has already been requested.</p><div class="fullcomment"><div class="comment cmt"><p>Trait whose instances can accept a stop request and indicate whether a stop has already been requested.</p><p>This is passed in
to the <code>run</code> method of <a href="Suite.html"><code>Suite</code></a>, so that running suites of tests can be
requested to stop early.</p></div></div>
    </li><li name="org.scalatest.StreamlinedXml" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXmlextendsAnyRef"></a><a id="StreamlinedXml:StreamlinedXml"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXmlextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing a streamlined method that returns a Uniformity[T] instance for any subtype of scala.xml.NodeSeq that will normalize the XML by removing empty text nodes and trimming non-empty text nodes." href="StreamlinedXml.html"><span class="name">StreamlinedXml</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing a <code>streamlined</code> method that returns a <a href="../scalactic/Uniformity.html"><code>Uniformity[T]</code></a>
instance for any subtype of <code>scala.xml.NodeSeq</code> that will normalize the XML by removing empty text nodes and trimming
non-empty text nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing a <code>streamlined</code> method that returns a <a href="../scalactic/Uniformity.html"><code>Uniformity[T]</code></a>
instance for any subtype of <code>scala.xml.NodeSeq</code> that will normalize the XML by removing empty text nodes and trimming
non-empty text nodes.</p><p>Here's an example of some unnormalized XML:</p><p><pre class="stHighlighted">
&lt;summer&gt;
  &lt;day&gt;&lt;/day&gt;
  &lt;night&gt;
    <span class="stReserved">with</span> lots of stars
  &lt;/night&gt;
&lt;/summer&gt;
</pre></p><p>The <code>Uniformity</code> returned by this trait's <code>streamlined</code> method would transform
the above XML to:</p><p><pre class="stHighlighted">
&lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;<span class="stReserved">with</span> lots of stars&lt;/night&gt;&lt;/summer&gt;
</pre></p><p>The <code>streamlined</code> method can be used with the <a href="../scalactic/Explicitly.html"><code>Explicitly</code></a> DSL, like this:</p><p><pre class="stHighlighted">
xmlElem should equal (
  &lt;summer&gt;
    &lt;day&gt;&lt;/day&gt;
    &lt;night&gt;
      <span class="stReserved">with</span> lots of stars
    &lt;/night&gt;
  &lt;/summer&gt;
) (after being streamlined[<span class="stType">Elem</span>])
</pre></p><p>The goal of this trait is to provide a normalization for XML that makes it easier to test XML objects for equality.
White space is significant in XML, and is taken into account by the default equality for XML, accessed
by invoking the <code>==</code> method on an XML <code>NodeSeq</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; val xmlElem = &lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;with lots of stars&lt;/night&gt;&lt;/summer&gt;
xmlElem: scala.xml.Elem = &lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;with lots of stars&lt;/night&gt;&lt;/summer&gt;

scala&gt; xmlElem == &lt;summer&gt;
     |   &lt;day&gt;&lt;/day&gt;
     |   &lt;night&gt;
     |     with lots of stars
     |   &lt;/night&gt;
     | &lt;/summer&gt;
res1: Boolean = false
</pre></p><p>The above equality comparison produces false because of whitespace differences in the XML.
When such whitespace differences are unimportant to the actual application, it can make it
easier to write readable test code if you can compare XML for equality without taking
into account empty text nodes, or leading and trailing whitespace in nonempty text nodes.
The <code>streamlined</code> method of this trait provides a <code>Uniformity</code>
instance that does just that:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import Explicitly._
import Explicitly._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; import org.scalatest.StreamlinedXml._
import StreamlinedXml._

scala&gt; import scala.xml.Elem
import scala.xml.Elem *

scala&gt; (xmlElem === &lt;summer&gt;
     |   &lt;day&gt;&lt;/day&gt;
     |   &lt;night&gt;
     |     with lots of stars
     |   &lt;/night&gt;
     | &lt;/summer&gt;) (after being streamlined[Elem])
res9: Boolean = true
</pre>
</p></div></div>
    </li><li name="org.scalatest.StreamlinedXmlEquality" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXmlEqualityextendsAnyRef"></a><a id="StreamlinedXmlEquality:StreamlinedXmlEquality"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXmlEqualityextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait providing an implicit Equality[T] for subtypes of scala.xml.NodeSeq that before testing for equality, will normalize left and right sides by removing empty XML text nodes and trimming non-empty text nodes." href="StreamlinedXmlEquality.html"><span class="name">StreamlinedXmlEquality</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait providing an implicit <a href="../scalactic/Equality.html"><code>Equality[T]</code></a> for subtypes
of <code>scala.xml.NodeSeq</code> that before testing for equality, will normalize left and right sides
by removing empty XML text nodes and trimming non-empty text nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit <a href="../scalactic/Equality.html"><code>Equality[T]</code></a> for subtypes
of <code>scala.xml.NodeSeq</code> that before testing for equality, will normalize left and right sides
by removing empty XML text nodes and trimming non-empty text nodes.</p><p>Here's an example of some unnormalized XML:</p><p><pre class="stHighlighted">
&lt;summer&gt;
  &lt;day&gt;&lt;/day&gt;
  &lt;night&gt;
    <span class="stReserved">with</span> lots of stars
  &lt;/night&gt;
&lt;/summer&gt;
</pre></p><p>Prior to testing it for equality, the implicit <code>Equality[T]</code> provided by this trait would transform
the above XML to:</p><p><pre class="stHighlighted">
&lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;<span class="stReserved">with</span> lots of stars&lt;/night&gt;&lt;/summer&gt;
</pre></p><p>The goal of this trait is to provide an implicit <code>Equality</code> for XML that makes it easier to write tests involving XML.
White space is significant in XML, and is taken into account by the default equality for XML, accessed
by invoking the <code>==</code> method on an XML <code>NodeSeq</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; val xmlElem = &lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;with lots of stars&lt;/night&gt;&lt;/summer&gt;
xmlElem: scala.xml.Elem = &lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;with lots of stars&lt;/night&gt;&lt;/summer&gt;

scala&gt; import org.scalatest.Assertions._
import org.scalatest.Assertions._

scala&gt; assert(xmlElem === &lt;summer&gt;
     |   &lt;day&gt;&lt;/day&gt;
     |     &lt;night&gt;
     |       with lots of stars
     |     &lt;/night&gt;
     |   &lt;/summer&gt;)
org.scalatest.exceptions.TestFailedException: &lt;summer&gt;&lt;day&gt;&lt;/day&gt;&lt;night&gt;with lots of stars&lt;/night&gt;&lt;/summer&gt; did not equal &lt;summer&gt;
  &lt;day&gt;&lt;/day&gt;
    &lt;night&gt;
      with lots of stars
    &lt;/night&gt;
  &lt;/summer&gt;
  at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:500)
  at org.scalatest.Assertions$.newAssertionFailedException(Assertions.scala:1538)
  at org.scalatest.Assertions$AssertionsHelper.macroAssert(Assertions.scala:466)
  ... 53 elided
</pre></p><p>The above assertion fails because of whitespace differences in the XML.
When such whitespace differences are unimportant to the actual application, it can make it
easier to write readable test code if you can compare XML for equality without taking
into account empty text nodes, or leading and trailing whitespace in nonempty text nodes.
This trait provides an <code>Equality[T]</code>
instance that does just that:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.StreamlinedXmlEquality._
import org.scalatest.StreamlinedXmlEquality._

scala&gt; assert(xmlElem === &lt;summer&gt;
     |   &lt;day&gt;&lt;/day&gt;
     |   &lt;night&gt;
     |     with lots of stars
     |   &lt;/night&gt;
     | &lt;/summer&gt;)
</pre>
</p></div></div>
    </li><li name="org.scalatest.StreamlinedXmlNormMethods" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXmlNormMethodsextendsStreamlinedXmlwithNormMethods"></a><a id="StreamlinedXmlNormMethods:StreamlinedXmlNormMethods"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXmlNormMethodsextendsStreamlinedXmlwithNormMethods" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Subtrait of NormMethods that provides an implicit Uniformity[T] for subtypes of scala.xml.NodeSeq that enables you to streamline XML by invoking .norm on it." href="StreamlinedXmlNormMethods.html"><span class="name">StreamlinedXmlNormMethods</span></a><span class="result"> extends <a href="StreamlinedXml.html" class="extype" name="org.scalatest.StreamlinedXml">StreamlinedXml</a> with <span class="extype" name="org.scalactic.NormMethods">NormMethods</span></span>
      </span>
      
      <p class="shortcomment cmt">Subtrait of <a href="../scalactic/NormMethods.html"><code>NormMethods</code></a> that provides
an implicit <code>Uniformity[T]</code> for subtypes of <code>scala.xml.NodeSeq</code> that enables
you to streamline XML by invoking <code>.norm</code> on it.</p><div class="fullcomment"><div class="comment cmt"><p>Subtrait of <a href="../scalactic/NormMethods.html"><code>NormMethods</code></a> that provides
an implicit <code>Uniformity[T]</code> for subtypes of <code>scala.xml.NodeSeq</code> that enables
you to streamline XML by invoking <code>.norm</code> on it.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; &lt;good&gt;&lt;day&gt;sunshine&lt;/day&gt;&lt;/good&gt; == &lt;good&gt;
     |   &lt;day&gt;
     |     sunshine
     |   &lt;/day&gt;
     | &lt;/good&gt;
res1: Boolean = false

scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; import org.scalatest.StreamlinedXmlNormMethods._
import org.scalatest.StreamlinedXmlNormMethods._

scala&gt; &lt;good&gt;&lt;day&gt;sunshine&lt;/day&gt;&lt;/good&gt; === &lt;good&gt;
     |   &lt;day&gt;
     |     sunshine
     |   &lt;/day&gt;
     | &lt;/good&gt;.norm
res2: Boolean = true
</pre>
</p></div></div>
    </li><li name="org.scalatest.Suite" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SuiteextendsAssertionswithSerializable"></a><a id="Suite:Suite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SuiteextendsAssertionswithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="A suite of tests." href="Suite.html"><span class="name">Suite</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">A suite of tests.</p><div class="fullcomment"><div class="comment cmt"><p>A suite of tests. A <code>Suite</code> instance encapsulates a conceptual
suite (<em>i.e.</em>, a collection) of tests.</p><p>This trait provides an interface composed of &quot;lifecycle methods&quot; that allow suites of tests to be run.
Its implementation enables a default way of writing and executing tests.  Subtraits and subclasses can
override <code>Suite</code>'s lifecycle methods to enable other ways of writing and executing tests.</p><h4> Nested suites </h4><p>A <code>Suite</code> can refer to a collection of other <code>Suite</code>s,
which are called <em>nested</em> <code>Suite</code>s. Those nested  <code>Suite</code>s can in turn have
their own nested  <code>Suite</code>s, and so on. Large test suites can be organized, therefore, as a tree of
nested <code>Suite</code>s.
This trait's <code>run</code> method, in addition to invoking its
test methods, invokes <code>run</code> on each of its nested <code>Suite</code>s.</p><p>A <code>List</code> of a <code>Suite</code>'s nested <code>Suite</code>s can be obtained by invoking its
<code>nestedSuites</code> method. If you wish to create a <code>Suite</code> that serves as a
container for nested <code>Suite</code>s, whether or not it has test methods of its own, simply override <code>nestedSuites</code>
to return a <code>List</code> of the nested <code>Suite</code>s. Because this is a common use case, ScalaTest provides
a convenience <code>Suites</code> class, which takes a variable number of nested <code>Suite</code>s as constructor
parameters. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.suite.nested
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ASuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
  test(<span class="stQuotedString">"A should have ASCII value 41 hex"</span>) {
    assert(<span class="stQuotedString">'A'</span> === <span class="stLiteral">0x41</span>)
  }
  test(<span class="stQuotedString">"a should have ASCII value 61 hex"</span>) {
    assert(<span class="stQuotedString">'a'</span> === <span class="stLiteral">0x61</span>)
  }
}
<span class="stReserved">class</span> <span class="stType">BSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
  test(<span class="stQuotedString">"B should have ASCII value 42 hex"</span>) {
    assert(<span class="stQuotedString">'B'</span> === <span class="stLiteral">0x42</span>)
  }
  test(<span class="stQuotedString">"b should have ASCII value 62 hex"</span>) {
    assert(<span class="stQuotedString">'b'</span> === <span class="stLiteral">0x62</span>)
  }
}
<span class="stReserved">class</span> <span class="stType">CSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> {
  test(<span class="stQuotedString">"C should have ASCII value 43 hex"</span>) {
    assert(<span class="stQuotedString">'C'</span> === <span class="stLiteral">0x43</span>)
  }
  test(<span class="stQuotedString">"c should have ASCII value 63 hex"</span>) {
    assert(<span class="stQuotedString">'c'</span> === <span class="stLiteral">0x63</span>)
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ASCIISuite</span> <span class="stReserved">extends</span> <span class="stType">Suites</span>(
  <span class="stReserved">new</span> <span class="stType">ASuite</span>,
  <span class="stReserved">new</span> <span class="stType">BSuite</span>,
  <span class="stReserved">new</span> <span class="stType">CSuite</span>
)
</pre></p><p>If you now run <code>ASCIISuite</code>:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ASCIISuite)
</pre></p><p>You will see reports printed to the standard output that indicate the nested
suites&#8212;<code>ASuite</code>, <code>BSuite</code>, and
<code>CSuite</code>&#8212;were run:</p><p><pre class="stREPL">
<span class="stGreen">ASCIISuite:
ASuite:
- A should have ASCII value 41 hex
- a should have ASCII value 61 hex
BSuite:
- B should have ASCII value 42 hex
- b should have ASCII value 62 hex
CSuite:
- C should have ASCII value 43 hex
- c should have ASCII value 63 hex</span>
</pre></p><p>Note that <code>Runner</code> can discover <code>Suite</code>s automatically, so you need not
necessarily define nested <code>Suites</code> explicitly. See the <a href="tools/Runner$.html#membersOnlyWildcard">documentation
for <code>Runner</code></a> for more information.</p><p><a name="configMapSection"></a></p><h4> The config map </h4><p>In some cases you may need to pass information to a suite of tests.
For example, perhaps a suite of tests needs to grab information from a file, and you want
to be able to specify a different filename during different runs.  You can accomplish this in ScalaTest by passing
the filename in a <em>config map</em> of key-value pairs, which is passed to <code>run</code> as a <a href="ConfigMap.html"><code>ConfigMap</code></a>.
The values in the config map are called &quot;config objects,&quot; because they can be used to <em>configure</em>
suites, reporters, and tests.</p><p>You can specify a string config object is via the ScalaTest <code>Runner</code>, either via the command line
or ScalaTest's ant task.
(See the <a href="tools/Runner$.html#configMapSection">documentation for Runner</a> for information on how to specify
config objects on the command line.)
The config map is passed to <code>run</code>, <code>runNestedSuites</code>, <code>runTests</code>, and <code>runTest</code>,
so one way to access it in your suite is to override one of those methods. If you need to use the config map inside your tests, you
can access it from the <code>NoArgTest</code> passed to <code>withFixture</code>, or the <code>OneArgTest</code> passed to
<code>withFixture</code> in the traits in the <code>org.scalatest.fixture</code> package. (See the
<a href="fixture/Suite.html">documentation for <code>fixture.Suite</code></a>
for instructions on how to access the config map in tests.)</p><h4> Executing suites in parallel </h4><p>The <code>run</code> method takes as one of its parameters an optional <a href="Distributor.html"><code>Distributor</code></a>. If
a <code>Distributor</code> is passed in, this trait's implementation of <code>run</code> puts its nested
<code>Suite</code>s into the distributor rather than executing them directly. The caller of <code>run</code>
is responsible for ensuring that some entity runs the <code>Suite</code>s placed into the
distributor. The <code>-P</code> command line parameter to <code>Runner</code>, for example, will cause
<code>Suite</code>s put into the <code>Distributor</code> to be run in parallel via a pool of threads.
If you wish to execute the tests themselves in parallel, mix in <a href="ParallelTestExecution.html"><code>ParallelTestExecution</code></a>.</p><p><a name="errorHandling"></a></p><h4> &quot;Run-aborting&quot; exceptions </h4><p>The Javadoc documentation for <code>java.lang.Error</code> states:</p><p><blockquote>
An <code>Error</code> is a subclass of <code>Throwable</code> that indicates serious problems that a reasonable application
should not try to catch. Most
such errors are abnormal conditions.
</blockquote></p><p>Because <code>Error</code>s are used to denote serious errors, trait <code>Suite</code> and its subtypes in the ScalaTest API
do not always treat a test that completes abruptly with an <code>Error</code> as a test failure, but sometimes as an indication
that serious problems have arisen that should cause the run to abort. For example, if a test completes abruptly with an
<code>OutOfMemoryError</code>, it will not be reported as a test failure, but will instead cause the run to abort. Because not
everyone uses <code>Error</code>s only to represent serious
problems, however, ScalaTest only behaves this way for the following <em>run-aborting</em> exception types (and their subclasses):</p><ul><li><code>java.lang.annotation.AnnotationFormatError</code></li><li><code>java.awt.AWTError</code></li><li><code>java.nio.charset.CoderMalfunctionError</code></li><li><code>javax.xml.parsers.FactoryConfigurationError</code></li><li><code>java.lang.LinkageError</code></li><li><code>java.lang.ThreadDeath</code></li><li><code>javax.xml.transform.TransformerFactoryConfigurationError</code></li><li><code>java.lang.VirtualMachineError</code></li></ul><p>The previous list includes all <code>Error</code>s that exist as part of Java 1.5 API, excluding <code>java.lang.AssertionError</code>.
ScalaTest does treat a thrown <code>AssertionError</code> as an indication of a test failure. In addition, any other
<code>Error</code> that is not an instance of a type mentioned in the previous list will be caught by the <code>Suite</code> traits
in the ScalaTest API and reported as the cause of a test failure.</p><p>Although trait <code>Suite</code> and all its subtypes in the ScalaTest API consistently behave this way with regard to <code>Error</code>s,
this behavior is not required by the contract of <code>Suite</code>. Subclasses and subtraits that you define, for example, may treat all
<code>Error</code>s as test failures, or indicate errors in some other way that has nothing to do with exceptions.</p><p><a name="lifecyle-methods"></a></p><h4> Extensibility </h4><p>Trait <code>Suite</code> provides default implementations of its methods that should
be sufficient for most applications, but many methods can be overridden when desired. Here's
a summary of the methods that are intended to be overridden:</p><ul><li><code>run</code> - override this method to define custom ways to run suites of
  tests.</li><li><code>runNestedSuites</code> - override this method to define custom ways to run nested suites.</li><li><code>runTests</code> - override this method to define custom ways to run a suite's tests.</li><li><code>runTest</code> - override this method to define custom ways to run a single named test.</li><li><code>testNames</code> - override this method to specify the <code>Suite</code>'s test names in a custom way.</li><li><code>tags</code> - override this method to specify the <code>Suite</code>'s test tags in a custom way.</li><li><code>nestedSuites</code> - override this method to specify the <code>Suite</code>'s nested <code>Suite</code>s in a custom way.</li><li><code>suiteName</code> - override this method to specify the <code>Suite</code>'s name in a custom way.</li><li><code>expectedTestCount</code> - override this method to count this <code>Suite</code>'s expected tests in a custom way.</li></ul><p>For example, this trait's implementation of <code>testNames</code> performs reflection to discover methods starting with <code>test</code>,
and places these in a <code>Set</code> whose iterator returns the names in alphabetical order. If you wish to run tests in a different
order in a particular <code>Suite</code>, perhaps because a test named <code>testAlpha</code> can only succeed after a test named
<code>testBeta</code> has run, you can override <code>testNames</code> so that it returns a <code>Set</code> whose iterator returns
<code>testBeta</code> <em>before</em> <code>testAlpha</code>. (This trait's implementation of <code>run</code> will invoke tests
in the order they come out of the <code>testNames</code> <code>Set</code> iterator.)</p><p>Alternatively, you may not like starting your test methods with <code>test</code>, and prefer using <code>@Test</code> annotations in
the style of Java's JUnit 4 or TestNG. If so, you can override <code>testNames</code> to discover tests using either of these two APIs
<code>@Test</code> annotations, or one of your own invention. (This is in fact
how <code>org.scalatest.junit.JUnitSuite</code> and <code>org.scalatest.testng.TestNGSuite</code> work.)</p><p>Moreover, <em>test</em> in ScalaTest does not necessarily mean <em>test method</em>. A test can be anything that can be given a name,
that starts and either succeeds or fails, and can be ignored. In <code>org.scalatest.FunSuite</code>, for example, tests are represented
as function values. This
approach might look foreign to JUnit users, but may feel more natural to programmers with a functional programming background.
To facilitate this style of writing tests, <code>FunSuite</code> overrides <code>testNames</code>, <code>runTest</code>, and <code>run</code> such that you can
define tests as function values.</p><p>You can also model existing JUnit 3, JUnit 4, or TestNG tests as suites of tests, thereby incorporating tests written in Java into a ScalaTest suite.
The &quot;wrapper&quot; classes in packages <code>org.scalatest.junit</code> and <code>org.scalatest.testng</code> exist to make this easy.
No matter what legacy tests you may have, it is likely you can create or use an existing <code>Suite</code> subclass that allows you to model those tests
as ScalaTest suites and tests and incorporate them into a ScalaTest suite. You can then write new tests in Scala and continue supporting
older tests in Java.</p></div></div>
    </li><li name="org.scalatest.SuiteMixin" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SuiteMixinextendsAnyRef"></a><a id="SuiteMixin:SuiteMixin"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SuiteMixinextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait defining abstract &quot;lifecycle&quot; methods that are implemented in Suite and can be overridden in stackable modification traits." href="SuiteMixin.html"><span class="name">SuiteMixin</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait defining abstract &quot;lifecycle&quot; methods that are implemented in <a href="Suite.html#lifecycle-methods"><code>Suite</code></a> and can
be overridden in stackable modification traits.</p><div class="fullcomment"><div class="comment cmt"><p>Trait defining abstract &quot;lifecycle&quot; methods that are implemented in <a href="Suite.html#lifecycle-methods"><code>Suite</code></a> and can
be overridden in stackable modification traits.</p><p>The main purpose of <code>SuiteMixin</code> is to differentiate core <code>Suite</code>
style traits, such as <a href="Spec.html"><code>Spec</code></a>, <a href="FunSuite.html"><code>FunSuite</code></a>, and <a href="FunSpec.html"><code>FunSpec</code></a> from stackable
modification traits for <code>Suite</code>s such as <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>, <a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>,
and <a href="SequentialNestedSuiteExecution.html"><code>SequentialNestedSuiteExecution</code></a>. Because these stackable traits extend <code>SuiteMixin</code>
instead of <code>Suite</code>, you can't define a suite by simply extending one of the stackable traits:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MySuite</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> <span class="stLineComment">// Won't compile</span>
</pre></p><p>Instead, you need to extend a core <code>Suite</code> trait and mix the stackable <code>BeforeAndAfterEach</code> trait
into that, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">MySuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfterEach</span> <span class="stLineComment">// Compiles fine</span>
</pre>
</p></div></div>
    </li><li name="org.scalatest.Suites" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SuitesextendsSuite"></a><a id="Suites:Suites"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SuitesextendsSuite" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A Suite class that takes zero to many Suites in its constructor, which will be returned from its nestedSuites method." href="Suites.html"><span class="name">Suites</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a></span>
      </span>
      
      <p class="shortcomment cmt">A <code>Suite</code> class that takes zero to many <code>Suite</code>s in its constructor,
 which will be returned from its <code>nestedSuites</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>Suite</code> class that takes zero to many <code>Suite</code>s in its constructor,
 which will be returned from its <code>nestedSuites</code> method.</p><p>For example, you can define a suite that always executes a list of
nested suites like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">StepsSuite</span> <span class="stReserved">extends</span> <span class="stType">Suites</span>(
  <span class="stReserved">new</span> <span class="stType">Step1Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step2Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step3Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step4Suite</span>,
  <span class="stReserved">new</span> <span class="stType">Step5Suite</span>
)
</pre></p><p>If <code>StepsSuite</code> is executed sequentially, it will execute its
nested suites in the passed order: <code>Step1Suite</code>, <code>Step2Suite</code>,
<code>Step3Suite</code>, <code>Step4Suite</code>, and <code>Step5Suite</code>.
If <code>StepsSuite</code> is executed in parallel, the nested suites will
be executed concurrently.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NullPointerException"><code>NullPointerException</code></span> if <code>suitesToNest</code>, or any suite
it contains, is <code>null</code>.</p></span></dd></dl></div>
    </li><li name="org.scalatest.Tag" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TagextendsAnyRef"></a><a id="Tag:Tag"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TagextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Class whose subclasses can be used to tag tests in style traits in which tests are defined as functions." href="Tag.html"><span class="name">Tag</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Class whose subclasses can be used to tag tests in style traits in which tests are defined as functions.</p><div class="fullcomment"><div class="comment cmt"><p>Class whose subclasses can be used to tag tests in style traits in which tests are defined as functions.</p><p>ScalaTest has two ways to tag tests: annotations and instances of this <code>Tag</code> class.
To tag a test method or an entire test class, you use a <em>tag annotation</em>, whereas to tag a test function,
you use a <code>Tag</code> object. Though not required, it is usually a good idea to define both an annotation
and a corresponding <code>Tag</code> object for each conceptual tag you want, so you can tag anything: test functions, test classes,
and test methods. The name of the conceptual tag is the fully qualified name of the annotation interface, so you must
pass this name to the <code>Tag</code> constructor.</p><p>For example, imagine you want to tag integration tests that use the actual database, and are, therefore, generally slower. You could
create a tag annotation and object called <code>DbTest</code>. To give them both the same simple name, you can declare them in different packages.
The tag annotation must be written in Java, not Scala, because annotations written
in Scala are not accessible at runtime. Here's an example:</p><p><pre>
package com.mycompany.myproject.testing.tags;

import java.lang.annotation.*;
import org.scalatest.TagAnnotation

@TagAnnotation
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface DbTest {}
</pre></p><p>Given this annotation's fully qualified name is <code>com.mycompany.myproject.testing.tags.DbTest</code> the corresponding <code>Tag</code>
object decaration must have that name passed to its constructor, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> com.mycompany.myproject.testing.tagobjects
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.myproject.testing.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could tag a test function as a <code>DbTest</code> in, for
example, a <a href="FlatSpec.html"><code>FlatSpec</code></a> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> com.mycompany.myproject.testing.tagobjects.DbTest
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"Integration tests"</span> can <span class="stQuotedString">"sometimes be slow"</span> taggedAs(<span class="stType">DbTest</span>) in {
    Thread.sleep(<span class="stLiteral">1000</span>)
  }
}
</pre></p><p>You could tag a test method as a <code>DbTest</code> in, for
example, a <a href="Suite.html"><code>Suite</code></a> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.Suite
<span class="stReserved">import</span> com.mycompany.myproject.testing.tags.DbTest
<br/><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">Suite</span> {
<br/>  @<span class="stType">DbTest</span>
  <span class="stReserved">def</span> <span class="literalIdentifier">&#96;integration tests can sometimes be slow&#96;</span> {
    Thread.sleep(<span class="stLiteral">1000</span>)
  }
}
</pre></p><p>And you could tag all the tests in an entire test class by annotating the class, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> com.mycompany.myproject.testing.tags.DbTest
<br/>@<span class="stType">DBTest</span>
<span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br/>  <span class="stQuotedString">"Integration tests"</span> can <span class="stQuotedString">"sometimes be slow"</span> in {
    Thread.sleep(<span class="stLiteral">1000</span>)
  }
<br/>  they should <span class="stQuotedString">"likely sometimes be excluded "</span> in {
    Thread.sleep(<span class="stLiteral">1000</span>)
  }
}
</pre></p><p>In the previous example, both tests will be tagged as <code>DBTest</code>s even though the
tests are not tagged as such individually.</p><p>When you run ScalaTest and want to either include or exclude <code>DbTest</code>s, you'd give the fully qualified
name of the tag annotation (which is also the name passed to the corresponding <code>Tag</code> constructor) to <a href="tools/Runner$.html"><code>Runner</code></a>. For
example, here's how you'd exclude <code>DbTest</code>s on the <code>Runner</code> command line:</p><p><pre>
-l com.mycompany.myproject.testing.tags.DbTest
</pre></p><p>For examples of tagging in other style traits, see the &quot;Tagging tests&quot; section in the documentation for the trait:</p><ul><li><a href="FeatureSpec.html#taggingTests">Tagging <code>FeatureSpec</code> tests</a></li><li><a href="FlatSpec.html#taggingTests">Tagging <code>FlatSpec</code> tests</a></li><li><a href="FreeSpec.html#taggingTests">Tagging <code>FreeSpec</code> tests</a></li><li><a href="FunSpec.html#taggingTests">Tagging <code>FunSpec</code> tests</a></li><li><a href="FunSuite.html#taggingTests">Tagging <code>FunSuite</code> tests</a></li><li><a href="PropSpec.html#taggingTests">Tagging <code>PropSpec</code> tests</a></li><li><a href="Spec.html#taggingTests">Tagging <code>Spec</code> tests</a></li><li><a href="WordSpec.html#taggingTests">Tagging <code>WordSpec</code> tests</a></li></ul></div></div>
    </li><li name="org.scalatest.TagAnnotation" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TagAnnotationextendsAnnotation"></a><a id="TagAnnotation:TagAnnotation"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TagAnnotationextendsAnnotation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Annotation used to annotate annotation interfaces that define tags for ScalaTest tests." href="TagAnnotation.html"><span class="name">TagAnnotation</span></a><span class="result"> extends <span class="extype" name="java.lang.annotation.Annotation">Annotation</span></span>
      </span>
      
      <p class="shortcomment cmt">Annotation used to annotate annotation interfaces that define tags for ScalaTest tests.</p><div class="fullcomment"><div class="comment cmt"><p>Annotation used to annotate annotation interfaces that define tags for ScalaTest tests.</p><p><em>Note: This is actually an annotation defined in Java, not a Scala trait. It must be defined in Java instead of Scala so it will be accessible
at runtime. It has been inserted into Scaladoc by pretending it is a trait.</em></p><p>ScalaTest will only consider annotations that are themselves annotated with <code>TagAnnotation</code>
as tag annotations, to avoid accidentally interpreting arbitrary annotations as tags. You use <code>TagAnnotation</code>,
therefore, when you define a tag annotation (which you must do in Java). Here's an example:</p><p><pre>
package com.mycompany.myproject.testing.tags;

import java.lang.annotation.*;
import org.scalatest.TagAnnotation *

@TagAnnotation
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface DbTest {}
</pre></p><p>For more information, see the documentation for <a href="Tag.html">class <code>Tag</code></a>.</p><p></pre>
</p></div></div>
    </li><li name="org.scalatest.TestData" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TestDataextendsAnyRef"></a><a id="TestData:TestData"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TestDataextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="A bundle of information about the current test." href="TestData.html"><span class="name">TestData</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">A bundle of information about the current test.</p><div class="fullcomment"><div class="comment cmt"><p>A bundle of information about the current test.</p><p>A <code>TestData</code> object is passed to the <code>withFixture</code> methods of traits <code>Suite</code> and <code>fixture.Suite</code>
(both <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> and <a href="fixture/Suite$OneArgTest.html"><code>OneArgTest</code></a>
extend <code>TestData</code>) and to the <code>beforeEach</code> and <code>afterEach</code>
methods of trait <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>. This enables fixtures and tests to make use
of the test name and configuration objects in the config map.</p><p>In ScalaTest's event model, a test may be surrounded by &ldquo;scopes.&rdquo; Each test and scope is associated with string of text.
A test's name is a concatenation of the text of any surrounding scopes followed by the text provided with the test
itself, after each text element has been trimmed and one space inserted between each component. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.freespec
<br/><span class="stReserved">import</span> org.scalatest.FreeSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">FreeSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> - {
    <span class="stQuotedString">"when empty"</span> - {
      <span class="stQuotedString">"should have size 0"</span> in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"should produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>The above <code>FreeSpec</code> contains two tests, both nested inside the same two scopes. The outermost scope names
the subject, <code>A Set</code>. The nested scope qualifies the subject with <code>when empty</code>. Inside that
scope are the two tests. The text of the tests are:</p><ul><li><code>should have size 0</code></li><li><code>should produce NoSuchElementException when head is invoked</code></li></ul><p>Therefore, the names of these two tests are:</p><ul><li><code>A Stack when empty should have size 0</code></li><li><code>A Stack when empty should produce NoSuchElementException when head is invoked</code></li></ul><p>The <code>TestData</code> instance for the first test would contain:</p><ul><li><code>name</code>: <code>"A Stack when empty should have size 0"</code></li><li><code>scopes</code>: <code>collection.immutable.IndexedSeq("A Stack", "when empty")</code></li><li><code>text</code>: <code>"should have size 0"</code></li></ul></div></div>
    </li><li name="org.scalatest.TestRegistration" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="TestRegistrationextendsAnyRef"></a><a id="TestRegistration:TestRegistration"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TestRegistrationextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait declaring methods that can be used to register by-name test functions that have any result type." href="TestRegistration.html"><span class="name">TestRegistration</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait declaring methods that can be used to register by-name test functions that
have any result type.</p>
    </li><li name="org.scalatest.TestSuite" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TestSuiteextendsSuite"></a><a id="TestSuite:TestSuite"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TestSuiteextendsSuite" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="The base trait of ScalaTest's synchronous testing styles, which defines a withFixture lifecycle method that accepts as its parameter a test function that returns an Outcome." href="TestSuite.html"><span class="name">TestSuite</span></a><span class="result"> extends <a href="Suite.html" class="extype" name="org.scalatest.Suite">Suite</a></span>
      </span>
      
      <p class="shortcomment cmt">The base trait of ScalaTest's <em>synchronous testing styles</em>, which defines a
<code>withFixture</code> lifecycle method that accepts as its parameter a test function
that returns an <a href="Outcome.html"><code>Outcome</code></a>.</p><div class="fullcomment"><div class="comment cmt"><p>The base trait of ScalaTest's <em>synchronous testing styles</em>, which defines a
<code>withFixture</code> lifecycle method that accepts as its parameter a test function
that returns an <a href="Outcome.html"><code>Outcome</code></a>.</p><p>The <code>withFixture</code> method add by this trait has the
following signature and implementation:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>): <span class="stType">Outcome</span> = {
  test()
}
</pre></p><p>The <code>apply</code> method of test function interface,
<code>NoArgTest</code>, also returns <code>Outcome</code>:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In trait NoArgTest:</span>
<span class="stReserved">def</span> apply(): <span class="stType">Outcome</span>
</pre></p><p>Because the result of a test is an <code>Outcome</code>, when the test function returns, the test body must have determined an outcome already. It
will already be one of <a href="Succeeded$.html"><code>Succeeded</code></a>, <a href="Failed.html"><code>Failed</code></a>, <a href="Canceled.html"><code>Canceled</code></a>, or <a href="Pending$.html"></code>Pending</code></a>. This is
also true when <code>withFixture(NoArgTest)</code> returns: because the result type of <code>withFixture(NoArgTest)</code> is <code>Outcome</code>,
the test has by definition already finished execution.</p><p>The recommended way to ensure cleanup is performed after a test body finishes execution is
to use a <code>try</code>-<code>finally</code> clause.
Using <code>try</code>-<code>finally</code> will ensure that cleanup will occur whether
the test function completes abruptly by throwing a suite-aborting exception, or returns
normally yielding an <code>Outcome</code>. Note that the only situation in which a test function
will complete abruptly with an exception is if the test body throws a suite-aborting exception.
Any other exception will be caught and reported as either a <code>Failed</code>, <code>Canceled</code>,
or <code>Pending</code>.</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;. Thus, the recommended
structure of a <code>withFixture</code> implementation that performs cleanup looks like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">try</span> {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  } <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup here</span>
  }
}
</pre></p><p>If you have no cleanup to perform, you can write <code>withFixture</code> like this instead:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup here</span>
  <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
}
</pre></p><p>If you want to perform an action only for certain outcomes, you can use
a pattern match.
For example, if you want to perform an action if a test fails, you'd
match on <code>Failed</code>, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>  <span class="stLineComment">// Perform setup here</span>
<br/>  <span class="stReserved">val</span> outcome = <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
<br/>  outcome <span class="stReserved">match</span> {
    <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =>
      <span class="stLineComment">// perform action that you want to occur</span>
      <span class="stLineComment">// only if a test fails here</span>
      failed
    <span class="stReserved">case</span> other => other
  }
}
</pre></p><p>If you want to change the outcome in some way in <code>withFixture</code>, you can also
use a pattern match.
For example, if a particular exception intermittently causes a test to fail, and can
transform those failures into cancelations, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>  <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
    <span class="stReserved">case</span> <span class="stType">Failed</span>(ex: <span class="stType">ParticularException</span>) =>
      <span class="stType">Canceled</span>(<span class="stQuotedString">"Muting flicker"</span>, ex)
    <span class="stReserved">case</span> other => other
  }
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.TestSuiteMixin" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="TestSuiteMixinextendsSuiteMixin"></a><a id="TestSuiteMixin:TestSuiteMixin"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TestSuiteMixinextendsSuiteMixin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="" href="TestSuiteMixin.html"><span class="name">TestSuiteMixin</span></a><span class="result"> extends <a href="SuiteMixin.html" class="extype" name="org.scalatest.SuiteMixin">SuiteMixin</a></span>
      </span>
      
      
    </li><li name="org.scalatest.Tracker" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TrackerextendsAnyRef"></a><a id="Tracker:Tracker"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TrackerextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Class that tracks the progress of a series of Ordinals produced by invoking next and nextNewOldPair on the current Ordinal." href="Tracker.html"><span class="name">Tracker</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Class that tracks the progress of a series of <code>Ordinal</code>s produced by invoking
<code>next</code> and <code>nextNewOldPair</code> on the current <code>Ordinal</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Class that tracks the progress of a series of <code>Ordinal</code>s produced by invoking
<code>next</code> and <code>nextNewOldPair</code> on the current <code>Ordinal</code>.</p><p>Instances of this class are thread safe. Multiple threads can invoke <code>nextOrdinal</code>
and <code>nextTracker</code> concurrently. This facilitates multi-threaded tests that send
<code>infoProvided</code> reports concurrently. When using a <code>Dispatcher</code> to execute
suites in parallel, the intention is that each <code>Tracker</code> will only be used by one
thread. For example, if the optional <code>Dispatcher</code>  passed to <code>Suite</code>'s implementation
of <a href="Suite.html#lifecycle-methods"<code>runNestedSuites</code></a> is defined, that method will obtain a new <code>Tracker</code> by invoking
<code>nextTracker</code> for each nested suite it passes to the <code>Dispatcher</code>.</p></div></div>
    </li><li name="org.scalatest.TryValues" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="TryValuesextendsAnyRef"></a><a id="TryValues:TryValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TryValuesextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait that provides an implicit conversion that adds success and failure methods to scala.util.Try, enabling you to make assertions about the value of a Success or the exception of a Failure." href="TryValues.html"><span class="name">TryValues</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait that provides an implicit conversion that adds <code>success</code> and <code>failure</code> methods
to <code>scala.util.Try</code>, enabling you to make assertions about the value of a <code>Success</code> or
the exception of a <code>Failure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides an implicit conversion that adds <code>success</code> and <code>failure</code> methods
to <code>scala.util.Try</code>, enabling you to make assertions about the value of a <code>Success</code> or
the exception of a <code>Failure</code>.</p><p>The <code>success</code> method will return the <code>Try</code> on which it is invoked as a <code>Success</code> if the <code>Try</code>
actually is a <code>Success</code>, or throw <code>TestFailedException</code> if not.
The <code>failure</code> method will return the <code>Try</code> on which it is invoked as a <code>Failure</code> if the <code>Try</code>
actually is a <code>Failure</code>, or throw <code>TestFailedException</code> if not.</p><p>This construct allows you to express in one statement that an <code>Try</code> should be either a <code>Success</code>
or a <code>Failure</code> and that its value or exception, respectively,should meet some expectation. Here's an example:</p><p><pre class="stHighlighted">
try1.success.value should be &gt; <span class="stLiteral">9</span>
try2.failure.exception should have message <span class="stQuotedString">"/ by zero"</span>
</pre></p><p>Or, using assertions instead of a matchers:</p><p><pre class="stHighlighted">
assert(try1.success.value &gt; <span class="stLiteral">9</span>)
assert(try2.failure.exception.getMessage == <span class="stQuotedString">"/ by zero"</span>)
</pre></p><p>Were you to simply invoke <code>get</code> on the <code>Try</code>,
if the <code>Try</code> wasn't a <code>Success</code>, it would throw the exception contained in the <code>Failure</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> try2 = <span class="stType">Try</span> { <span class="stLiteral">1</span> / <span class="stLiteral">0</span> }
<br/>try2.get should be &lt; <span class="stLiteral">9</span> <span class="stLineComment">// try2.get throws ArithmeticException</span>
</pre></p><p>The <code>ArithmeticException</code> would cause the test to fail, but without providing a <a href="exceptions/StackDepth.html">stack depth</a> pointing
to the failing line of test code. This stack depth, provided by <a href="exceptions/TestFailedException.html"><code>TestFailedException</code></a> (and a
few other ScalaTest exceptions), makes it quicker for
users to navigate to the cause of the failure. Without <a href="TryValues.html"><code>TryValues</code></a>, to get
a stack depth exception you would need to make two statements, like this:</p><p><pre class="stHighlighted">
try2 should be a <span class="stQuotedString">'success</span> <span class="stLineComment">// throws TestFailedException</span>
try2.get should be &lt; <span class="stLiteral">9</span>
</pre></p><p>The <code>TryValues</code> trait allows you to state that more concisely:</p><p><pre class="stHighlighted">
try2.success.value should be &lt; <span class="stLiteral">9</span> <span class="stLineComment">// throws TestFailedException</span>
</pre></p></div></div>
    </li><li name="org.scalatest.WordSpec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="WordSpecextendsWordSpecLike"></a><a id="WordSpec:WordSpec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#WordSpecextendsWordSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="WordSpec.html"><span class="name">WordSpec</span></a><span class="result"> extends <a href="WordSpecLike.html" class="extype" name="org.scalatest.WordSpecLike">WordSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt">Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
For teams coming from specs or specs2, <code>WordSpec</code> will feel familiar, and is often the most natural way to port specsN tests to
ScalaTest. <code>WordSpec</code> is very prescriptive in how text must be written, so a good fit for teams who want a high degree of discipline
enforced upon their specification text.
</td></tr></table></p><p>Class <code>WordSpec</code> is so named because your specification text is structured by placing words after strings.
Here's an example <code>WordSpec</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"have size 0"</span> in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>In a <code>WordSpec</code> you write a one (or more) sentence specification for each bit of behavior you wish to
specify and test. Each specification sentence has a
&quot;subject,&quot; which is sometimes called the <em>system under test</em> (or SUT). The
subject is entity being specified and tested and also serves as the subject of the sentences you write for each test. A subject
can be followed by one of three verbs, <code>should</code>, <code>must</code>, or <code>can</code>, and a block. Here are some
examples:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> should {
  <span class="stLineComment">// ...</span>
}
<span class="stQuotedString">"An Account"</span> must {
  <span class="stLineComment">// ...</span>
}
<span class="stQuotedString">"A ShippingManifest"</span> can {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>You can describe a subject in varying situations by using a <code>when</code> clause. A <code>when</code> clause
follows the subject and precedes a block. In the block after the <code>when</code>, you place strings that describe a situation or a state
the subject may be in using a string, each followed by a verb. Here's an example:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> when {
  <span class="stQuotedString">"empty"</span> should {
    <span class="stLineComment">// ...</span>
  }
  <span class="stQuotedString">"non-empty"</span> should {
    <span class="stLineComment">// ...</span>
  }
  <span class="stQuotedString">"full"</span> should {
    <span class="stLineComment">// ...</span>
  }
}
</pre></p><p>When you are ready to finish a sentence, you write a string followed by <code>in</code> and a block that
contains the code of the test. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">StackSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
  <span class="stQuotedString">"A Stack"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"be empty"</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"complain on peek"</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"complain on pop"</span> in {
        <span class="stLineComment">// ...</span>
      }
    }
    <span class="stQuotedString">"full"</span> should {
      <span class="stQuotedString">"be full"</span> in {
        <span class="stLineComment">// ...</span>
      }
      <span class="stQuotedString">"complain on push"</span> in {
        <span class="stLineComment">// ...</span>
      }
    }
  }
}
</pre></p><p>Running the above <code>StackSpec</code> in the interpreter would yield:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new StackSpec)
<span class="stGreen">StackSpec:
A Stack
  when empty
&nbsp; - should be empty
&nbsp; - should complain on peek
&nbsp; - should complain on pop
&nbsp; when full
&nbsp; - should be full
&nbsp; - should complain on push</span>
</pre></p><p>Note that the output does not exactly match the input in an effort to maximize readability.
Although the <code>WordSpec</code> code is nested, which can help you eliminate any repeated phrases
in the specification portion of your code, the output printed moves <code>when</code> and <code>should</code>
down to the beginning of the next line.</p><p>Sometimes you may wish to eliminate repeated phrases inside the block following a <code>verb</code>. Here's an example
in which the phrase &quot;provide an and/or operator, which&quot; is repeated:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">AndOrSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"The ScalaTest Matchers DSL"</span> should {
    <span class="stQuotedString">"provide an and operator, which returns silently when evaluating true and true"</span> in {}
    <span class="stQuotedString">"provide an and operator, which throws a TestFailedException when evaluating true and false"</span> in {}
    <span class="stQuotedString">"provide an and operator, which throws a TestFailedException when evaluating false and true"</span> in {}
    <span class="stQuotedString">"provide an and operator, which throws a TestFailedException when evaluating false and false"</span> in {}
    <span class="stQuotedString">"provide an or operator, which returns silently when evaluating true or true"</span> in {}
    <span class="stQuotedString">"provide an or operator, which returns silently when evaluating true or false"</span> in {}
    <span class="stQuotedString">"provide an or operator, which returns silently when evaluating false or true"</span> in {}
    <span class="stQuotedString">"provide an or operator, which throws a TestFailedException when evaluating false or false"</span> in {}
  }
}
</pre></p><p>In such situations you can place <code>which</code> clauses inside the verb clause, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">AndOrSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"The ScalaTest Matchers DSL"</span> should {
    <span class="stQuotedString">"provide an and operator,"</span> which {
      <span class="stQuotedString">"returns silently when evaluating true and true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating true and false"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating false and true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating false and false"</span> in {}
    }
    <span class="stQuotedString">"provide an or operator,"</span> which {
      <span class="stQuotedString">"returns silently when evaluating true or true"</span> in {}
      <span class="stQuotedString">"returns silently when evaluating true or false"</span> in {}
      <span class="stQuotedString">"returns silently when evaluating false or true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating false or false"</span> in {}
    }
  }
}
</pre></p><p>Running the above <code>AndOrSpec</code> in the interpreter would yield:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AndOrSpec)
<span class="stGreen">AndOrSpec:
The ScalaTest Matchers DSL
  should provide an and operator, which
&nbsp; - returns silently when evaluating true and true
&nbsp; - throws a TestFailedException when evaluating true and false
&nbsp; - throws a TestFailedException when evaluating false and true
&nbsp; - throws a TestFailedException when evaluating false and false
&nbsp; should provide an or operator, which
&nbsp; - returns silently when evaluating true or true
&nbsp; - returns silently when evaluating true or false
&nbsp; - returns silently when evaluating false or true
&nbsp; - throws a TestFailedException when evaluating false or false</span>
</pre></p><p>Note that unlike <code>when</code> and <code>should</code>/<code>must</code>/<code>can</code>, a <code>which</code> appears
in the output right where you put it in the input, at the end of the line, to maximize readability.</p><p><a name="AfterWords">If</a> a word or phrase is repeated at the beginning of each string contained in a block, you can eliminate
that repetition by using an <em>after word</em>. An after word is a word or phrase that you can place
after <code>when</code>, a verb, or
<code>which</code>. For example, in the previous <code>WordSpec</code>, the word &quot;provide&quot; is repeated
at the beginning of each string inside the <code>should</code> block. You can factor out this duplication
like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">AndOrSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>   <span class="stReserved">def</span> provide = afterWord(<span class="stQuotedString">"provide"</span>)
<br/>  <span class="stQuotedString">"The ScalaTest Matchers DSL"</span> should provide {
    <span class="stQuotedString">"an and operator,"</span> which {
      <span class="stQuotedString">"returns silently when evaluating true and true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating true and false"</span> in {}
      <span class="stQuotedString">"that throws a TestFailedException when evaluating false and true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating false and false"</span> in {}
    }
    <span class="stQuotedString">"an or operator,"</span> which {
      <span class="stQuotedString">"returns silently when evaluating true or true"</span> in {}
      <span class="stQuotedString">"returns silently when evaluating true or false"</span> in {}
      <span class="stQuotedString">"returns silently when evaluating false or true"</span> in {}
      <span class="stQuotedString">"throws a TestFailedException when evaluating false or false"</span> in {}
    }
  }
}
</pre></p><p> Running the above version of <code>AndOrSpec</code> with the <code>provide</code> after word in the interpreter would give you:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new AndOrSpec)
<span class="stGreen">AndOrSpec:
The ScalaTest Matchers DSL
  should provide
    an and operator, which
&nbsp;   - returns silently when evaluating true and true
&nbsp;   - throws a TestFailedException when evaluating true and false
&nbsp;   - that throws a TestFailedException when evaluating false and true
&nbsp;   - throws a TestFailedException when evaluating false and false
&nbsp;   an or operator, which
&nbsp;   - returns silently when evaluating true or true
&nbsp;   - returns silently when evaluating true or false
&nbsp;   - returns silently when evaluating false or true
&nbsp;   - throws a TestFailedException when evaluating false or false</span>
</pre></p><p>Once you've defined an after word, you can place it after <code>when</code>, a verb
(<code>should</code>, <code>must</code>, or <code>can</code>), or
<code>which</code>. (You can't place one after <code>in</code> or <code>is</code>, the
words that introduce a test.) Here's an example that has after words used in all three
places:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">ScalaTestGUISpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stReserved">def</span> theUser = afterWord(<span class="stQuotedString">"the user"</span>)
  <span class="stReserved">def</span> display = afterWord(<span class="stQuotedString">"display"</span>)
  <span class="stReserved">def</span> is = afterWord(<span class="stQuotedString">"is"</span>)
<br/>  <span class="stQuotedString">"The ScalaTest GUI"</span> when theUser {
    <span class="stQuotedString">"clicks on an event report in the list box"</span> should display {
      <span class="stQuotedString">"a blue background in the clicked-on row in the list box"</span> in {}
      <span class="stQuotedString">"the details for the event in the details area"</span> in {}
      <span class="stQuotedString">"a rerun button,"</span> which is {
        <span class="stQuotedString">"enabled if the clicked-on event is rerunnable"</span> in {}
        <span class="stQuotedString">"disabled if the clicked-on event is not rerunnable"</span> in {}
      }
    }
  }
}
</pre></p><p>Running the previous <code>WordSpec</code> in the Scala interpreter would yield:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ScalaTestGUISpec)
<span class="stGreen">ScalaTestGUISpec:
The ScalaTest GUI
  when the user clicks on an event report in the list box
    should display
&nbsp;   - a blue background in the clicked-on row in the list box
&nbsp;   - the details for the event in the details area
&nbsp;     a rerun button, which is
&nbsp;     - enabled if the clicked-on event is rerunnable
&nbsp;     - disabled if the clicked-on event is not rerunnable</span>
</pre></p><p>In case when you need to use different verb for a same subject, you can use <code>it</code> or <code>they</code> shorthand to avoid subject duplication:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> when {
  <span class="stLineComment">// ...</span>
}
<br/>it should {
  <span class="stLineComment">// ...</span>
}
</pre></p><p>A <code>WordSpec</code>'s lifecycle has two phases: the <em>registration</em> phase and the
<em>ready</em> phase. It starts in registration phase and enters ready phase the first time
<code>run</code> is called on it. It then remains in ready phase for the remainder of its lifetime.</p><p>Tests can only be registered while the <code>WordSpec</code> is
in its registration phase. Any attempt to register a test after the <code>WordSpec</code> has
entered its ready phase, <em>i.e.</em>, after <code>run</code> has been invoked on the <code>WordSpec</code>,
will be met with a thrown <a href="exceptions/TestRegistrationClosedException.html"><code>TestRegistrationClosedException</code></a>. The recommended style
of using <code>WordSpec</code> is to register tests during object construction as is done in all
the examples shown here. If you keep to the recommended style, you should never see a
<code>TestRegistrationClosedException</code>.</p><p><em>Note: Class <code>WordSpec</code> is in part inspired by class <code>org.specs.Specification</code>, designed by
Eric Torreborre for the <a href="http://code.google.com/p/specs/" target="_blank">specs framework</a>.</em></p><p><a name="ignoredTests"></a></p><h4> Ignored tests </h4><p>To support the common use case of temporarily disabling a test, with the
good intention of resurrecting the test at a later time, <code>WordSpec</code> adds a method
<code>ignore</code> to strings that can be used instead of <code>in</code> to register a test. For example, to temporarily
disable the test with the name <code>"A Stack should pop values in last-in-first-out order"</code>, just
change &ldquo;<code>in</code>&rdquo; into &#8220;<code>ignore</code>,&#8221; like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.ignore
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"have size 0"</span> ignore {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run only the second test and report that the first test was ignored:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stGreen">  - should should produce NoSuchElementException when head is invoked</span>
</pre></p><p>If you wish to temporarily ignore an entire suite of tests, you can (on the JVM, not Scala.js) annotate the test class with <code>@Ignore</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.ignoreall
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<span class="stReserved">import</span> org.scalatest.Ignore
<br/>@<span class="stType">Ignore</span>
<span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"have size 0"</span> in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>When you mark a test class with a tag annotation, ScalaTest will mark each test defined in that class with that tag.
Thus, marking the <code>SetSpec</code> in the above example with the <code>@Ignore</code> tag annotation means that both tests
in the class will be ignored. If you run the above <code>SetSpec</code> in the Scala interpreter, you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A Set
  when empty</span>
<span class="stYellow">  - should have size 0 !!! IGNORED !!!</span>
<span class="stYellow">  - should produce NoSuchElementException when head is invoked !!! IGNORED !!!</span>
</pre></p><p>Note that marking a test class as ignored won't prevent it from being discovered by ScalaTest. Ignored classes
will be discovered and run, and all their tests will be reported as ignored. This is intended to keep the ignored
class visible, to encourage the developers to eventually fix and &ldquo;un-ignore&rdquo; it. If you want to
prevent a class from being discovered at all (on the JVM, not Scala.js), use the <a href="DoNotDiscover.html"><code>DoNotDiscover</code></a> annotation instead.</p><p><a name="informers"></a></p><h4> Informers </h4><p>One of the parameters to <code>WordSpec</code>'s <code>run</code> method is a <a href="Reporter.html"><code>Reporter</code></a>, which
will collect and report information about the running suite of tests.
Information about suites and tests that were run, whether tests succeeded or failed,
and tests that were ignored will be passed to the <code>Reporter</code> as the suite runs.
Most often the reporting done by default by <code>WordSpec</code>'s methods will be sufficient, but
occasionally you may wish to provide custom information to the <code>Reporter</code> from a test.
For this purpose, an <a href="Informer.html"><code>Informer</code></a> that will forward information to the current <code>Reporter</code>
is provided via the <code>info</code> parameterless method.
You can pass the extra information to the <code>Informer</code> via its <code>apply</code> method.
The <code>Informer</code> will then pass the information to the <code>Reporter</code> via an <a href="events/InfoProvided.html"><code>InfoProvided</code></a> event.</p><p>One use case for the <code>Informer</code> is to pass more information about a specification to the reporter. For example,
the <a href="GivenWhenThen.html"><code>GivenWhenThen</code></a> trait provides methods that use the implicit <code>info</code> provided by <code>WordSpec</code>
to pass such information to the reporter. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.info
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      info(<span class="stQuotedString">"That's all folks!"</span>)
    }
  }
}
</pre></p><p>If you run this <code>WordSpec</code> from the interpreter, you will see the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">A mutable Set
- should allow an element to be added
  + Given an empty mutable Set
  + When an element is added
  + Then the Set should have size 1
  + And the Set should contain the added element
  + That's all folks!</span>
</pre></p><p><a name="documenters"></a></p><h4> Documenters </h4><p><code>WordSpec</code> also provides a <code>markup</code> method that returns a <a href="Documenter.html"><code>Documenter</code></a>, which allows you to send
to the <code>Reporter</code> text formatted in <a href="http://daringfireball.net/projects/markdown/" target="_blank">Markdown syntax</a>.
You can pass the extra information to the <code>Documenter</code> via its <code>apply</code> method.
The <code>Documenter</code> will then pass the information to the <code>Reporter</code> via an <a href="events/MarkupProvided.html"><code>MarkupProvided</code></a> event.</p><p>Here's an example <code>WordSpec</code> that uses <code>markup</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.markup
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">GivenWhenThen</span> {
<br/>  markup { <span class="stQuotedString">"""</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">Mutable Set</span>
<span class="stQuotedString">&mdash;&mdash;&mdash;--</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">A set is a collection that contains no duplicate elements.</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">To implement a concrete mutable set, you need to provide implementations</span>
<span class="stQuotedString">of the following methods:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def contains(elem: A): Boolean</span>
    <span class="stQuotedString">def iterator: Iterator[A]</span>
    <span class="stQuotedString">def += (elem: A): this.type</span>
    <span class="stQuotedString">def -= (elem: A): this.type</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">If you wish that methods like `take`,</span>
<span class="stQuotedString">`drop`, `filter` return the same kind of set,</span>
<span class="stQuotedString">you should also override:</span>
<span class="stQuotedString"></span>
    <span class="stQuotedString">def empty: This</span>
<span class="stQuotedString"></span>
<span class="stQuotedString">It is also good idea to override methods `foreach` and</span>
<span class="stQuotedString">`size` for efficiency.</span>
<span class="stQuotedString"></span>
  <span class="stQuotedString">"""</span> }
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
      <span class="stType">Given</span>(<span class="stQuotedString">"an empty mutable Set"</span>)
      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
<br/>      <span class="stType">When</span>(<span class="stQuotedString">"an element is added"</span>)
      set += <span class="stQuotedString">"clarity"</span>
<br/>      <span class="stType">Then</span>(<span class="stQuotedString">"the Set should have size 1"</span>)
      assert(set.size === <span class="stLiteral">1</span>)
<br/>      <span class="stType">And</span>(<span class="stQuotedString">"the Set should contain the added element"</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
<br/>      markup(<span class="stQuotedString">"This test finished with a **bold** statement!"</span>)
    }
  }
}
</pre></p><p>Although all of ScalaTest's built-in reporters will display the markup text in some form,
the HTML reporter will format the markup information into HTML. Thus, the main purpose of <code>markup</code> is to
add nicely formatted text to HTML reports. Here's what the above <code>SetSpec</code> would look like in the HTML reporter:</p><p><img class="stScreenShot" src="../../lib/wordSpec.gif"></p><p><a name="notifiersAlerters"></a></p><h4> Notifiers and alerters </h4><p>ScalaTest records text passed to <code>info</code> and <code>markup</code> during tests, and sends the recorded text in the <code>recordedEvents</code> field of
test completion events like <code>TestSucceeded</code> and <code>TestFailed</code>. This allows string reporters (like the standard out reporter) to show
<code>info</code> and <code>markup</code> text <em>after</em> the test name in a color determined by the outcome of the test. For example, if the test fails, string
reporters will show the <code>info</code> and <code>markup</code> text in red. If a test succeeds, string reporters will show the <code>info</code>
and <code>markup</code> text in green. While this approach helps the readability of reports, it means that you can't use <code>info</code> to get status
updates from long running tests.</p><p>To get immediate (<em>i.e.</em>, non-recorded) notifications from tests, you can use <code>note</code> (a <a href="Notifier.html"><code>Notifier</code></a>) and <code>alert</code>
(an <a href="Alerter.html"><code>Alerter</code></a>). Here's an example showing the differences:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.note
<br/><span class="stReserved">import</span> collection.mutable
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A mutable Set"</span> should {
    <span class="stQuotedString">"allow an element to be added"</span> in {
<br/>      info(<span class="stQuotedString">"info is recorded"</span>)
      markup(<span class="stQuotedString">"markup is *also* recorded"</span>)
      note(<span class="stQuotedString">"notes are sent immediately"</span>)
      alert(<span class="stQuotedString">"alerts are also sent immediately"</span>)
<br/>      <span class="stReserved">val</span> set = mutable.Set.empty[<span class="stType">String</span>]
      set += <span class="stQuotedString">"clarity"</span>
      assert(set.size === <span class="stLiteral">1</span>)
      assert(set.contains(<span class="stQuotedString">"clarity"</span>))
    }
  }
}
</pre></p><p>Because <code>note</code> and <code>alert</code> information is sent immediately, it will appear <em>before</em> the test name in string reporters, and its color will
be unrelated to the ultimate outcome of the test: <code>note</code> text will always appear in green, <code>alert</code> text will always appear in yellow.
Here's an example:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
<span class="stGreen">SetSpec:
A mutable Set
  + notes are sent immediately</span>
  <span class="stYellow">+ alerts are also sent immediately</span>
<span class="stGreen">- should allow an element to be added
  + info is recorded
  + markup is *also* recorded</span>
</pre></p><p>Another example is <a href="tools/Runner$.html#slowpokeNotifications">slowpoke notifications</a>.
If you find a test is taking a long time to complete, but you're not sure which test, you can enable
slowpoke notifications. ScalaTest will use an <code>Alerter</code> to fire an event whenever a test has been running
longer than a specified amount of time.</p><p>In summary, use <code>info</code> and <code>markup</code> for text that should form part of the specification output. Use
<code>note</code> and <code>alert</code> to send status notifications. (Because the HTML reporter is intended to produce a
readable, printable specification, <code>info</code> and <code>markup</code> text will appear in the HTML report, but
<code>note</code> and <code>alert</code> text will not.)</p><p><a name="pendingTests"></a></p><h4> Pending tests </h4><p>A <em>pending test</em> is one that has been given a name but is not yet implemented. The purpose of
pending tests is to facilitate a style of testing in which documentation of behavior is sketched
out before tests are written to verify that behavior (and often, before the behavior of
the system being tested is itself implemented). Such sketches form a kind of specification of
what tests and functionality to implement later.</p><p>To support this style of testing, a test can be given a name that specifies one
bit of behavior required by the system being tested. The test can also include some code that
sends more information about the behavior to the reporter when the tests run. At the end of the test,
it can call method <code>pending</code>, which will cause it to complete abruptly with <a href="exceptions/TestPendingException.html"><code>TestPendingException</code></a>.</p><p>Because tests in ScalaTest can be designated as pending with <code>TestPendingException</code>, both the test name and any information
sent to the reporter when running the test can appear in the report of a test run. (In other words,
the code of a pending test is executed just like any other test.) However, because the test completes abruptly
with <code>TestPendingException</code>, the test will be reported as pending, to indicate
the actual test, and possibly the functionality it is intended to test, has not yet been implemented.
You can mark tests as pending in a <code>WordSpec</code> like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.pending
<br/><span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"have size 0"</span> in (pending)
<br/>      <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>If you run this version of <code>SetSpec</code> with:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SetSpec)
</pre></p><p>It will run both tests but report that <code>should have size 0</code> is pending. You'll see:</p><p><pre class="stREPL">
<span class="stGreen">A Set</span>
<span class="stGreen">  when empty</span>
<span class="stYellow">  - should have size 0 (pending)</span>
<span class="stGreen">  - should produce NoSuchElementException when head is invoked</span>
</pre></p><p>One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.</p><p>One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
test that throws <code>TestPendingException</code> (which is what calling the <code>pending</code> method does). Thus
the body of pending tests are executed up until they throw <code>TestPendingException</code>. The reason for this difference
is that it enables your unfinished test to send <code>InfoProvided</code> messages to the reporter before it completes
abruptly with <code>TestPendingException</code>, as shown in the previous example on <code>Informer</code>s
that used the <code>GivenWhenThen</code> trait. For example, the following snippet in a <code>WordSpec</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"The Scala language"</span> should {
   <span class="stQuotedString">"add correctly"</span> in {
     <span class="stType">Given</span>(<span class="stQuotedString">"two integers"</span>)
     <span class="stType">When</span>(<span class="stQuotedString">"they are added"</span>)
     <span class="stType">Then</span>(<span class="stQuotedString">"the result is the sum of the two numbers"</span>)
     pending
   }
   <span class="stLineComment">// ...</span>
</pre></p><p>Would yield the following output when run in the interpreter:</p><p><pre class="stREPL">
<span class="stGreen">The Scala language</span>
<span class="stYellow">- should add correctly (pending)
  + Given two integers
  + When they are added
  + Then the result is the sum of the two numbers</span>
</pre></p><p><a name="taggingTests"></a></p><h4> Tagging tests </h4><p>A <code>WordSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
As with any suite, when executing a <code>WordSpec</code>, groups of tests can
optionally be included and/or excluded. To tag a <code>WordSpec</code>'s tests,
you pass objects that extend class <code>org.scalatest.Tag</code> to methods
that register tests. Class <code>Tag</code> takes one parameter, a string name.  If you have
created tag annotation interfaces as described in the <a href="Tag.html"><code>Tag</code> documentation</a>, then you
will probably want to use tag names on your test functions that match. To do so, simply
pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
defined a tag annotation interface with fully qualified name,
<code>com.mycompany.tags.DbTest</code>, then you could
create a matching tag for <code>WordSpec</code>s like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.tagging
<br/><span class="stReserved">import</span> org.scalatest.Tag
<br/><span class="stReserved">object</span> <span class="stType">DbTest</span> <span class="stReserved">extends</span> <span class="stType">Tag</span>(<span class="stQuotedString">"com.mycompany.tags.DbTest"</span>)
</pre></p><p>Given these definitions, you could place <code>WordSpec</code> tests into groups with tags like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.WordSpec
<span class="stReserved">import</span> org.scalatest.tagobjects.Slow
<br/><span class="stReserved">class</span> <span class="stType">SetSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stQuotedString">"A Set"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"have size 0"</span> taggedAs(<span class="stType">Slow</span>) in {
        assert(Set.empty.size === <span class="stLiteral">0</span>)
      }
<br/>      <span class="stQuotedString">"produce NoSuchElementException when head is invoked"</span> taggedAs(<span class="stType">Slow</span>, <span class="stType">DbTest</span>) in {
        assertThrows[<span class="stType">NoSuchElementException</span>] {
          Set.empty.head
        }
      }
    }
  }
}
</pre></p><p>This code marks both tests with the <code>org.scalatest.tags.Slow</code> tag,
and the second test with the <code>com.mycompany.tags.DbTest</code> tag.</p><p>The <code>run</code> method takes a <a href="Filter.html"><code>Filter</code></a>, whose constructor takes an optional
<code>Set[String]</code> called <code>tagsToInclude</code> and a <code>Set[String]</code> called
<code>tagsToExclude</code>. If <code>tagsToInclude</code> is <code>None</code>, all tests will be run
except those those belonging to tags listed in the
<code>tagsToExclude</code> <code>Set</code>. If <code>tagsToInclude</code> is defined, only tests
belonging to tags mentioned in the <code>tagsToInclude</code> set, and not mentioned in <code>tagsToExclude</code>,
will be run.</p><p>It is recommended, though not required, that you create a corresponding tag annotation when you
create a <code>Tag</code> object. A tag annotation (on the JVM, not Scala.js) allows you to tag all the tests of a <code>WordSpec</code> in
one stroke by annotating the class. For more information and examples, see the
<a href="Tag.html">documentation for class <code>Tag</code></a>. On Scala.js, to tag all tests of a suite, you'll need to
tag each test individually at the test site.</p><p><a name="sharedFixtures"></a></p><h4> Shared fixtures </h4><p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p><p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul><p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p><p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:

 <dl>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">Different tests need different fixtures (refactor using Scala instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</dd>
 <dd style="display: list-item; list-style-type: disc; margin-left: 1.2em;">You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</dd>
 </dl>
 </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr>

<tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

<tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr>

</table></p><p><a name="getFixtureMethods"></a></p><h6> Calling get-fixture methods </h6><p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or an holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.getfixture
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stReserved">class</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br/>  <span class="stReserved">def</span> fixture = <span class="stReserved">new</span> <span class="stType">Fixture</span>
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(f.buffer.isEmpty)
      f.buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      <span class="stReserved">val</span> f = fixture
      f.builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(f.builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(f.buffer.isEmpty)
    }
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p><p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p><p><a name="fixtureContextObjects"></a></p><h6> Instantiating fixture-context objects  </h6><p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p><p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.fixturecontext
<br/><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.WordSpec
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>)
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stLineComment">// This test needs the StringBuilder fixture</span>
    <span class="stQuotedString">"be productive"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
      builder.append(<span class="stQuotedString">"productive!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is productive!"</span>)
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> should {
    <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
    <span class="stQuotedString">"be readable"</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
      buffer += (<span class="stQuotedString">"readable!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"readable!"</span>))
    }
<br/>    <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
    <span class="stQuotedString">"be clear and concise"</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
      builder.append(<span class="stQuotedString">"clear!"</span>)
      buffer += (<span class="stQuotedString">"concise!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">"ScalaTest"</span>, <span class="stQuotedString">"is"</span>, <span class="stQuotedString">"concise!"</span>))
    }
  }
}
</pre></p><p><a name="withFixtureNoArgTest"></a></p><h6> Overriding <code>withFixture(NoArgTest)</code> </h6><p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="Suite.html#lifecyle-methods"><code>Suite</code></a>.</p><p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href="Failed.html" class="extype" name="org.scalatest.Failed"><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p><p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. Instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p><p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.noargtest
<br/><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br/>    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">"."</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">"Dir snapshot: "</span> + fileNames.mkString(<span class="stQuotedString">", "</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br/>  <span class="stQuotedString">"This test"</span> should {
    <span class="stQuotedString">"succeed"</span> in {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
    }
<br/>    <span class="stQuotedString">"fail"</span> in {
      assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
    }
  }
}
</pre></p><p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new ExampleSuite)
<span class="stGreen">ExampleSuite:
This test
- should succeed</span>
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (<console>:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p><p>Note that the <a href="Suite$NoArgTest.html"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="ConfigMap.html">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p><p><a name="loanFixtureMethods"></a></p><h6> Calling loan-fixture methods </h6><p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p><p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br/><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> {
<br/>  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stLineComment">// This test needs the file fixture</span>
    <span class="stQuotedString">"be productive"</span> in withFile { (file, writer) =&gt;
      writer.write(<span class="stQuotedString">"productive!"</span>)
      writer.flush()
      assert(file.length === <span class="stLiteral">24</span>)
    }
  }
<br/>  <span class="stQuotedString">"Test code"</span> should {
    <span class="stLineComment">// This test needs the database fixture</span>
    <span class="stQuotedString">"be readable"</span> in withDatabase { db =&gt;
      db.append(<span class="stQuotedString">"readable!"</span>)
      assert(db.toString === <span class="stQuotedString">"ScalaTest is readable!"</span>)
    }
<br/>    <span class="stLineComment">// This test needs both the file and the database</span>
    <span class="stQuotedString">"be clear and concise"</span> in withDatabase { db =&gt;
      withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
        db.append(<span class="stQuotedString">"clear!"</span>)
        writer.write(<span class="stQuotedString">"concise!"</span>)
        writer.flush()
        assert(db.toString === <span class="stQuotedString">"ScalaTest is clear!"</span>)
        assert(file.length === <span class="stLiteral">21</span>)
      }
    }
  }
}
</pre></p><p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p><p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p><p><a name="withFixtureOneArgTest"></a></p><h6> Overriding <code>withFixture(OneArgTest)</code> </h6><p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.WordSpec</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.WordSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p><p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. Instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p><p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p><p>Here's a complete example:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.oneargtest
<br/><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.WordSpec</span> {
<br/>  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br/>  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">"hello"</span>, <span class="stQuotedString">"world"</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br/>    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">"ScalaTest is "</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// "loan" the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"easy!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">18</span>)
    }
<br/>    <span class="stQuotedString">"be fun"</span> in { f =&gt;
      f.writer.write(<span class="stQuotedString">"fun!"</span>)
      f.writer.flush()
      assert(f.file.length === <span class="stLiteral">17</span>)
    }
  }
}
</pre></p><p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="fixture/WordSpec.html">documentation for <code>fixture.WordSpec</code></a>.</p><p><a name="beforeAndAfter"></a></p><h6> Mixing in <code>BeforeAndAfter</code> </h6><p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="BeforeAndAfter.html"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.beforeandafter
<br/><span class="stReserved">import</span> org.scalatest.WordSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  before {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
  }
<br/>  after {
    builder.clear()
    buffer.clear()
  }
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
    }
  }
}
</pre></p><p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class (on the JVM, not Scala.js) unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href="OneInstancePerTest.html"><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p><p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p><p><a name="composingFixtures"></a></p><h4> Composing fixtures by stacking traits </h4><p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.composingwithfixture
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">TestSuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">TestSuite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="BeforeAndAfterEach.html"><code>BeforeAndAfterEach</code></a>
and/or <a href="BeforeAndAfterAll.html"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.wordspec.composingbeforeandaftereach
<br/><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br/><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">"ScalaTest is "</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br/><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br/>  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br/><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br/>  <span class="stQuotedString">"Testing"</span> should {
    <span class="stQuotedString">"be easy"</span> in {
      builder.append(<span class="stQuotedString">"easy!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is easy!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"sweet"</span>
    }
<br/>    <span class="stQuotedString">"be fun"</span> in {
      builder.append(<span class="stQuotedString">"fun!"</span>)
      assert(builder.toString === <span class="stQuotedString">"ScalaTest is fun!"</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">"clear"</span>
    }
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p><p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a <a href="events/SuiteAborted.html"><code>SuiteAborted</code></a> event.</p><p><a name="sharedTests"></a></p><h4> Shared tests </h4><p>Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
by different fixture objects.  To accomplish this in a <code>WordSpec</code>, you first place shared tests in <em>behavior functions</em>.
These behavior functions will be invoked during the construction phase of any <code>WordSpec</code> that uses them, so that the tests they
contain will be registered as tests in that <code>WordSpec</code>.  For example, given this stack class:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> scala.collection.mutable.ListBuffer
<br/><span class="stReserved">class</span> <span class="stType">Stack[T]</span> {
<br/>  <span class="stReserved">val</span> MAX = <span class="stLiteral">10</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ListBuffer[T]</span>
<br/>  <span class="stReserved">def</span> push(o: T) {
    <span class="stReserved">if</span> (!full)
      buf.prepend(o)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't push onto a full stack"</span>)
  }
<br/>  <span class="stReserved">def</span> pop(): T = {
    <span class="stReserved">if</span> (!empty)
      buf.remove(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> peek: T = {
    <span class="stReserved">if</span> (!empty)
      buf(<span class="stLiteral">0</span>)
    <span class="stReserved">else</span>
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">IllegalStateException</span>(<span class="stQuotedString">"can't pop an empty stack"</span>)
  }
<br/>  <span class="stReserved">def</span> full: <span class="stType">Boolean</span> = buf.size == MAX
  <span class="stReserved">def</span> empty: <span class="stType">Boolean</span> = buf.size == <span class="stLiteral">0</span>
  <span class="stReserved">def</span> size = buf.size
<br/>  <span class="stReserved">override</span> <span class="stReserved">def</span> toString = buf.mkString(<span class="stQuotedString">"Stack("</span>, <span class="stQuotedString">", "</span>, <span class="stQuotedString">")"</span>)
}
</pre></p><p>You may want to test the <code>Stack</code> class in different states: empty, full, with one item, with one item less than capacity,
<em>etc</em>. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
stack fixture to use when running the tests. So in your <code>WordSpec</code> for stack, you'd invoke the
behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures. You
can define a behavior function that encapsulates these shared tests inside the <code>WordSpec</code> that uses them. If they are shared
between different <code>WordSpec</code>s, however, you could also define them in a separate trait that is mixed into each <code>WordSpec</code>
that uses them.</p><p><a name="StackBehaviors">For</a> example, here the <code>nonEmptyStack</code> behavior function (in this case, a behavior <em>method</em>) is
defined in a trait along with another method containing shared tests for non-full stacks:</p><p><pre class="stHighlighted">
<span class="stReserved">trait</span> <span class="stType">StackBehaviors</span> { <span class="stReserved">this</span>: <span class="stType">WordSpec</span> =&gt;
<br/>  <span class="stReserved">def</span> nonEmptyStack(newStack: =&gt; <span class="stType">Stack[Int]</span>, lastItemAdded: <span class="stType">Int</span>) {
<br/>    <span class="stQuotedString">"be non-empty"</span> in {
      assert(!newStack.empty)
    }
<br/>    <span class="stQuotedString">"return the top item on peek"</span> in {
      assert(newStack.peek === lastItemAdded)
    }
<br/>    <span class="stQuotedString">"not remove the top item on peek"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.peek === lastItemAdded)
      assert(stack.size === size)
    }
<br/>    <span class="stQuotedString">"remove the top item on pop"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      assert(stack.pop === lastItemAdded)
      assert(stack.size === size - <span class="stLiteral">1</span>)
    }
  }
<br/>  <span class="stReserved">def</span> nonFullStack(newStack: =&gt; <span class="stType">Stack[Int]</span>) {
<br/>    <span class="stQuotedString">"not be full"</span> in {
      assert(!newStack.full)
    }
<br/>    <span class="stQuotedString">"add to the top on push"</span> in {
      <span class="stReserved">val</span> stack = newStack
      <span class="stReserved">val</span> size = stack.size
      stack.push(<span class="stLiteral">7</span>)
      assert(stack.size === size + <span class="stLiteral">1</span>)
      assert(stack.peek === <span class="stLiteral">7</span>)
    }
  }
}
</pre></p><p>Given these behavior functions, you could invoke them directly, but <code>WordSpec</code> offers a DSL for the purpose,
which looks like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
behave like nonFullStack(stackWithOneItem)
</pre></p><p>If you prefer to use an imperative style to change fixtures, for example by mixing in <code>BeforeAndAfterEach</code> and
reassigning a <code>stack</code> <code>var</code> in <code>beforeEach</code>, you could write your behavior functions
in the context of that <code>var</code>, which means you wouldn't need to pass in the stack fixture because it would be
in scope already inside the behavior function. In that case, your code would look like this:</p><p><pre class="stHighlighted">
behave like nonEmptyStack <span class="stLineComment">// assuming lastValuePushed is also in scope inside nonEmptyStack</span>
behave like nonFullStack
</pre></p><p>The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">SharedTestExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">WordSpec</span> <span class="stReserved">with</span> <span class="stType">StackBehaviors</span> {
<br/>  <span class="stLineComment">// Stack fixture creation methods</span>
  <span class="stReserved">def</span> emptyStack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
<br/>  <span class="stReserved">def</span> fullStack = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i <- <span class="stLiteral">0</span> until stack.MAX)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItem = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    stack.push(<span class="stLiteral">9</span>)
    stack
  }
<br/>  <span class="stReserved">def</span> stackWithOneItemLessThanCapacity = {
    <span class="stReserved">val</span> stack = <span class="stReserved">new</span> <span class="stType">Stack[Int]</span>
    <span class="stReserved">for</span> (i &lt;- <span class="stLiteral">1</span> to <span class="stLiteral">9</span>)
      stack.push(i)
    stack
  }
<br/>  <span class="stReserved">val</span> lastValuePushed = <span class="stLiteral">9</span>
<br/>  <span class="stQuotedString">"A Stack"</span> when {
    <span class="stQuotedString">"empty"</span> should {
      <span class="stQuotedString">"be empty"</span> in {
        assert(emptyStack.empty)
      }
<br/>      <span class="stQuotedString">"complain on peek"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.peek
        }
      }
<br/>      <span class="stQuotedString">"complain on pop"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          emptyStack.pop
        }
      }
    }
<br/>    <span class="stQuotedString">"it contains one item"</span> should {
      behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
      behave like nonFullStack(stackWithOneItem)
    }
<br/>    <span class="stQuotedString">"it contains one item less than capacity"</span> should {
      behave like nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed)
      behave like nonFullStack(stackWithOneItemLessThanCapacity)
    }
<br/>    <span class="stQuotedString">"full"</span> should {
      <span class="stQuotedString">"be full"</span> in {
        assert(fullStack.full)
      }
<br/>      behave like nonEmptyStack(fullStack, lastValuePushed)
<br/>      <span class="stQuotedString">"complain on a push"</span> in {
        assertThrows[<span class="stType">IllegalStateException</span>] {
          fullStack.push(<span class="stLiteral">10</span>)
        }
      }
    }
  }
}
</pre></p><p>If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
you'll see:</p><p><pre class="stREPL">
scala&gt; org.scalatest.run(new SharedTestExampleSpec)
<span class="stGreen">SharedTestExampleSpec:
A Stack
  when empty
&nbsp; - should be empty
&nbsp; - should complain on peek
&nbsp; - should complain on pop
&nbsp; when it contains one item
&nbsp; - should be non-empty
&nbsp; - should return the top item on peek
&nbsp; - should not remove the top item on peek
&nbsp; - should remove the top item on pop
&nbsp; - should not be full
&nbsp; - should add to the top on push
&nbsp; when it contains one item less than capacity
&nbsp; - should be non-empty
&nbsp; - should return the top item on peek
&nbsp; - should not remove the top item on peek
&nbsp; - should remove the top item on pop
&nbsp; - should not be full
&nbsp; - should add to the top on push
&nbsp; when full
&nbsp; - should be full
&nbsp; - should be non-empty
&nbsp; - should return the top item on peek
&nbsp; - should not remove the top item on peek
&nbsp; - should remove the top item on pop
&nbsp; - should complain on a push</span>
</pre></p><p>One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
complaining that multiple tests are being registered with the same test name. A good way to solve this problem in a <code>WordSpec</code> is to make sure
each invocation of a behavior function is in the context of a different surrounding <code>when</code>,
<code>should</code>/<code>must</code>/<code>can</code>, or <code>which</code> clause, because a test's name is the concatenation of its
surrounding clauses and after words, followed by the &quot;spec text&quot;.
For example, the following code in a <code>WordSpec</code> would register a test with the name <code>"A Stack when empty should be empty"</code>:</p><p><pre class="stHighlighted">
<span class="stQuotedString">"A Stack"</span> when {
  <span class="stQuotedString">"empty"</span> should {
    <span class="stQuotedString">"be empty"</span> in {
      assert(emptyStack.empty)
    }
  }
}
<span class="stLineComment">// ...</span>
</pre></p><p>If the <code>"be empty"</code> test was factored out into a behavior function, it could be called repeatedly so long
as each invocation of the behavior function is in the context of a different surrounding <code>when</code> clauses.</p></div></div>
    </li><li name="org.scalatest.WordSpecLike" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="WordSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting"></a><a id="WordSpecLike:WordSpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#WordSpecLikeextendsTestSuitewithTestRegistrationwithShouldVerbwithMustVerbwithCanVerbwithInformingwithNotifyingwithAlertingwithDocumenting" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Implementation trait for class WordSpec, which facilitates a &amp;ldquo;behavior-driven&amp;rdquo; style of development (BDD), in which tests are combined with text that specifies the behavior the tests verify." href="WordSpecLike.html"><span class="name">WordSpecLike</span></a><span class="result"> extends <a href="TestSuite.html" class="extype" name="org.scalatest.TestSuite">TestSuite</a> with <a href="TestRegistration.html" class="extype" name="org.scalatest.TestRegistration">TestRegistration</a> with <a href="words/ShouldVerb.html" class="extype" name="org.scalatest.words.ShouldVerb">ShouldVerb</a> with <a href="words/MustVerb.html" class="extype" name="org.scalatest.words.MustVerb">MustVerb</a> with <a href="words/CanVerb.html" class="extype" name="org.scalatest.words.CanVerb">CanVerb</a> with <a href="Informing.html" class="extype" name="org.scalatest.Informing">Informing</a> with <a href="Notifying.html" class="extype" name="org.scalatest.Notifying">Notifying</a> with <a href="Alerting.html" class="extype" name="org.scalatest.Alerting">Alerting</a> with <a href="Documenting.html" class="extype" name="org.scalatest.Documenting">Documenting</a></span>
      </span>
      
      <p class="shortcomment cmt">Implementation trait for class <code>WordSpec</code>, which facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation trait for class <code>WordSpec</code>, which facilitates a &ldquo;behavior-driven&rdquo; style of development (BDD), in which tests
are combined with text that specifies the behavior the tests verify.</p><p><a href="WordSpec.html"><code>WordSpec</code></a> is a class, not a trait, to minimize compile time given there is a slight compiler overhead to
mixing in traits compared to extending classes. If you need to mix the behavior of <code>WordSpec</code>
into some other class, you can use this trait instead, because class <code>WordSpec</code> does nothing more than extend this trait and add a nice <code>toString</code> implementation.</p><p>See the documentation of the class for a <a href="WordSpec.html">detailed overview of <code>WordSpec</code></a>.</p></div></div>
    </li><li name="org.scalatest.WrapWith" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="WrapWithextendsAnnotation"></a><a id="WrapWith:WrapWith"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#WrapWithextendsAnnotation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Annotation to associate a wrapper suite with a non-Suite class, so it can be run via ScalaTest." href="WrapWith.html"><span class="name">WrapWith</span></a><span class="result"> extends <span class="extype" name="java.lang.annotation.Annotation">Annotation</span></span>
      </span>
      
      <p class="shortcomment cmt">Annotation to associate a <em>wrapper suite</em> with a non-<code>Suite</code> class, so it can be run via ScalaTest.</p><div class="fullcomment"><div class="comment cmt"><p>Annotation to associate a <em>wrapper suite</em> with a non-<code>Suite</code> class, so it can be run via ScalaTest.</p><p><em>Note: This is actually an annotation defined in Java, not a Scala trait. It must be defined in Java instead of Scala so it will be accessible
at runtime. It has been inserted into Scaladoc by pretending it is a trait.</em></p><p>A class will be considered annotated with <code>WrapWith</code> if it is annotated directly or one of its superclasses (but
not supertraits) are annotated with <code>WrapWith</code>.
The wrapper suite must have a public, one-arg constructor that takes a <code>Class</code> instance whose type parameter
is compatible with the <em>class to wrap</em>: <em>i.e.</em>, the class being annotated with <code>WrapWith</code>.
ScalaTest will load the class to wrap and construct a new instance of the wrapper suite, passing in the <code>Class</code>
instance for the class to wrap.
Here's an example:</p><p><pre class="stHighlight">
import org.scalacheck.Properties

@WrapWith(classOf[ScalaCheckPropertiesSpec])
class StringSpecification extends Properties("String") {
  // ...
}
</pre></p><p>The <code>ScalaCheckPropertiesSpec</code> would need to have a public, no-arg constructor that accepts subclasses of <code>org.scalacheck.Properties</code>:</p><p><pre class="stHighlight">
import org.scalacheck.Properties
import org.scalatest.Suite

class ScalaCheckPropertiesSpec(clazz: Class[_ <: Properties]) extends Suite {
  // ...
}
</pre>
</p></div></div>
    </li><li name="org.scalatest.PendingNothing" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PendingNothing=org.scalatest.PendingStatement"></a><a id="PendingNothing:PendingNothing"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PendingNothing=org.scalatest.PendingStatement" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: Please use PendingStatement instead">PendingNothing</span><span class="result alias"> = <a href="PendingStatement.html" class="extype" name="org.scalatest.PendingStatement">PendingStatement</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use PendingStatement instead</p></dd></dl></div>
    </li><li name="org.scalatest.Rerunner" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RerunnerextendsAnyRef"></a><a id="Rerunner:Rerunner"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#RerunnerextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose instances can rerun tests or other entities (such as suites)." href="Rerunner.html"><span class="name deprecated" title="Deprecated: We are considering removing Rerunner in ScalaTest 2.0 and would like to know if anyone is using it. If you are, please email scalatest-users@googlegroups.com or and describe your use case. Thanks!">Rerunner</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose instances can rerun tests or other entities (such as suites).</p><div class="fullcomment"><div class="comment cmt"><p>Trait whose instances can rerun tests or other entities (such as suites). An object extending
this trait can be passed to a <code>Reporter</code> as part of a <code>Report</code>. The
test or other entity about which the report is made can then be rerun by invoking the
<code>rerun</code> method on the <code>Rerunnable</code>.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>We are considering removing Rerunner in ScalaTest 2.0 and would like to know if anyone is using it. If you are, please email scalatest-users@googlegroups.com or and describe your use case. Thanks!</p></dd></dl></div>
    </li><li name="org.scalatest.Spec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Spec=org.scalatest.refspec.RefSpec"></a><a id="Spec:Spec"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Spec=org.scalatest.refspec.RefSpec" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: Please use org.scalatest.refspec.RefSpec instead">Spec</span><span class="result alias"> = <a href="refspec/RefSpec.html" class="extype" name="org.scalatest.refspec.RefSpec">RefSpec</a></span>
      </span>
      
      <p class="shortcomment cmt"><strong>The name <code>org.scalatest.Spec</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.refspec.RefSpec</code>, instead.</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalatest.Spec</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.refspec.RefSpec</code>, instead.</strong></p><p>Because this style uses reflection at runtime to discover scopes and tests, it can only be supported on the JVM, not Scala.js.
Thus in ScalaTest 3.0.0, class <code>org.scalatest.Spec</code> was moved to the <code>org.scalatest.refspec</code> package and renamed
<code>RefSpec</code>, with the intention of later moving it to a separate module available only on the JVM.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.refspec.RefSpec instead</p></dd></dl></div>
    </li><li name="org.scalatest.SpecLike" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SpecLike=org.scalatest.refspec.RefSpecLike"></a><a id="SpecLike:SpecLike"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SpecLike=org.scalatest.refspec.RefSpecLike" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: Please use org.scalatest.refspec.RefSpecLike instead">SpecLike</span><span class="result alias"> = <a href="refspec/RefSpecLike.html" class="extype" name="org.scalatest.refspec.RefSpecLike">RefSpecLike</a></span>
      </span>
      
      <p class="shortcomment cmt"><strong>The name <code>org.scalatest.SpecLike</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.refspec.RefSpecLike</code>, instead.</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalatest.SpecLike</code> has been deprecated and will be removed in a future version of ScalaTest. Please use
its new name, <code>org.scalatest.refspec.RefSpecLike</code>, instead.</strong></p><p>Because this style uses reflection at runtime to discover scopes and tests, it can only be supported on the JVM, not Scala.js.
Thus in ScalaTest 3.0.0, class <code>org.scalatest.SpecLike</code> was moved to the <code>org.scalatest.refspec</code> package and renamed
<code>RefSpecLike</code>, with the intention of later moving it to a separate module available only on the JVM.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>Please use org.scalatest.refspec.RefSpecLike instead</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="org.scalatest#ScalaTestVersion" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ScalaTestVersion:String"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ScalaTestVersion:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ScalaTestVersion</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">The version number of ScalaTest.</p><div class="fullcomment"><div class="comment cmt"><p>The version number of ScalaTest.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the ScalaTest version number.</p></dd></dl></div>
    </li><li name="org.scalatest#color" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="color:org.scalatest.Shell"></a><a id="color:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#color:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">color</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>colorPassed</code> configuration parameter set to <code>true</code>.</p>
    </li><li name="org.scalatest#durations" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="durations:org.scalatest.Shell"></a><a id="durations:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#durations:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">durations</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>durationsPassed</code> configuration parameter set to <code>true</code>.</p>
    </li><li name="org.scalatest#fullstacks" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="fullstacks:org.scalatest.Shell"></a><a id="fullstacks:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#fullstacks:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">fullstacks</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>fullStacksPassed</code> configuration parameter set to <code>true</code>.</p>
    </li><li name="org.scalatest#nocolor" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="nocolor:org.scalatest.Shell"></a><a id="nocolor:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#nocolor:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nocolor</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>colorPassed</code> configuration parameter set to <code>false</code>.</p>
    </li><li name="org.scalatest#nodurations" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="nodurations:org.scalatest.Shell"></a><a id="nodurations:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#nodurations:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nodurations</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>durationsPassed</code> configuration parameter set to <code>false</code>.</p>
    </li><li name="org.scalatest#nostacks" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="nostacks:org.scalatest.Shell"></a><a id="nostacks:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#nostacks:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nostacks</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>shortStacksPassed</code> configuration parameter set to <code>false</code>.</p>
    </li><li name="org.scalatest#nostats" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="nostats:org.scalatest.Shell"></a><a id="nostats:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#nostats:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nostats</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>statsPassed</code> configuration parameter set to <code>false</code>.</p>
    </li><li name="org.scalatest#shortstacks" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="shortstacks:org.scalatest.Shell"></a><a id="shortstacks:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#shortstacks:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">shortstacks</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>shortStacksPassed</code> configuration parameter set to <code>true</code>.</p>
    </li><li name="org.scalatest#stats" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="stats:org.scalatest.Shell"></a><a id="stats:Shell"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#stats:org.scalatest.Shell" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">stats</span><span class="result">: <a href="Shell.html" class="extype" name="org.scalatest.Shell">Shell</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this <code>Shell</code> with <code>statsPassed</code> configuration parameter set to <code>true</code>.</p>
    </li><li name="org.scalatest.AppendedClues" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AppendedClues"></a><a id="AppendedClues:AppendedClues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#AppendedClues" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of AppendedClues members as an alternative to mixing it in." href="AppendedClues$.html"><span class="name">AppendedClues</span></a><span class="result"> extends <a href="AppendedClues.html" class="extype" name="org.scalatest.AppendedClues">AppendedClues</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>AppendedClues</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>AppendedClues</code> members as
an alternative to mixing it in. One use case is to import <code>AppendedClues</code>
members so you can use them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.Assertions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Assertions"></a><a id="Assertions:Assertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Assertions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of Assertions members as an alternative to mixing it in." href="Assertions$.html"><span class="name">Assertions</span></a><span class="result"> extends <a href="Assertions.html" class="extype" name="org.scalatest.Assertions">Assertions</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Assertions</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Assertions</code> members as
an alternative to mixing it in. One use case is to import <code>Assertions</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$scala -classpath scalatest.jar
Welcome to Scala version 2.7.3.final (Java HotSpot(TM) Client VM, Java 1.5.0_16).
Type in expressions to have them evaluated.
Type :help for more information.
&nbsp;
scala&gt; import org.scalatest.Assertions._
import org.scalatest.Assertions._
&nbsp;
scala&gt; assert(1 === 2)
org.scalatest.TestFailedException: 1 did not equal 2
     at org.scalatest.Assertions$class.assert(Assertions.scala:211)
     at org.scalatest.Assertions$.assert(Assertions.scala:511)
     at .&lt;init&gt;(&lt;console&gt;:7)
     at .&lt;clinit&gt;(&lt;console&gt;)
     at RequestResult$.&lt;init&gt;(&lt;console&gt;:3)
     at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)
     at RequestResult$result(&lt;console&gt;)
     at sun.reflect.NativeMethodAccessorImpl.invoke...
&nbsp;
scala&gt; assertResult(3) { 1 + 3 }
org.scalatest.TestFailedException: Expected 3, but got 4
     at org.scalatest.Assertions$class.expect(Assertions.scala:447)
     at org.scalatest.Assertions$.expect(Assertions.scala:511)
     at .&lt;init&gt;(&lt;console&gt;:7)
     at .&lt;clinit&gt;(&lt;console&gt;)
     at RequestResult$.&lt;init&gt;(&lt;console&gt;:3)
     at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)
     at RequestResult$result(&lt;console&gt;)
     at sun.reflect.NativeMethodAccessorImpl.in...
&nbsp;
scala&gt; val caught = intercept[StringIndexOutOfBoundsException] { "hi".charAt(-1) }
caught: StringIndexOutOfBoundsException = java.lang.StringIndexOutOfBoundsException: String index out of range: -1
</pre>
</p></div></div>
    </li><li name="org.scalatest.Canceled" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Canceled"></a><a id="Canceled:Canceled"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Canceled" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class Canceled that provides, in addition to the extractor and factory method provided by the compiler given its companion is a case class, a second factory method that produces a Canceled outcome given a string message." href="Canceled$.html"><span class="name">Canceled</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>Canceled</code> that provides, in addition to the extractor and factory method
provided by the compiler given its companion is a case class, a second factory method
that produces a <code>Canceled</code> outcome given a string message.</p>
    </li><li name="org.scalatest.Checkpoints" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Checkpoints"></a><a id="Checkpoints:Checkpoints"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Checkpoints" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing the members of trait Checkpoints as an alternative to mixing it in." href="Checkpoints$.html"><span class="name">Checkpoints</span></a><span class="result"> extends <a href="Checkpoints.html" class="extype" name="org.scalatest.Checkpoints">Checkpoints</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing the members of trait <code>Checkpoints</code> as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing the members of trait <code>Checkpoints</code> as
an alternative to mixing it in. One use case is to import <code>Checkpoints</code> so you can use
it in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.CompleteLastly" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CompleteLastly"></a><a id="CompleteLastly:CompleteLastly"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#CompleteLastly" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of CompleteLastly members as an alternative to mixing it in." href="CompleteLastly$.html"><span class="name">CompleteLastly</span></a><span class="result"> extends <a href="CompleteLastly.html" class="extype" name="org.scalatest.CompleteLastly">CompleteLastly</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>CompleteLastly</code> members as
an alternative to mixing it in.</p>
    </li><li name="org.scalatest.ConfigMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ConfigMap"></a><a id="ConfigMap:ConfigMap"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#ConfigMap" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class ConfigMap containing factory methods." href="ConfigMap$.html"><span class="name">ConfigMap</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>ConfigMap</code> containing factory methods.</p>
    </li><li name="org.scalatest.DiagrammedAssertions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DiagrammedAssertions"></a><a id="DiagrammedAssertions:DiagrammedAssertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DiagrammedAssertions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of DiagrammedAssertions members as an alternative to mixing it in." href="DiagrammedAssertions$.html"><span class="name">DiagrammedAssertions</span></a><span class="result"> extends <a href="DiagrammedAssertions.html" class="extype" name="org.scalatest.DiagrammedAssertions">DiagrammedAssertions</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>DiagrammedAssertions</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>DiagrammedAssertions</code> members as
an alternative to mixing it in. One use case is to import <code>DiagrammedAssertions</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$scala -classpath scalatest.jar
Welcome to Scala version 2.10.4.final (Java HotSpot(TM) Client VM, Java 1.6.0_45).
Type in expressions to have them evaluated.
Type :help for more information.
&nbsp;
scala&gt; import org.scalatest.Assertions._
import org.scalatest.Assertions._
&nbsp;
scala&gt; assert(1 === 2)
org.scalatest.exceptions.TestFailedException:

assert(1 === 2)
       | |   |
       1 |   2
         false

     at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
	    at org.scalatest.DiagrammedAssertions$.newAssertionFailedException(DiagrammedAssertions.scala:249)
	    at org.scalatest.DiagrammedAssertions$DiagrammedAssertionsHelper.macroAssert(DiagrammedAssertions.scala:111)
	    at .&lt;init&gt;(&lt;console&gt;:20)
	    at .&lt;clinit&gt;(&lt;console&gt;)
	    at .&lt;init&gt;(&lt;console&gt;:7)
	    at .&lt;clinit&gt;(&lt;console&gt;)
 	  at $print(&lt;console&gt;)
	    at sun.reflect.NativeMethodAccessorImpl.invoke...
</pre>
</p></div></div>
    </li><li name="org.scalatest.DiagrammedExpr" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DiagrammedExpr"></a><a id="DiagrammedExpr:DiagrammedExpr"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#DiagrammedExpr" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="DiagrammedExpr companion object that provides factory methods to create different sub types of DiagrammedExpr" href="DiagrammedExpr$.html"><span class="name">DiagrammedExpr</span></a>
      </span>
      
      <p class="shortcomment cmt"><code>DiagrammedExpr</code> companion object that provides factory methods to create different sub types of <code>DiagrammedExpr</code></p><div class="fullcomment"><div class="comment cmt"><p><code>DiagrammedExpr</code> companion object that provides factory methods to create different sub types of <code>DiagrammedExpr</code></p><p><code>DiagrammedExpr</code> is used by code generated from <code>DiagrammedAssertionsMacro</code>, it needs to be public
so that the generated code can be compiled.  It is expected that ScalaTest users would ever need to use <code>DiagrammedExpr</code>
directly.
</p></div></div>
    </li><li name="org.scalatest.EitherValues" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EitherValues"></a><a id="EitherValues:EitherValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#EitherValues" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of ValueEither members as an alternative to mixing it in." href="EitherValues$.html"><span class="name">EitherValues</span></a><span class="result"> extends <a href="EitherValues.html" class="extype" name="org.scalatest.EitherValues">EitherValues</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>ValueEither</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>ValueEither</code> members as
an alternative to mixing it in. One use case is to import <code>EitherValues</code>'s members so you can use
<code>left.value</code> and <code>right.value</code> on <code>Either</code> in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.7.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import matchers.Matchers._
import matchers.Matchers._

scala&gt; import EitherValues._
import EitherValues._

scala&gt; val e: Either[String, Int] = Left("Muchas problemas")
e: Either[String,Int] = Left(Muchas problemas)

scala&gt; e.left.value should be ("Muchas problemas")

scala&gt; e.right.value should be &lt; 9
org.scalatest.TestFailedException: The Either on which rightValue was invoked was not defined.
  at org.scalatest.EitherValues$RightValuable.value(EitherValues.scala:148)
  at .&lt;init&gt;(&lt;console&gt;:18)
  ...
</pre>
</p></div></div>
    </li><li name="org.scalatest.Exceptional" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Exceptional"></a><a id="Exceptional:Exceptional"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Exceptional" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class Exceptional that provides a factory method and an extractor that enables patterns that match both Failed and Canceled outcomes and extracts the contained exception and a factory method." href="Exceptional$.html"><span class="name">Exceptional</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>Exceptional</code> that provides a factory method and an extractor that enables
patterns that match both <code>Failed</code> and <code>Canceled</code> outcomes and
extracts the contained exception and a factory method.</p>
    </li><li name="org.scalatest.Failed" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Failed"></a><a id="Failed:Failed"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Failed" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Failed$.html"><span class="name">Failed</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      
    </li><li name="org.scalatest.FailedStatus" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FailedStatus"></a><a id="FailedStatus:FailedStatus"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FailedStatus" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Singleton status that represents an already completed run with at least one failed test or aborted suite." href="FailedStatus$.html"><span class="name">FailedStatus</span></a><span class="result"> extends <a href="Status.html" class="extype" name="org.scalatest.Status">Status</a> with <span class="extype" name="java.io.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Singleton status that represents an already completed run with at least one failed test or aborted suite.</p><div class="fullcomment"><div class="comment cmt"><p>Singleton status that represents an already completed run with at least one failed test or aborted suite.</p><p>Note: the difference between this <code>FailedStatus</code> object and the similarly named <a href="Failed.html"><code>Failed</code></a>
class is that a <code>Failed</code> instance indicates one test failed, whereas this <code>FailedStatus</code> object indicates either one or more tests failed
and/or one or more suites aborted during a run. Both are used as the result type of <code>Suite</code> lifecycle methods, but <code>Failed</code>
is a possible result of <code>withFixture</code>, whereas <code>FailedStatus</code> is a possible result of <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, or <code>runTest</code>. In short, <code>Failed</code> is always just about one test, whereas <code>FailedStatus</code> could be
about something larger: multiple tests or an entire suite.</p></div></div>
    </li><li name="org.scalatest.Filter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Filter"></a><a id="Filter:Filter"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Filter" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Filter$.html"><span class="name">Filter</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      
    </li><li name="org.scalatest.FutureOutcome" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="FutureOutcome"></a><a id="FutureOutcome:FutureOutcome"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#FutureOutcome" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to FutureOutcomes that contains factory methods for creating already-completed FutureOutcomes." href="FutureOutcome$.html"><span class="name">FutureOutcome</span></a>
      </span>
      
      <p class="shortcomment cmt">Companion object to <code>FutureOutcomes</code> that contains factory methods for creating already-completed
<code>FutureOutcomes</code>.</p>
    </li><li name="org.scalatest.Inside" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Inside"></a><a id="Inside:Inside"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Inside" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of the inside construct as an alternative to mixing it in." href="Inside$.html"><span class="name">Inside</span></a><span class="result"> extends <a href="Inside.html" class="extype" name="org.scalatest.Inside">Inside</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of the <code>inside</code> construct as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of the <code>inside</code> construct as
an alternative to mixing it in. One use case is to import the <code>inside</code> construct so you can use
it in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.8.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import matchers.Matchers._
import matchers.Matchers._

scala&gt; import Inside._
import Inside._

scala&gt; inside (List(1, 2, 3)) { case List(x, y, z) =>
    |   y should equal (2)
    | }

scala&gt; inside (List(1, 2, 3)) { case List(x, y, z) =>
     |   x should equal (2)
     | }
org.scalatest.TestFailedException: 1 did not equal 2, inside List(1, 2, 3)
  at org.scalatest.matchers.Matchers$class.newTestFailedException(Matchers.scala:150)
  at org.scalatest.matchers.Matchers$.newTestFailedException(Matchers.scala:2331)
  at org.scalatest.matchers.Matchers$ShouldMethodHelper$.shouldMatcher(Matchers.scala:873)
  ...
</pre>
</p></div></div>
    </li><li name="org.scalatest.Inspectors" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Inspectors"></a><a id="Inspectors:Inspectors"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Inspectors" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of Inspectors members as an alternative to mixing it in." href="Inspectors$.html"><span class="name">Inspectors</span></a><span class="result"> extends <a href="Inspectors.html" class="extype" name="org.scalatest.Inspectors">Inspectors</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Inspectors</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Inspectors</code> members as
an alternative to mixing it in. One use case is to import <code>Inspectors</code>'s members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.LoneElement" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LoneElement"></a><a id="LoneElement:LoneElement"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#LoneElement" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of LoneElement members as an alternative to mixing it in." href="LoneElement$.html"><span class="name">LoneElement</span></a><span class="result"> extends <a href="LoneElement.html" class="extype" name="org.scalatest.LoneElement">LoneElement</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>LoneElement</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>LoneElement</code> members as
an alternative to mixing it in. One use case is to import <code>LoneElement</code>'s members so you can use
<code>loneElement</code> in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.Matchers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Matchers"></a><a id="Matchers:Matchers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Matchers" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of Matchers members as an alternative to mixing it the trait." href="Matchers$.html"><span class="name">Matchers</span></a><span class="result"> extends <a href="Matchers.html" class="extype" name="org.scalatest.Matchers">Matchers</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Matchers</code> members as
an alternative to mixing it the trait.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Matchers</code> members as
an alternative to mixing it the trait. One use case is to import <code>Matchers</code> members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.MustMatchers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MustMatchers"></a><a id="MustMatchers:MustMatchers"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#MustMatchers" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of Matchers members as an alternative to mixing it the trait." href="MustMatchers$.html"><span class="name">MustMatchers</span></a><span class="result"> extends <a href="MustMatchers.html" class="extype" name="org.scalatest.MustMatchers">MustMatchers</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Matchers</code> members as
an alternative to mixing it the trait.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Matchers</code> members as
an alternative to mixing it the trait. One use case is to import <code>Matchers</code> members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.NonImplicitAssertions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NonImplicitAssertions"></a><a id="NonImplicitAssertions:NonImplicitAssertions"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#NonImplicitAssertions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of the members of trait Assertions without importing the implicit conversions it provides by default." href="NonImplicitAssertions$.html"><span class="name">NonImplicitAssertions</span></a><span class="result"> extends <a href="NonImplicitAssertions.html" class="extype" name="org.scalatest.NonImplicitAssertions">NonImplicitAssertions</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of the members of trait <code>Assertions</code> without importing the implicit conversions
it provides by default.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of the members of trait <code>Assertions</code> without importing the implicit conversions
it provides by default.  One use case for this object is to import the non-implicit <code>Assertions</code> members so you can use
them in the Scala interpreter along with another library whose implicits conflict with those provided by <code>Assertions</code>:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.7.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import NonImplicitAssertions._
import NonImplicitAssertions._

scala&gt; assert(1 + 1 === 2)
&lt;console&gt;:14: error: value === is not a member of Int
             assert(1 + 1 === 2)
                           ^

scala&gt; assert(1 + 1 == 2)

scala&gt; expect(2) { 1 + 1 }

scala&gt; expect(2) { 1 + 1 + 1 }
org.scalatest.TestFailedException: Expected 2, but got 3
  at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:318)
  at org.scalatest.NonImplicitAssertions$.newAssertionFailedException(NonImplicitAssertions.scala:73)
  ...

scala&gt; intercept[IndexOutOfBoundsException] { "hi".charAt(-1) }
res3: IndexOutOfBoundsException = java.lang.StringIndexOutOfBoundsException: String index out of range: -1
</pre>
</p></div></div>
    </li><li name="org.scalatest.OptionValues" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OptionValues"></a><a id="OptionValues:OptionValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OptionValues" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of OptionValues members as an alternative to mixing it in." href="OptionValues$.html"><span class="name">OptionValues</span></a><span class="result"> extends <a href="OptionValues.html" class="extype" name="org.scalatest.OptionValues">OptionValues</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>OptionValues</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>OptionValues</code> members as
an alternative to mixing it in. One use case is to import <code>OptionValues</code>'s members so you can use
<code>value</code> on option in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.7.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import matchers.Matchers._
import matchers.Matchers._

scala&gt; import OptionValues._
import OptionValues._

scala&gt; val opt1: Option[Int] = Some(1)
opt1: Option[Int] = Some(1)

scala&gt; val opt2: Option[Int] = None
opt2: Option[Int] = None

scala&gt; opt1.value should be &lt; 10

scala&gt; opt2.value should be &lt; 10
org.scalatest.TestFailedException: The Option on which value was invoked was not defined.
  at org.scalatest.OptionValues$Valuable.value(OptionValues.scala:68)
  at .&lt;init&gt;(&lt;console&gt;:18)
  ...
</pre></p></div></div>
    </li><li name="org.scalatest.Outcome" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Outcome"></a><a id="Outcome:Outcome"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Outcome" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object for trait Outcome that contains an implicit method that enables collections of Outcomes to be flattened into a collections of contained exceptions." href="Outcome$.html"><span class="name">Outcome</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object for trait <code>Outcome</code> that contains an implicit method that enables
collections of <code>Outcome</code>s to be flattened into a collections of contained exceptions.</p>
    </li><li name="org.scalatest.OutcomeOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OutcomeOf"></a><a id="OutcomeOf:OutcomeOf"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#OutcomeOf" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of OutcomeOf's method as an alternative to mixing it in." href="OutcomeOf$.html"><span class="name">OutcomeOf</span></a><span class="result"> extends <a href="OutcomeOf.html" class="extype" name="org.scalatest.OutcomeOf">OutcomeOf</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>OutcomeOf</code>'s method as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>OutcomeOf</code>'s method as
an alternative to mixing it in. One use case is to import <code>OutcomeOf</code>'s method so you can use
it in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.PartialFunctionValues" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PartialFunctionValues"></a><a id="PartialFunctionValues:PartialFunctionValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PartialFunctionValues" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of PartialFunctionValues members as an alternative to mixing it in." href="PartialFunctionValues$.html"><span class="name">PartialFunctionValues</span></a><span class="result"> extends <a href="PartialFunctionValues.html" class="extype" name="org.scalatest.PartialFunctionValues">PartialFunctionValues</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>PartialFunctionValues</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>PartialFunctionValues</code> members as
an alternative to mixing it in. One use case is to import <code>PartialFunctionValues</code>'s members so you can use
the <code>valueAt</code> method on <code>PartialFunction</code> in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -cp scalatest-1.7.jar
Welcome to Scala version 2.9.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_29).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import matchers.Matchers._
import matchers.Matchers._

scala&gt; import PartialFunctionValues._
import PartialFunctionValues._

scala&gt; val pf: PartialFunction[String, Int] = Map("I" -&gt; 1, "II" -&gt; 2, "III" -&gt; 3, "IV" -&gt; 4)
pf: PartialFunction[String,Int] = Map(I -&gt; 1, II -&gt; 2, III -&gt; 3, IV -&gt; 4)

scala&gt; pf("IV") should equal (4)

scala&gt; pf("V") should equal (5)
java.util.NoSuchElementException: key not found: V
  at scala.collection.MapLike$class.default(MapLike.scala:224)
  at scala.collection.immutable.Map$Map4.default(Map.scala:167)
  ...
</pre>
</p></div></div>
    </li><li name="org.scalatest.Payloads" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Payloads"></a><a id="Payloads:Payloads"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Payloads" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of Payloads members as an alternative to mixing it in." href="Payloads$.html"><span class="name">Payloads</span></a><span class="result"> extends <a href="Payloads.html" class="extype" name="org.scalatest.Payloads">Payloads</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>Payloads</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Payloads</code> members as
an alternative to mixing it in. One use case is to import <code>Payloads</code>
members so you can use them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.Pending" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Pending"></a><a id="Pending:Pending"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Pending" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Outcome for a test that was pending, which contains an optional string giving more information on what exactly is needed for the test to become non-pending." href="Pending$.html"><span class="name">Pending</span></a><span class="result"> extends <a href="Outcome.html" class="extype" name="org.scalatest.Outcome">Outcome</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Outcome for a test that was pending, which contains an optional string giving more information on what exactly is needed
for the test to become non-pending.</p>
    </li><li name="org.scalatest.PrivateMethodTester" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PrivateMethodTester"></a><a id="PrivateMethodTester:PrivateMethodTester"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#PrivateMethodTester" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of PrivateMethodTester members as an alternative to mixing it in." href="PrivateMethodTester$.html"><span class="name">PrivateMethodTester</span></a><span class="result"> extends <a href="PrivateMethodTester.html" class="extype" name="org.scalatest.PrivateMethodTester">PrivateMethodTester</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>PrivateMethodTester</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>PrivateMethodTester</code> members as
an alternative to mixing it in. One use case is to import <code>PrivateMethodTester</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$scala -classpath scalatest.jar
Welcome to Scala version 2.7.5.final (Java HotSpot(TM) Client VM, Java 1.5.0_16).
Type in expressions to have them evaluated.
Type :help for more information.
&nbsp;
scala> import org.scalatest.PrivateMethodTester._
import org.scalatest.PrivateMethodTester._
&nbsp;
scala> class Example {
     |   private def addSesame(prefix: String) = prefix + " sesame"
     | }
defined class Example
&nbsp;
scala> val example = new Example
example: Example = Example@d8b6fe
&nbsp;
scala> val addSesame = PrivateMethod[String]('addSesame)
addSesame: org.scalatest.PrivateMethodTester.PrivateMethod[String] = org.scalatest.PrivateMethodTester$PrivateMethod@5cdf95
&nbsp;
scala> example invokePrivate addSesame("open")
res0: String = open sesame
<pre>

@author Bill Venners
</p></div></div>
    </li><li name="org.scalatest.RecoverMethods" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RecoverMethods"></a><a id="RecoverMethods:RecoverMethods"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#RecoverMethods" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of RecoverMethods's method as an alternative to mixing it in." href="RecoverMethods$.html"><span class="name">RecoverMethods</span></a><span class="result"> extends <a href="RecoverMethods.html" class="extype" name="org.scalatest.RecoverMethods">RecoverMethods</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>RecoverMethods</code>'s method as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>RecoverMethods</code>'s method as
an alternative to mixing it in. One use case is to import <code>RecoverMethods</code>'s method so you can use
it in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.Retries" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Retries"></a><a id="Retries:Retries"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Retries" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to trait Retries that enables its members to be imported as an alternative to mixing them in." href="Retries$.html"><span class="name">Retries</span></a><span class="result"> extends <a href="Retries.html" class="extype" name="org.scalatest.Retries">Retries</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to trait <code>Retries</code> that enables its members to be imported as an
alternative to mixing them in.</p>
    </li><li name="org.scalatest.Sequential" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Sequential"></a><a id="Sequential:Sequential"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Sequential" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class Sequential that offers an apply factory method for creating a Sequential instance." href="Sequential$.html"><span class="name">Sequential</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>Sequential</code> that offers an <code>apply</code> factory method
for creating a <code>Sequential</code> instance.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to class <code>Sequential</code> that offers an <code>apply</code> factory method
for creating a <code>Sequential</code> instance.</p><p>One use case for this object is to run multiple specification-style suites in the Scala interpreter, like this:</p><p><pre class="stREPL">
scala&gt; Sequential(new MyFirstSuite, new MyNextSuite).execute()
</pre>
</p></div></div>
    </li><li name="org.scalatest.Stepwise" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Stepwise"></a><a id="Stepwise:Stepwise"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Stepwise" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class Stepwise that offers an apply factory method for creating a Stepwise instance." href="Stepwise$.html"><span class="name">Stepwise</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>Stepwise</code> that offers an <code>apply</code> factory method
for creating a <code>Stepwise</code> instance.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to class <code>Stepwise</code> that offers an <code>apply</code> factory method
for creating a <code>Stepwise</code> instance.</p><p>One use case for this object is to run multiple specification-style suites in the Scala interpreter, like this:</p><p><pre class="stREPL">
scala&gt; Stepwise(new MyFirstSuite, new MyNextSuite).execute()
</pre>
</p></div></div>
    </li><li name="org.scalatest.Stopper" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Stopper"></a><a id="Stopper:Stopper"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Stopper" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to Stopper that holds a factory method that produces a new Stopper whose stopRequested method returns false until after its requestStop has been invoked." href="Stopper$.html"><span class="name">Stopper</span></a>
      </span>
      
      <p class="shortcomment cmt">Companion object to Stopper that holds a factory method that produces a new <code>Stopper</code> whose
<code>stopRequested</code> method returns false until after its <code>requestStop</code> has been
invoked.</p>
    </li><li name="org.scalatest.StreamlinedXml" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXml"></a><a id="StreamlinedXml:StreamlinedXml"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXml" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of StreamlinedXml members as an alternative to mixing it the trait." href="StreamlinedXml$.html"><span class="name">StreamlinedXml</span></a><span class="result"> extends <a href="StreamlinedXml.html" class="extype" name="org.scalatest.StreamlinedXml">StreamlinedXml</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>StreamlinedXml</code> members as
an alternative to mixing it the trait.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>StreamlinedXml</code> members as
an alternative to mixing it the trait. One use case is to import <code>StreamlinedXml</code> members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.StreamlinedXmlEquality" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXmlEquality"></a><a id="StreamlinedXmlEquality:StreamlinedXmlEquality"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXmlEquality" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of StreamlinedXmlEquality members as an alternative to mixing it the trait." href="StreamlinedXmlEquality$.html"><span class="name">StreamlinedXmlEquality</span></a><span class="result"> extends <a href="StreamlinedXmlEquality.html" class="extype" name="org.scalatest.StreamlinedXmlEquality">StreamlinedXmlEquality</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>StreamlinedXmlEquality</code> members as
an alternative to mixing it the trait.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>StreamlinedXmlEquality</code> members as
an alternative to mixing it the trait. One use case is to import <code>StreamlinedXmlEquality</code> members so you can use
them in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.StreamlinedXmlNormMethods" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamlinedXmlNormMethods"></a><a id="StreamlinedXmlNormMethods:StreamlinedXmlNormMethods"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#StreamlinedXmlNormMethods" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of StreamlinedXmlNormMethods members as an alternative to mixing it the trait." href="StreamlinedXmlNormMethods$.html"><span class="name">StreamlinedXmlNormMethods</span></a><span class="result"> extends <a href="StreamlinedXmlNormMethods.html" class="extype" name="org.scalatest.StreamlinedXmlNormMethods">StreamlinedXmlNormMethods</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>StreamlinedXmlNormMethods</code> members as
an alternative to mixing it the trait.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>StreamlinedXmlNormMethods</code> members as
an alternative to mixing it the trait. One use case is to import <code>StreamlinedXmlNormMethods</code>'s implicit so you can use
it in the Scala interpreter.
</p></div></div>
    </li><li name="org.scalatest.Succeeded" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Succeeded"></a><a id="Succeeded:Succeeded"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Succeeded" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Outcome for a test that succeeded." href="Succeeded$.html"><span class="name">Succeeded</span></a><span class="result"> extends <a href="Outcome.html" class="extype" name="org.scalatest.Outcome">Outcome</a> with <a href="compatible/Assertion.html" class="extype" name="org.scalatest.compatible.Assertion">scalatest.compatible.Assertion</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Outcome for a test that succeeded.</p><div class="fullcomment"><div class="comment cmt"><p>Outcome for a test that succeeded.</p><p>Note: the difference between this <code>Succeeded</code> object and the similarly named <a href="SucceededStatus$.html"><code>SucceededStatus</code></a>
object is that this object indicates one test (or assertion) succeeded, whereas the <code>SucceededStatus</code> object indicates the absence of any failed tests or
aborted suites during a run. Both are used as the result type of <a href="Suite.html#lifecycle-methods"><code>Suite</code></a> lifecycle methods, but <code>Succeeded</code>
is a possible result of <code>withFixture</code>, whereas <code>SucceededStatus</code> is a possible result of <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, or <code>runTest</code>. In short, <code>Succeeded</code> is always just about one test (or assertion), whereas <code>SucceededStatus</code> could be
about something larger: multiple tests or an entire suite.</p></div></div>
    </li><li name="org.scalatest.SucceededStatus" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SucceededStatus"></a><a id="SucceededStatus:SucceededStatus"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#SucceededStatus" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Singleton status that represents an already completed run with no tests failed and no suites aborted." href="SucceededStatus$.html"><span class="name">SucceededStatus</span></a><span class="result"> extends <a href="Status.html" class="extype" name="org.scalatest.Status">Status</a> with <span class="extype" name="java.io.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Singleton status that represents an already completed run with no tests failed and no suites aborted.</p><div class="fullcomment"><div class="comment cmt"><p>Singleton status that represents an already completed run with no tests failed and no suites aborted.</p><p>Note: the difference between this <code>SucceededStatus</code> object and the similarly named <a href="Succeeded$.html"><code>Succeeded</code></a>
object is that the <code>Succeeded</code> object indicates one test succeeded, whereas this <code>SucceededStatus</code> object indicates the absence
of any failed tests or aborted suites during a run. Both are used as the result type of <a href="Suite.html#lifecycle-methods"><code>Suite</code></a> lifecycle methods, but <code>Succeeded</code>
is a possible result of <code>withFixture</code>, whereas <code>SucceededStatus</code> is a possible result of <code>run</code>, <code>runNestedSuites</code>,
<code>runTests</code>, or <code>runTest</code>. In short, <code>Succeeded</code> is always just about one test, whereas <code>SucceededStatus</code> could be
about something larger: multiple tests or an entire suite.</p></div></div>
    </li><li name="org.scalatest.Suites" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Suites"></a><a id="Suites:Suites"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Suites" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object to class Suites that offers an apply factory method for creating a Suites instance." href="Suites$.html"><span class="name">Suites</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Companion object to class <code>Suites</code> that offers an <code>apply</code> factory method
for creating a <code>Suites</code> instance.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to class <code>Suites</code> that offers an <code>apply</code> factory method
for creating a <code>Suites</code> instance.</p><p>One use case for this object is to run multiple specification-style suites in the Scala interpreter, like this:</p><p><pre class="stREPL">
scala&gt; Suites(new MyFirstSuite, new MyNextSuite).execute()
</pre>
</p></div></div>
    </li><li name="org.scalatest.Tag" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Tag"></a><a id="Tag:Tag"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Tag" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object for Tag, which offers a factory method." href="Tag$.html"><span class="name">Tag</span></a>
      </span>
      
      <p class="shortcomment cmt">Companion object for <code>Tag</code>, which offers a factory method.</p>
    </li><li name="org.scalatest.Tracker" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Tracker"></a><a id="Tracker:Tracker"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#Tracker" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Tracker$.html"><span class="name">Tracker</span></a>
      </span>
      
      
    </li><li name="org.scalatest.TryValues" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TryValues"></a><a id="TryValues:TryValues"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#TryValues" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Companion object that facilitates the importing of TryValues members as an alternative to mixing it in." href="TryValues$.html"><span class="name">TryValues</span></a><span class="result"> extends <a href="TryValues.html" class="extype" name="org.scalatest.TryValues">TryValues</a></span>
      </span>
      
      <p class="shortcomment cmt">Companion object that facilitates the importing of <code>TryValues</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>TryValues</code> members as
an alternative to mixing it in. One use case is to import <code>TryValues</code>'s members so you can use
<code>success</code> and <code>failure</code> on <code>Try</code> in the Scala interpreter.
</pre>
</p></div></div>
    </li><li name="org.scalatest.run" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="run"></a><a id="run:run"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#run" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Singleton object providing an apply method for the ScalaTest shell and a main method for ScalaTest's simple runner." href="run$.html"><span class="name">run</span></a>
      </span>
      
      <p class="shortcomment cmt">Singleton object providing an <code>apply</code> method for the ScalaTest shell and a
<code>main</code> method for ScalaTest's simple runner.</p><div class="fullcomment"><div class="comment cmt"><p>Singleton object providing an <code>apply</code> method for the ScalaTest shell and a
<code>main</code> method for ScalaTest's simple runner.</p><p>The <code>apply</code> method can be used in the ScalaTest Shell (its DSL for the Scala
interpreter) in this way:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; class ArithmeticSuite extends FunSuite with Matchers {
     |   test("addition works") {
     |     1 + 1 should equal (2)
     |   }
     |   ignore("subtraction works") {
     |     1 - 1 should equal (0)
     |   }
     |   test("multiplication works") {
     |     1 * 1 should equal (2)
     |   }
     |   test("division works") (pending)
     | }
defined class ArithmeticSuite

scala&gt; run(new ArithmeticSuite)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED ***
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
</pre></p><p>The last command is calling the <code>apply</code> method on the <code>run</code> singleton object. In other
words, you could alternatively call it this way:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">scala&gt; run.apply(new ArithmeticSuite)</span>
<span style="color: #00cc00">ArithmeticSuite:
- addition works</span>
<span style="color: #cfc923">- subtraction works !!! IGNORED !!!</span>
<span style="color: #dd2233">- multiplication works *** FAILED ***
  1 did not equal 2 (<console>:16)</span>
<span style="color: #cfc923">- division works (pending)</span>
</pre></p><p>The <code>run</code> singleton object also serves a different purpose. Its <code>main</code> method
allows users to &quot;run&quot; <code>run</code> as a Scala application. ScalaTest's <a href="tools/Runner$.html"><code>Runner</code></a> application is very
powerful, but doesn't provide the simplest out-of-box experience for people trying ScalaTest for the first time. For example,
to run an <code>ExampleSpec</code> in the unnamed package from the directory where it is compiled with
<code>Runner</code>'s standard out reporter requires this command:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">$ scala -cp scalatest-RELEASE.jar org.scalatest.tools.Runner -R . -o -s ExampleSpec</span>
</pre></p><p>Running it with the <code>run</code> application is simpler:</p><p><pre style="background-color: #2c415c; padding: 10px">
<span style="color: white">$ scala -cp scalatest-RELEASE.jar org.scalatest.run ExampleSpec</span>
</pre></p></div></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
