<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>ScalaTest 3.0.1  - org.scalatest.concurrent.Conductors.Conductor</title>
          <meta name="description" content="ScalaTest 3.0.1 - org.scalatest.concurrent.Conductors.Conductor" />
          <meta name="keywords" content="ScalaTest 3.0.1 org.scalatest.concurrent.Conductors.Conductor" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NJWCS90VG5"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-NJWCS90VG5');

</script>
        </head>
        <body>
      <div id="search">
        <span id="doc-title">ScalaTest 3.0.1<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html">
              <span class="name">root</span>
            </a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.org" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="org"></a><a id="org:org"></a>
      <span class="permalink">
      <a href="index.html#org" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html">
              <span class="name">org</span>
            </a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="org.scalatest" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scalatest"></a><a id="scalatest:scalatest"></a>
      <span class="permalink">
      <a href="../org/index.html#scalatest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter." href="../index.html">
              <span class="name">scalatest</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.</p><div class="fullcomment"><div class="comment cmt"><p>ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li><li name="org.scalatest.concurrent" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concurrent"></a><a id="concurrent:concurrent"></a>
      <span class="permalink">
      <a href="../../org/scalatest/index.html#concurrent" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter." href="index.html">
              <span class="name">concurrent</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.</p><div class="fullcomment"><div class="comment cmt"><p>ScalaTest's main traits, classes, and other members, including members supporting ScalaTest's DSL for the Scala interpreter.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.scalatest">scalatest</a></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors" visbl="pub" class="indented4 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ConductorsextendsPatienceConfiguration"></a><a id="Conductors:Conductors"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/index.html#ConductorsextendsPatienceConfiguration" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait whose HtmlTag(&lt;code&gt;Conductor&lt;/code&gt;) member facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.HtmlTag(&lt;/code&gt;)" href="Conductors.html">
              <span class="name">Conductors</span>
            </a><span class="result"> extends <a href="PatienceConfiguration.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration">PatienceConfiguration</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait whose <code>Conductor</code> member facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.</code></p><div class="fullcomment"><div class="comment cmt"><p>Trait whose <code>Conductor</code> member facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.</p><p>A <code>Conductor</code> conducts a multi-threaded scenario by maintaining
a clock of &quot;beats.&quot; Beats are numbered starting with 0. You can ask a
<code>Conductor</code> to run threads that interact with the class, trait,
or library (the <em>subject</em>)
you want to test. A thread can call the <code>Conductor</code>'s
<code>waitForBeat</code> method, which will cause the thread to block
until that beat has been reached. The <code>Conductor</code> will advance
the beat only when all threads participating in the test are blocked. By
tying the timing of thread activities to specific beats, you can write
tests for concurrent systems that have deterministic interleavings of
threads.</p><p>A <code>Conductor</code> object has a three-phase lifecycle. It begins its life
in the <em>setup</em> phase. During this phase, you can start threads by
invoking the <code>thread</code> method on the <code>Conductor</code>.
When <code>conduct</code> is invoked on a <code>Conductor</code>, it enters
the <em>conducting</em> phase. During this phase it conducts the one multi-threaded
scenario it was designed to conduct. After all participating threads have exited, either by
returning normally or throwing an exception, the <code>conduct</code> method
will complete, either by returning normally or throwing an exception. As soon as
the <code>conduct</code> method completes, the <code>Conductor</code>
enters its <em>defunct</em> phase. Once the <code>Conductor</code> has conducted
a multi-threaded scenario, it is defunct and can't be reused. To run the same test again,
you'll need to create a new instance of <code>Conductor</code>.</p><p>Here's an example of the use of <code>Conductor</code> to test the <code>ArrayBlockingQueue</code>
class from <code>java.util.concurrent</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.fixture.FunSuite
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> java.util.concurrent.ArrayBlockingQueue
<span class="stReserved">import</span> org.scalatest.concurrent.Conductors

<span class="stReserved">class</span> <span class="stType">ArrayBlockingQueueSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> <span class="stReserved">with</span> <span class="stType">Conductors</span> {

  test(<span class="stQuotedString">"calling put on a full queue blocks the producer thread"</span>) {

    <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
    <span class="stReserved">import</span> conductor._

    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)

    thread(<span class="stQuotedString">"producer"</span>) {
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
      beat should be (<span class="stLiteral">1</span>)
    }

    thread(<span class="stQuotedString">"consumer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
    }

    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
}
</pre></p><p>When the test shown is run, it will create one thread named <em>producer</em> and another named
<em>consumer</em>. The producer thread will eventually execute the code passed as a by-name
parameter to <code>thread("producer")</code>:</p><p><pre class="stHighlighted">
buf put <span class="stLiteral">42</span>
buf put <span class="stLiteral">17</span>
beat should be (<span class="stLiteral">1</span>)
</pre></p><p>Similarly, the consumer thread will eventually execute the code passed as a by-name parameter
to <code>thread("consumer")</code>:</p><p><pre class="stHighlighted">
waitForBeat(<span class="stLiteral">1</span>)
buf.take should be (<span class="stLiteral">42</span>)
buf.take should be (<span class="stLiteral">17</span>)
</pre></p><p>The <code>thread</code> creates the threads and starts them, but they will not immediately
execute the by-name parameter passed to them. They will first block, waiting for the <code>Conductor</code>
to give them a green light to proceed.</p><p>The next call in the test is <code>whenFinished</code>. This method will first call <code>conduct</code> on
the <code>Conductor</code>, which will wait until all threads that were created (in this case, producer and consumer) are
at the &quot;starting line&quot;, <em>i.e.</em>, they have all started and are blocked, waiting on the green light.
The <code>conduct</code> method will then give these threads the green light and they will
all start executing their blocks concurrently.</p><p>When the threads are given the green light, the beat is 0. The first thing the producer thread does is put 42 in
into the queue. As the queue is empty at this point, this succeeds. The producer thread next attempts to put a 17
into the queue, but because the queue has size 1, this can't succeed until the consumer thread has read the 42
from the queue. This hasn't happened yet, so producer blocks. Meanwhile, the consumer thread's first act is to
call <code>waitForBeat(1)</code>. Because the beat starts out at 0, this call will block the consumer thread.
As a result, once the producer thread has executed <code>buf put 17</code> and the consumer thread has executed
<code>waitForBeat(1)</code>, both threads will be blocked.</p><p>The <code>Conductor</code> maintains a clock that wakes up periodically and checks to see if all threads
participating in the multi-threaded scenario (in this case, producer and consumer) are blocked. If so, it
increments the beat. Thus sometime later the beat will be incremented, from 0 to 1. Because consumer was
waiting for beat 1, it will wake up (<em>i.e.</em>, the <code>waitForBeat(1)</code> call will return) and
execute the next line of code in its block, <code>buf.take should be (42)</code>. This will succeed, because
the producer thread had previously (during beat 0) put 42 into the queue. This act will also make
producer runnable again, because it was blocked on the second <code>put</code>, which was waiting for another
thread to read that 42.</p><p>Now both threads are unblocked and able to execute their next statement. The order is
non-deterministic, and can even be simultaneous if running on multiple cores. If the <code>consumer</code> thread
happens to execute <code>buf.take should be (17)</code> first, it will block (<code>buf.take</code> will not return), because the queue is
at that point empty. At some point later, the producer thread will execute <code>buf put 17</code>, which will
unblock the consumer thread. Again both threads will be runnable and the order non-deterministic and
possibly simulataneous. The producer thread may charge ahead and run its next statement, <code>beat should be (1)</code>.
This will succeed because the beat is indeed 1 at this point. As this is the last statement in the producer's block,
the producer thread will exit normally (it won't throw an exception). At some point later the consumer thread will
be allowed to complete its last statement, the <code>buf.take</code> call will return 17. The consumer thread will
execute <code>17 should be (17)</code>. This will succeed and as this was the last statement in its block, the consumer will return
normally.</p><p>If either the producer or consumer thread had completed abruptbly with an exception, the <code>conduct</code> method
(which was called by <code>whenFinished</code>) would have completed abruptly with an exception to indicate the test
failed. However, since both threads returned normally, <code>conduct</code> will return. Because <code>conduct</code> doesn't
throw an exception, <code>whenFinished</code> will execute the block of code passed as a by-name parameter to it: <code>buf should be ('empty)</code>.
This will succeed, because the queue is indeed empty at this point. The <code>whenFinished</code> method will then return, and
because the <code>whenFinished</code> call was the last statement in the test and it didn't throw an exception, the test completes successfully.</p><p>This test tests <code>ArrayBlockingQueue</code>, to make sure it works as expected. If there were a bug in <code>ArrayBlockingQueue</code>
such as a <code>put</code> called on a full queue didn't block, but instead overwrote the previous value, this test would detect
it. However, if there were a bug in <code>ArrayBlockingQueue</code> such that a call to <code>take</code> called on an empty queue
never blocked and always returned 0, this test might not detect it. The reason is that whether the consumer thread will ever call
<code>take</code> on an empty queue during this test is non-deterministic. It depends on how the threads get scheduled during beat 1.
What is deterministic in this test, because the consumer thread blocks during beat 0, is that the producer thread will definitely
attempt to write to a full queue. To make sure the other scenario is tested, you'd need a different test:</p><p><pre class="stHighlighted">
test(<span class="stQuotedString">"calling take on an empty queue blocks the consumer thread"</span>) {

  <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
  <span class="stReserved">import</span> conductor._

  <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)

  thread(<span class="stQuotedString">"producer"</span>) {
    waitForBeat(<span class="stLiteral">1</span>)
    buf put <span class="stLiteral">42</span>
    buf put <span class="stLiteral">17</span>
  }

  thread(<span class="stQuotedString">"consumer"</span>) {
    buf.take should be (<span class="stLiteral">42</span>)
    buf.take should be (<span class="stLiteral">17</span>)
    beat should be (<span class="stLiteral">1</span>)
  }

  whenFinished {
    buf should be (<span class="stQuotedString">'empty</span>)
  }
}
</pre></p><p>In this test, the producer thread will block, waiting for beat 1. The consumer thread will invoke <code>buf.take</code>
as its first act. This will block, because the queue is empty. Because both threads are blocked, the <code>Conductor</code>
will at some point later increment the beat to 1. This will awaken the producer thread. It will return from its
<code>waitForBeat(1)</code> call and execute <code>buf put 42</code>. This will unblock the consumer thread, which will
take the 42, and so on.</p><p>The problem that <code>Conductor</code> is designed to address is the difficulty, caused by the non-deterministic nature
of thread scheduling, of testing classes, traits, and libraries that are intended to be used by multiple threads.
If you just create a test in which one thread reads from an <code>ArrayBlockingQueue</code> and
another writes to it, you can't be sure that you have tested all possible interleavings of threads, no matter
how many times you run the test. The purpose of <code>Conductor</code>
is to enable you to write tests with deterministic interleavings of threads. If you write one test for each possible
interleaving of threads, then you can be sure you have all the scenarios tested. The two tests shown here, for example,
ensure that both the scenario in which a producer thread tries to write to a full queue and the scenario in which a
consumer thread tries to take from an empty queue are tested.</p><p>Class <code>Conductor</code> was inspired by the
<a href="http://www.cs.umd.edu/projects/PL/multithreadedtc/">MultithreadedTC project</a>,
created by Bill Pugh and Nat Ayewah of the University of Maryland.</p><p>Although useful, bear in mind that a <code>Conductor</code>'s results are not guaranteed to be
accurate 100% of the time. The reason is that it uses <code>java.lang.Thread</code>'s <code>getState</code> method to
decide when to advance the beat. This use goes against the advice given in the Javadoc documentation for
<code>getState</code>, which says, &quot;This method is designed for use in monitoring of the system state, not for
synchronization.&quot; In short, sometimes the return value of <code>getState</code> occasionally may be inacurrate,
which in turn means that sometimes a <code>Conductor</code> could decide to advance the beat too early. In practice,
<code>Conductor</code> has proven to be very helpful when developing thread safe classes. It is also useful in
for regression tests, but you may have to tolerate occasional false negatives.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="org.scalatest.concurrent">concurrent</a></dd></dl></div>
    </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="" title="Class that facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently."></a>
                        <a href="" title="Class that facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.">
                          Conductor
                        </a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="AbstractPatienceConfiguration$PatienceConfig.html" title="Configuration object for asynchronous constructs, such as those provided by traits HtmlTag(&lt;a href=&quot;Eventually.html&quot;&gt;&lt;code&gt;Eventually&lt;/code&gt;&lt;/a&gt;) and
HtmlTag(&lt;a href=&quot;Waiters.html&quot;&gt;&lt;code&gt;Waiters&lt;/code&gt;&lt;/a&gt;).HtmlTag(&lt;/a&gt;)HtmlTag(&lt;/a&gt;)"></a>
                        <a href="AbstractPatienceConfiguration$PatienceConfig.html" title="Configuration object for asynchronous constructs, such as those provided by traits HtmlTag(&lt;a href=&quot;Eventually.html&quot;&gt;&lt;code&gt;Eventually&lt;/code&gt;&lt;/a&gt;) and
HtmlTag(&lt;a href=&quot;Waiters.html&quot;&gt;&lt;code&gt;Waiters&lt;/code&gt;&lt;/a&gt;).HtmlTag(&lt;/a&gt;)HtmlTag(&lt;/a&gt;)">
                          PatienceConfig
                        </a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">

<!-- Top of doc.scalatest.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/3cbad67e7fa9539151489fd25cf64fdd-ads.js?product=ScalaTest"></script>

      <div id="definition">
        <div class="big-circle class">c</div>
        <p id="owner"><a href="../../index.html" class="extype" name="org">org</a>.<a href="../index.html" class="extype" name="org.scalatest">scalatest</a>.<a href="index.html" class="extype" name="org.scalatest.concurrent">concurrent</a>.<a href="Conductors.html" class="extype" name="org.scalatest.concurrent.Conductors">Conductors</a></p>
        <h1>Conductor<span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Conductor</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Class that facilitates the testing of classes, traits, and libraries designed
to be used by multiple threads concurrently.</p><p>A <code>Conductor</code> conducts a multi-threaded scenario by maintaining
a clock of &quot;beats.&quot; Beats are numbered starting with 0. You can ask a
<code>Conductor</code> to run threads that interact with the class, trait,
or library (the <em>subject</em>)
you want to test. A thread can call the <code>Conductor</code>'s
<code>waitForBeat</code> method, which will cause the thread to block
until that beat has been reached. The <code>Conductor</code> will advance
the beat only when all threads participating in the test are blocked. By
tying the timing of thread activities to specific beats, you can write
tests for concurrent systems that have deterministic interleavings of
threads.</p><p>A <code>Conductor</code> object has a three-phase lifecycle. It begins its life
in the <em>setup</em> phase. During this phase, you can start threads by
invoking the <code>thread</code> method on the <code>Conductor</code>.
When <code>conduct</code> is invoked on a <code>Conductor</code>, it enters
the <em>conducting</em> phase. During this phase it conducts the one multi-threaded
scenario it was designed to conduct. After all participating threads have exited, either by
returning normally or throwing an exception, the <code>conduct</code> method
will complete, either by returning normally or throwing an exception. As soon as
the <code>conduct</code> method completes, the <code>Conductor</code>
enters its <em>defunct</em> phase. Once the <code>Conductor</code> has conducted
a multi-threaded scenario, it is defunct and can't be reused. To run the same test again,
you'll need to create a new instance of <code>Conductor</code>.</p><p>Here's an example of the use of <code>Conductor</code> to test the <code>ArrayBlockingQueue</code>
class from <code>java.util.concurrent</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.fixture.FunSuite
<span class="stReserved">import</span> org.scalatest.matchers.Matchers
<span class="stReserved">import</span> java.util.concurrent.ArrayBlockingQueue
<span class="stReserved">import</span> org.scalatest.concurrent.Conductors

<span class="stReserved">class</span> <span class="stType">ArrayBlockingQueueSuite</span> <span class="stReserved">extends</span> <span class="stType">FunSuite</span> <span class="stReserved">with</span> <span class="stType">Matchers</span> <span class="stReserved">with</span> <span class="stType">Conductors</span> {

  test(<span class="stQuotedString">"calling put on a full queue blocks the producer thread"</span>) {

    <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
    <span class="stReserved">import</span> conductor._

    <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)

    thread(<span class="stQuotedString">"producer"</span>) {
      buf put <span class="stLiteral">42</span>
      buf put <span class="stLiteral">17</span>
      beat should be (<span class="stLiteral">1</span>)
    }

    thread(<span class="stQuotedString">"consumer"</span>) {
      waitForBeat(<span class="stLiteral">1</span>)
      buf.take should be (<span class="stLiteral">42</span>)
      buf.take should be (<span class="stLiteral">17</span>)
    }

    whenFinished {
      buf should be (<span class="stQuotedString">'empty</span>)
    }
  }
}
</pre></p><p>When the test shown is run, it will create one thread named <em>producer</em> and another named
<em>consumer</em>. The producer thread will eventually execute the code passed as a by-name
parameter to <code>thread("producer")</code>:</p><p><pre class="stHighlighted">
buf put <span class="stLiteral">42</span>
buf put <span class="stLiteral">17</span>
beat should be (<span class="stLiteral">1</span>)
</pre></p><p>Similarly, the consumer thread will eventually execute the code passed as a by-name parameter
to <code>thread("consumer")</code>:</p><p><pre class="stHighlighted">
waitForBeat(<span class="stLiteral">1</span>)
buf.take should be (<span class="stLiteral">42</span>)
buf.take should be (<span class="stLiteral">17</span>)
</pre></p><p>The <code>thread</code> calls create the threads and starts them, but they will not immediately
execute the by-name parameter passed to them. They will first block, waiting for the <code>Conductor</code>
to give them a green light to proceed.</p><p>The next call in the test is <code>whenFinished</code>. This method will first call <code>conduct</code> on
the <code>Conductor</code>, which will wait until all threads that were created (in this case, producer and consumer) are
at the &quot;starting line&quot;, <em>i.e.</em>, they have all started and are blocked, waiting on the green light.
The <code>conduct</code> method will then give these threads the green light and they will
all start executing their blocks concurrently.</p><p>When the threads are given the green light, the beat is 0. The first thing the producer thread does is put 42 in
into the queue. As the queue is empty at this point, this succeeds. The producer thread next attempts to put a 17
into the queue, but because the queue has size 1, this can't succeed until the consumer thread has read the 42
from the queue. This hasn't happened yet, so producer blocks. Meanwhile, the consumer thread's first act is to
call <code>waitForBeat(1)</code>. Because the beat starts out at 0, this call will block the consumer thread.
As a result, once the producer thread has executed <code>buf put 17</code> and the consumer thread has executed
<code>waitForBeat(1)</code>, both threads will be blocked.</p><p>The <code>Conductor</code> maintains a clock that wakes up periodically and checks to see if all threads
participating in the multi-threaded scenario (in this case, producer and consumer) are blocked. If so, it
increments the beat. Thus sometime later the beat will be incremented, from 0 to 1. Because consumer was
waiting for beat 1, it will wake up (<em>i.e.</em>, the <code>waitForBeat(1)</code> call will return) and
execute the next line of code in its block, <code>buf.take should be (42)</code>. This will succeed, because
the producer thread had previously (during beat 0) put 42 into the queue. This act will also make
producer runnable again, because it was blocked on the second <code>put</code>, which was waiting for another
thread to read that 42.</p><p>Now both threads are unblocked and able to execute their next statement. The order is
non-deterministic, and can even be simultaneous if running on multiple cores. If the <code>consumer</code> thread
happens to execute <code>buf.take should be (17)</code> first, it will block (<code>buf.take</code> will not return), because the queue is
at that point empty. At some point later, the producer thread will execute <code>buf put 17</code>, which will
unblock the consumer thread. Again both threads will be runnable and the order non-deterministic and
possibly simulataneous. The producer thread may charge ahead and run its next statement, <code>beat should be (1)</code>.
This will succeed because the beat is indeed 1 at this point. As this is the last statement in the producer's block,
the producer thread will exit normally (it won't throw an exception). At some point later the consumer thread will
be allowed to complete its last statement, the <code>buf.take</code> call will return 17. The consumer thread will
execute <code>17 should be (17)</code>. This will succeed and as this was the last statement in its block, the consumer will return
normally.</p><p>If either the producer or consumer thread had completed abruptbly with an exception, the <code>conduct</code> method
(which was called by <code>whenFinished</code>) would have completed abruptly with an exception to indicate the test
failed. However, since both threads returned normally, <code>conduct</code> will return. Because <code>conduct</code> doesn't
throw an exception, <code>whenFinished</code> will execute the block of code passed as a by-name parameter to it: <code>buf should be ('empty)</code>.
This will succeed, because the queue is indeed empty at this point. The <code>whenFinished</code> method will then return, and
because the <code>whenFinished</code> call was the last statement in the test and it didn't throw an exception, the test completes successfully.</p><p>This test tests <code>ArrayBlockingQueue</code>, to make sure it works as expected. If there were a bug in <code>ArrayBlockingQueue</code>
such as a <code>put</code> called on a full queue didn't block, but instead overwrote the previous value, this test would detect
it. However, if there were a bug in <code>ArrayBlockingQueue</code> such that a call to <code>take</code> called on an empty queue
never blocked and always returned 0, this test might not detect it. The reason is that whether the consumer thread will ever call
<code>take</code> on an empty queue during this test is non-deterministic. It depends on how the threads get scheduled during beat 1.
What is deterministic in this test, because the consumer thread blocks during beat 0, is that the producer thread will definitely
attempt to write to a full queue. To make sure the other scenario is tested, you'd need a different test:</p><p><pre class="stHighlighted">
test(<span class="stQuotedString">"calling take on an empty queue blocks the consumer thread"</span>) {

  <span class="stReserved">val</span> conductor = <span class="stReserved">new</span> <span class="stType">Conductor</span>
  <span class="stReserved">import</span> conductor._

  <span class="stReserved">val</span> buf = <span class="stReserved">new</span> <span class="stType">ArrayBlockingQueue[Int]</span>(<span class="stLiteral">1</span>)

  thread(<span class="stQuotedString">"producer"</span>) {
    waitForBeat(<span class="stLiteral">1</span>)
    buf put <span class="stLiteral">42</span>
    buf put <span class="stLiteral">17</span>
  }

  thread(<span class="stQuotedString">"consumer"</span>) {
    buf.take should be (<span class="stLiteral">42</span>)
    buf.take should be (<span class="stLiteral">17</span>)
    beat should be (<span class="stLiteral">1</span>)
  }

  whenFinished {
    buf should be (<span class="stQuotedString">'empty</span>)
  }
}
</pre></p><p>In this test, the producer thread will block, waiting for beat 1. The consumer thread will invoke <code>buf.take</code>
as its first act. This will block, because the queue is empty. Because both threads are blocked, the <code>Conductor</code>
will at some point later increment the beat to 1. This will awaken the producer thread. It will return from its
<code>waitForBeat(1)</code> call and execute <code>buf put 42</code>. This will unblock the consumer thread, which will
take the 42, and so on.</p><p>The problem that <code>Conductor</code> is designed to address is the difficulty, caused by the non-deterministic nature
of thread scheduling, of testing classes, traits, and libraries that are intended to be used by multiple threads.
If you just create a test in which one thread reads from an <code>ArrayBlockingQueue</code> and
another writes to it, you can't be sure that you have tested all possible interleavings of threads, no matter
how many times you run the test. The purpose of <code>Conductor</code>
is to enable you to write tests with deterministic interleavings of threads. If you write one test for each possible
interleaving of threads, then you can be sure you have all the scenarios tested. The two tests shown here, for example,
ensure that both the scenario in which a producer thread tries to write to a full queue and the scenario in which a
consumer thread tries to take from an empty queue are tested.</p><p>Class <code>Conductor</code> was inspired by the
<a href="http://www.cs.umd.edu/projects/PL/multithreadedtc/">MultithreadedTC project</a>,
created by Bill Pugh and Nat Ayewah of the University of Maryland.</p><p>Although useful, bear in mind that a <code>Conductor</code>'s results are not guaranteed to be
accurate 100% of the time. The reason is that it uses <code>java.lang.Thread</code>'s <code>getState</code> method to
decide when to advance the beat. This use goes against the advice given in the Javadoc documentation for
<code>getState</code>, which says, &quot;This method is designed for use in monitoring of the system state, not for
synchronization.&quot; In short, sometimes the return value of <code>getState</code> occasionally may be inacurrate,
which in turn means that sometimes a <code>Conductor</code> could decide to advance the beat too early. In practice,
<code>Conductor</code> has proven to be very helpful when developing thread safe classes. It is also useful in
for regression tests, but you may have to tolerate occasional false negatives.</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/scalatest/scalatest/tree/release-3.0.1/scalatest//src/main/scala/org/scalatest/concurrent/Conductors.scala" target="_blank">Conductors.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="org.scalatest.concurrent.Conductors.Conductor"><span>Conductor</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="org.scalatest.concurrent.Conductors.Conductor#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;():Conductors.this.Conductor"></a><a id="&lt;init&gt;:Conductor"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#&lt;init&gt;():Conductors.this.Conductor" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Conductor</span><span class="params">()</span>
      </span>
      
      
    </li></ol>
            </div>

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#beat" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="beat:Int"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#beat:Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">beat</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <p class="shortcomment cmt">The current value of the thread clock.</p><div class="fullcomment"><div class="comment cmt"><p>The current value of the thread clock.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the current beat value</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#conduct" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conduct(interval:org.scalatest.concurrent.PatienceConfiguration.Interval)(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion"></a><a id="conduct(Interval)(Conductors.PatienceConfig,Position):Assertion"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#conduct(interval:org.scalatest.concurrent.PatienceConfiguration.Interval)(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conduct</span><span class="params">(<span name="interval">interval: <a href="PatienceConfiguration$$Interval.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration.Interval">Interval</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="config">config: <a href="Conductors.html#PatienceConfigextendsProductwithSerializable" class="extmbr" name="org.scalatest.concurrent.AbstractPatienceConfiguration.PatienceConfig">Conductors.PatienceConfig</a></span>, <span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</p><p>The maximum amount of time allowed between successive beats is configured by the <code>timeout</code> field of
the <code>PatienceConfig</code> passed implicitly as the last parameter.
The interval to sleep between successive checks for progress is configured by the value contained in the passed
<code>interval</code> parameter.</p></div><dl class="paramcmts block"><dt class="param">interval</dt><dd class="cmt"><p>the <code>Interval</code> configuration parameter</p></dd><dt class="param">config</dt><dd class="cmt"><p>the <code>PatienceConfig</code> object containing the (used) <code>timeout</code> and
         (unused) <code>interval</code> parameters</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#conduct" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conduct(timeout:org.scalatest.concurrent.PatienceConfiguration.Timeout)(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion"></a><a id="conduct(Timeout)(Conductors.PatienceConfig,Position):Assertion"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#conduct(timeout:org.scalatest.concurrent.PatienceConfiguration.Timeout)(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conduct</span><span class="params">(<span name="timeout">timeout: <a href="PatienceConfiguration$$Timeout.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration.Timeout">Timeout</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="config">config: <a href="Conductors.html#PatienceConfigextendsProductwithSerializable" class="extmbr" name="org.scalatest.concurrent.AbstractPatienceConfiguration.PatienceConfig">Conductors.PatienceConfig</a></span>, <span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</p><p>The maximum amount of time allowed between successive beats is configured by the value contained in the passed
<code>timeout</code> parameter.
The interval to sleep between successive checks for progress is configured by  by the <code>interval</code> field of
the <code>PatienceConfig</code> passed implicitly as the last parameter.</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the <code>Timeout</code> configuration parameter</p></dd><dt class="param">config</dt><dd class="cmt"><p>the <code>PatienceConfig</code> object containing the (unused) <code>timeout</code> and
         (used) <code>interval</code> parameters</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#conduct" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conduct(timeout:org.scalatest.concurrent.PatienceConfiguration.Timeout,interval:org.scalatest.concurrent.PatienceConfiguration.Interval)(implicitpos:org.scalactic.source.Position):org.scalatest.Assertion"></a><a id="conduct(Timeout,Interval)(Position):Assertion"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#conduct(timeout:org.scalatest.concurrent.PatienceConfiguration.Timeout,interval:org.scalatest.concurrent.PatienceConfiguration.Interval)(implicitpos:org.scalactic.source.Position):org.scalatest.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conduct</span><span class="params">(<span name="timeout">timeout: <a href="PatienceConfiguration$$Timeout.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration.Timeout">Timeout</a></span>, <span name="interval">interval: <a href="PatienceConfiguration$$Interval.html" class="extype" name="org.scalatest.concurrent.PatienceConfiguration.Interval">Interval</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</p><p>The maximum amount of time allowed between successive beats is configured by the value contained in the passed
<code>timeout</code> parameter.
The interval to sleep between successive checks for progress is configured by the value contained in the passed
<code>interval</code> parameter.</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the <code>Timeout</code> configuration parameter</p></dd><dt class="param">interval</dt><dd class="cmt"><p>the <code>Interval</code> configuration parameter</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#conduct" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conduct()(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion"></a><a id="conduct()(Conductors.PatienceConfig,Position):Assertion"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#conduct()(implicitconfig:Conductors.this.PatienceConfig,implicitpos:org.scalactic.source.Position):org.scalatest.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conduct</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="config">config: <a href="Conductors.html#PatienceConfigextendsProductwithSerializable" class="extmbr" name="org.scalatest.concurrent.AbstractPatienceConfiguration.PatienceConfig">Conductors.PatienceConfig</a></span>, <span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Conducts a multi-threaded test using the configured maximum allowed time between beats
(the <code>timeout</code>) and the configured time to sleep between checks (the <code>interval</code>).
</p></div><dl class="paramcmts block"><dt class="param">config</dt><dd class="cmt"><p>the <code>PatienceConfig</code> object containing the <code>timeout</code> and
         <code>interval</code> parameters used to configure the multi-threaded test</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#conductingHasBegun" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conductingHasBegun:Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#conductingHasBegun:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conductingHasBegun</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Indicates whether either of the two overloaded <code>conduct</code> methods
have been invoked.</code></p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether either of the two overloaded <code>conduct</code> methods
have been invoked.</p><p>This method returns true if either <code>conduct</code> method has been invoked. The
<code>conduct</code> method may have returned or not. (In other words, a <code>true</code>
result from this method does not mean the <code>conduct</code> method has returned,
just that it was already been invoked and,therefore, the multi-threaded scenario it
conducts has definitely begun.)</p></div></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#isConductorFrozen" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isConductorFrozen:Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#isConductorFrozen:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isConductorFrozen</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Indicates whether the conductor has been frozen.</p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether the conductor has been frozen.</p><p>Note: The only way a thread
can freeze the conductor is by calling <code>withConductorFrozen</code>.</p></div></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#thread" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="thread(fun:=&gt;Any):Thread"></a><a id="thread(⇒Any):Thread"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#thread(fun:=&gt;Any):Thread" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">thread</span><span class="params">(<span name="fun">fun: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="java.lang.Thread">Thread</span></span>
      </span>
      
      <p class="shortcomment cmt">Creates a new thread that will execute the specified function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new thread that will execute the specified function.</p><p>The name of the thread will be of the form Conductor-Thread-N, where N is some integer.</p><p>This method may be safely called by any thread.</p></div><dl class="paramcmts block"><dt class="param">fun</dt><dd class="cmt"><p>the function to be executed by the newly created thread</p></dd><dt>returns</dt><dd class="cmt"><p>the newly created thread</p></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#threadNamed" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="threadNamed(name:String)(fun:=&gt;Any)(implicitpos:org.scalactic.source.Position):Thread"></a><a id="threadNamed(String)(⇒Any)(Position):Thread"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#threadNamed(name:String)(fun:=&gt;Any)(implicitpos:org.scalactic.source.Position):Thread" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">threadNamed</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="fun">fun: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <span class="extype" name="java.lang.Thread">Thread</span></span>
      </span>
      
      <p class="shortcomment cmt">Creates a new thread with the specified name that will execute the specified function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new thread with the specified name that will execute the specified function.</p><p>This method may be safely called by any thread.</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>the name of the newly created thread</p></dd><dt class="param">fun</dt><dd class="cmt"><p>the function to be executed by the newly created thread</p></dd><dt>returns</dt><dd class="cmt"><p>the newly created thread</p></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#waitForBeat" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="waitForBeat(beat:Int)(implicitpos:org.scalactic.source.Position):org.scalatest.Succeeded.type"></a><a id="waitForBeat(Int)(Position):Succeeded.type"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#waitForBeat(beat:Int)(implicitpos:org.scalactic.source.Position):org.scalatest.Succeeded.type" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">waitForBeat</span><span class="params">(<span name="beat">beat: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../Succeeded$.html" class="extype" name="org.scalatest.Succeeded">Succeeded</a>.type</span>
      </span>
      
      <p class="shortcomment cmt">Blocks the current thread until the thread beat reaches the
specified value, at which point the current thread will be unblocked.</p><div class="fullcomment"><div class="comment cmt"><p>Blocks the current thread until the thread beat reaches the
specified value, at which point the current thread will be unblocked.
</p></div><dl class="paramcmts block"><dt class="param">beat</dt><dd class="cmt"><p>the tick value to wait for</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NotAllowedException"><code>NotAllowedException</code></span> if the a <code>beat</code> less than or equal to zero is passed</p></span></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#whenFinished" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="whenFinished(fun:=&gt;org.scalatest.Assertion)(implicitpos:org.scalactic.source.Position):org.scalatest.Assertion"></a><a id="whenFinished(⇒Assertion)(Position):Assertion"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#whenFinished(fun:=&gt;org.scalatest.Assertion)(implicitpos:org.scalactic.source.Position):org.scalatest.Assertion" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">whenFinished</span><span class="params">(<span name="fun">fun: ⇒ <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <a href="../index.html#Assertion=org.scalatest.compatible.Assertion" class="extmbr" name="org.scalatest.Assertion">Assertion</a></span>
      </span>
      
      <p class="shortcomment cmt">Invokes <code>conduct</code> and after <code>conduct</code> method returns,
if <code>conduct</code> returns normally (<em>i.e.</em>, without throwing
an exception), invokes the passed function.</em></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Invokes <code>conduct</code> and after <code>conduct</code> method returns,
if <code>conduct</code> returns normally (<em>i.e.</em>, without throwing
an exception), invokes the passed function.</p><p>If <code>conduct</code> completes abruptly with an exception, this method
will complete abruptly with the same exception and not execute the passed
function.</p><p>This method must be called by the thread that instantiated this <code>Conductor</code>,
and that same thread will invoke <code>conduct</code> and, if it returns noramlly, execute
the passed function.</p><p>Because <code>whenFinished</code> invokes <code>conduct</code>, it can only be invoked
once on a <code>Conductor</code> instance. As a result, if you need to pass a block of
code to <code>whenFinished</code> it should be the last statement of your test. If you
don't have a block of code that needs to be run once all the threads have finished
successfully, then you can simply invoke <code>conduct</code> and never invoke
<code>whenFinished</code>.</p></div><dl class="paramcmts block"><dt class="param">fun</dt><dd class="cmt"><p>the function to execute after <code>conduct</code> call returns</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NotAllowedException"><code>NotAllowedException</code></span> if the calling thread is not the thread that
  instantiated this <code>Conductor</code>, or if <code>conduct</code> has already
   been invoked on this conductor.</p></span></dd></dl></div>
    </li><li name="org.scalatest.concurrent.Conductors.Conductor#withConductorFrozen" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withConductorFrozen[T](fun:=&gt;T):T"></a><a id="withConductorFrozen[T](⇒T):T"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#withConductorFrozen[T](fun:=&gt;T):T" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withConductorFrozen</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="fun">fun: ⇒ <span class="extype" name="org.scalatest.concurrent.Conductors.Conductor.withConductorFrozen.T">T</span></span>)</span><span class="result">: <span class="extype" name="org.scalatest.concurrent.Conductors.Conductor.withConductorFrozen.T">T</span></span>
      </span>
      
      <p class="shortcomment cmt">Executes the passed function with the <code>Conductor</code> <em>frozen</em> so that it
won't advance the clock.</em></code></p><div class="fullcomment"><div class="comment cmt"><p>Executes the passed function with the <code>Conductor</code> <em>frozen</em> so that it
won't advance the clock.</p><p>While the <code>Conductor</code> is frozen, the beat will not advance. Once the
passed function has completed executing, the <code>Conductor</code> will be unfrozen
so that the beat will advance when all threads are blocked, as normal.</p></div><dl class="paramcmts block"><dt class="param">fun</dt><dd class="cmt"><p>the function to execute while the <code>Conductor</code> is frozen.</p></dd></dl></div>
    </li>
              </ol>
            </div>

        

        <div class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="org.scalatest.concurrent.Conductors.Conductor#thread" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="thread(name:String)(fun:=&gt;Any)(implicitpos:org.scalactic.source.Position):Thread"></a><a id="thread(String)(⇒Any)(Position):Thread"></a>
      <span class="permalink">
      <a href="../../../org/scalatest/concurrent/Conductors$Conductor.html#thread(name:String)(fun:=&gt;Any)(implicitpos:org.scalactic.source.Position):Thread" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: The overloaded thread method that takes a String name has been deprecated and will be removed in a future version of ScalaTest. Please use threadNamed instead.">thread</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="fun">fun: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <span class="extype" name="org.scalactic.source.Position">Position</span></span>)</span><span class="result">: <span class="extype" name="java.lang.Thread">Thread</span></span>
      </span>
      
      <p class="shortcomment cmt"><strong>The overloaded thread method that takes a String name has been deprecated and will be removed in a future version of ScalaTest. Please use threadNamed instead.</strong>
</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The overloaded thread method that takes a String name has been deprecated and will be removed in a future version of ScalaTest. Please use threadNamed instead.</strong>
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>The overloaded thread method that takes a String name has been deprecated and will be removed in a future version of ScalaTest. Please use threadNamed instead.</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
