@*
 * Copyright 2010-2017 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *@

@import controllers.Application.scaladocsPageUrl

@userGuidePage("Sharing fixtures") {
<div style="text-align: left">



<h1> Sharing fixtures </h1>

<p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.</p>

<p>ScalaTest recommends three techniques to eliminate such code duplication:</p><ul><li>Refactor using Scala</li><li>Override <code>withFixture</code></li><li>Mix in a <em>before-and-after</em> trait</li></ul>

<p>Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p>

<p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p>

<p><table style="border-collapse: collapse; border: 1px solid black"></p>

<p><tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Refactor using Scala when different tests need different fixtures.</strong>
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#getFixtureMethods">get-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    The <em>extract method</em> refactor helps you create a fresh instances of mutable fixture objects in each test
    that needs them, but doesn't help you clean them up when you're done.
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#fixtureContextObjects">fixture-context objects</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    By placing fixture methods and fields into traits, you can easily give each test just the newly created
    fixtures it needs by mixing together traits.  Use this technique when you need <em>different combinations
    of mutable fixture objects in different tests</em>, and don't need to clean up after.
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#loanFixtureMethods">loan-fixture methods</a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Factor out dupicate code with the <em>loan pattern</em> when different tests need different fixtures <em>that must be cleaned up afterwards</em>.
  </td>
</tr></p>

<p><tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Override <code>withFixture</code> when most or all tests need the same fixture.</strong>
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureNoArgTest">
      <code>withFixture(NoArgTest)</code></a>
    </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">



    The recommended default approach when most or all tests need the same fixture treatment. This general technique
    allows you, for example, to perform side effects at the beginning and end of all or most tests,
    transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
    Use this technique unless:



<ul>
<li>Different tests need different fixtures (refactor using Scala instead)</li>

<li>An exception in fixture code should abort the suite, not fail the test (use a <em>before-and-after</em> trait instead)</li>

<li>You have objects to pass into tests (override <code>withFixture(<em>One</em>ArgTest)</code> instead)</li>
</ul>

 </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#withFixtureOneArgTest">
      <code>withFixture(OneArgTest)</code>
    </a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to pass the same fixture object or objects as a parameter into all or most tests.
  </td>
</tr></p>

<p><tr>
  <td colspan="2" style="background-color: #CCCCCC; border-width: 1px; padding: 3px; padding-top: 7px; border: 1px solid black; text-align: left">
    <strong>Mix in a before-and-after trait when you want an aborted suite, not a failed test, if the fixture code fails.</strong>
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#beforeAndAfter"><code>BeforeAndAfter</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use this boilerplate-buster when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr></p>

<p><tr>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right">
    <a href="#composingFixtures"><code>BeforeAndAfterEach</code></a>
  </td>
  <td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">
    Use when you want to <em>stack traits</em> that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.
  </td>
</tr></p>

<p></table></p>

<p><a name="getFixtureMethods"> </a></p><h4> Calling get-fixture methods </h4>

<p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or a holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.getfixture
<br /><span class="stReserved">import</span> org.scalatest.flatspec.AnyFlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> {
<br />  <span class="stReserved">def</span> fixture =
    <span class="stReserved">new</span> {
      <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
      <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
    }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(f.buffer.isEmpty)
    f.buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(f.buffer.isEmpty)
  }
}
</pre></p>

<p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p>

<p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p>

<p><a name="fixtureContextObjects"> </a></p><h4> Instantiating fixture-context objects  </h4>

<p>An alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are only
appropriate if you don't need to clean up the fixtures after using them.</p>

<p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.fixturecontext
<br /><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.flatspec.AnyFlatSpec
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> {
<br />  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs the StringBuilder fixture</span>
  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be productive&quot;</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
    builder.append(<span class="stQuotedString">&quot;productive!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is productive!&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
  <span class="stQuotedString">&quot;Test code&quot;</span> should <span class="stQuotedString">&quot;be readable&quot;</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
    buffer += (<span class="stQuotedString">&quot;readable!&quot;</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;readable!&quot;</span>))
  }
<br />  <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
  it should <span class="stQuotedString">&quot;be clear and concise&quot;</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
    builder.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
    buffer += (<span class="stQuotedString">&quot;concise!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;concise!&quot;</span>))
  }
}
</pre></p>

<p><a name="withFixtureNoArgTest"> </a></p><h4> Overriding <code>withFixture(NoArgTest)</code> </h4>

<p>Although the get-fixture method and fixture-context object approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href='@scaladocsPageUrl("org.scalatest.Suite")'><code>Suite</code></a>.</p>

<p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p>

<p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  test()
}
</pre></p>

<p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, in case an exception propagates back through <code>withFixture</code>. (If a test fails because of an exception,
the test function invoked by withFixture will result in a <a href='@scaladocsPageUrl("org.scalatest.Failed")'><code>Failed</code></a> wrapping the exception. Nevertheless,
best practice is to perform cleanup in a finally clause just in case an exception occurs.)</p>

<p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. That is to say, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p>

<p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p>

<p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
send that information to the reporter:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.noargtest
<br /><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest._
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> {
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
<br />    <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
      <span class="stReserved">case</span> failed: <span class="stType">Failed</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">&quot;.&quot;</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">&quot;Dir snapshot: &quot;</span> + fileNames.mkString(<span class="stQuotedString">&quot;, &quot;</span>))
        failed
      <span class="stReserved">case</span> other =&gt; other
    }
  }
<br />  <span class="stQuotedString">&quot;This test&quot;</span> should <span class="stQuotedString">&quot;succeed&quot;</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
  }
<br />  it should <span class="stQuotedString">&quot;fail&quot;</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
  }
}
</pre></p>

<p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p>

<p><pre class="stREPL">
scala&gt; new ExampleSuite execute
<span class="stGreen">ExampleSuite:
This test
- should succeed
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (&lt;console&gt;:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p>

<p>Note that the <a href='@scaladocsPageUrl("org.scalatest.Suite$NoArgTest")'><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes <a href='@scaladocsPageUrl("org.scalatest.TestData")'><code>TestData</code></a> such as the test name and the <a href='@scaladocsPageUrl("org.scalatest.ConfigMap")'>config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p>

<p><a name="loanFixtureMethods"> </a></p><h4> Calling loan-fixture methods </h4>

<p>If you need to both pass a fixture object into a test <em>and</em> perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p>

<p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.loanfixture
<br /><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br /><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br /><span class="stReserved">import</span> org.scalatest.flatspec.AnyFlatSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> {
<br />  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">&quot;hello&quot;</span>, <span class="stQuotedString">&quot;world&quot;</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stLineComment">// This test needs the file fixture</span>
  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be productive&quot;</span> in withFile { (file, writer) =&gt;
    writer.write(<span class="stQuotedString">&quot;productive!&quot;</span>)
    writer.flush()
    assert(file.length === <span class="stLiteral">24</span>)
  }
<br />  <span class="stLineComment">// This test needs the database fixture</span>
  <span class="stQuotedString">&quot;Test code&quot;</span> should <span class="stQuotedString">&quot;be readable&quot;</span> in withDatabase { db =&gt;
    db.append(<span class="stQuotedString">&quot;readable!&quot;</span>)
    assert(db.toString === <span class="stQuotedString">&quot;ScalaTest is readable!&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs both the file and the database</span>
  it should <span class="stQuotedString">&quot;be clear and concise&quot;</span> in withDatabase { db =&gt;
    withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
      db.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
      writer.write(<span class="stQuotedString">&quot;concise!&quot;</span>)
      writer.flush()
      assert(db.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
      assert(file.length === <span class="stLiteral">21</span>)
    }
  }
}
</pre></p>

<p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwards.</p>

<p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p>

<p></pre>
<a name="withFixtureOneArgTest"></a></p><h4> Overriding <code>withFixture(OneArgTest)</code> </h4>

<p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.AnyFlatSpec</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.AnyFlatSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p>

<p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p>

<p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p>

<p>Here's a complete example:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.oneargtest
<br /><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.AnyFlatSpec</span> {
<br />  <span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">FixtureParam</span>(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
<br />  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) = {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">&quot;hello&quot;</span>, <span class="stQuotedString">&quot;world&quot;</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">val</span> theFixture = <span class="stType">FixtureParam</span>(file, writer)
<br />    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(theFixture)) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">&quot;easy!&quot;</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">&quot;fun!&quot;</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p>

<p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href='@scaladocsPageUrl("org.scalatest.flatspec.AnyFlatSpec")'>documentation for <code>fixture.AnyFlatSpec</code></a>.</p>

<p><a name="beforeAndAfter"> </a></p><h4> Mixing in <code>BeforeAndAfter</code> </h4>

<p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href='@scaladocsPageUrl("org.scalatest.BeforeAndAfter")'><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.beforeandafter
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  before {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  after {
    builder.clear()
    buffer.clear()
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p>

<p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<a href='@scaladocsPageUrl("org.scalatest.OneInstancePerTest")'><code>OneInstancePerTest</code></a>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p>

<p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures.html">composing fixtures by stacking traits</a>.</p>

<p><a name="composingFixtures"> </a></p><h4> Composing fixtures by stacking traits </h4>

<p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingwithfixture
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">SuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">SuiteMixin</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p>

<p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &ldquo;super&rdquo; to <code>Buffer</code>. If you wanted <code>Buffer</code> to be &ldquo;super&rdquo;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p>

<p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Suite</span> <span class="stReserved">extends</span> <span class="stType">Suite</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p>

<p>And if you only need one fixture you mix in only that trait:</p>

<p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Suite</span> <span class="stReserved">extends</span> <span class="stType">Suite</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p>

<p>Another way to create stackable fixture traits is by extending the <a href='@scaladocsPageUrl("org.scalatest.BeforeAndAfterEach")'><code>BeforeAndAfterEach</code></a>
and/or <a href='@scaladocsPageUrl("org.scalatest.BeforeAndAfterAll")'><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingbeforeandaftereach
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">AnyFlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p>

<p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p>

<p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered an aborted suite, which will result in a
<a href='@scaladocsPageUrl("org.scalatest.events.SuiteAborted")'><code>SuiteAborted</code></a> event.</p>

</div>
}


