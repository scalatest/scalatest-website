@*
 * Copyright 2010-2013 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *@

@import controllers.Application.latestScaladocFor192

@userGuidePage("Sharing fixtures") {
<div style="text-align: left">

<h1>Sharing fixtures</h1>

<p>A test <em>fixture</em> is composed of the objects and other artifacts (files, sockets, database
connections, <em>etc.</em>) tests use to do their work.
When multiple tests need to work with the same fixtures, it is important to try and avoid
duplicating the fixture code across those tests. The more code duplication you have in your
tests, the greater drag the tests will have on refactoring the actual production code.
ScalaTest recommends several techniques to eliminate such code duplication, and provides several
traits to help. Each technique is geared towards helping you reduce code duplication without introducing
instance <code>var</code>s, shared mutable objects, or other dependencies between tests. Eliminating shared
mutable state across tests will make your test code easier to reason about and more amenable for parallel
test execution.</p>

<p>The following sections
describe these techniques, including explaining the recommended usage
for each. But first, here's a table summarizing the options:</p><p><table style="border-collapse: collapse; border: 1px solid black">
<tr><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">Technique</th><th style="background-color: #CCCCCC; border-width: 1px; padding: 3px; text-align: center; border: 1px solid black">Recommended uses</th></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#getFixtureMethods">get-fixture methods</a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when you need the same mutable fixture objects in multiple tests, and don't need to clean up after.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#fixtureContextObjects">fixture-context objects</a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when you need different combinations of mutable fixture objects in different tests, and don't need to clean up after. </td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#oneInstancePerTest"><code>OneInstancePerTest</code></a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when porting JUnit tests to ScalaTest, or if you prefer JUnit's approach to test isolation: running each test in its own instance of the test class.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#withFixtureNoArgTest"><code>withFixture(NoArgTest)</code></a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when you need to perform side effects at the beginning and end of all or most tests, or want to stack traits that perform such side-effects.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#loanFixtureMethods">loan-fixture methods</a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when different tests need different fixtures that must be cleaned up afterwords.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#withFixtureOneArgTest"><code>withFixture(OneArgTest)</code></a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when all or most tests need the same fixtures that must be cleaned up afterwords.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#beforeAndAfter"><code>BeforeAndAfter</code></a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when you need to perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.</td></td></tr>
<tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: right"><a href="#composingFixtures"><code>BeforeAndAfterEach</code></a></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: left">Use when you want to stack traits that perform the same side-effects before and/or after tests, rather than at the beginning or end of tests.</td></td></tr>
</table></p>

<p>
Note: Although the techniques described on this page are shown with <code>FlatSpec</code> examples, the techniques can be used in exactly
the same way with any style trait. The Scaladoc for each style trait gives corresponding examples for the other style traits.
</p>

<p><a name="getFixtureMethods"> </a></p><h4> Calling get-fixture methods </h4>

<p>If you need to create the same mutable fixture objects in multiple tests, and don't need to clean them up after using them, the simplest approach is to write one or
more <em>get-fixture</em> methods. A get-fixture method returns a new instance of a needed fixture object (or an holder object containing
multiple fixture objects) each time it is called. You can call a get-fixture method at the beginning of each
test that needs the fixture, storing the returned object or objects in local variables. Here's an example:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.getfixture
<br /><span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">def</span> fixture =
    <span class="stReserved">new</span> {
      <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
      <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
    }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(f.buffer.isEmpty)
    f.buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(f.buffer.isEmpty)
  }
}
</pre></p>

<p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p>

<p>If you need to configure fixture objects differently in different tests, you can pass configuration into the get-fixture method. For example, if you could pass
in an initial value for a mutable fixture object as a parameter to the get-fixture method.</p>

<p><a name="fixtureContextObjects"> </a></p><h4> Instantiating fixture-context objects  </h4>

<p>A alternate technique that is especially useful when different tests need different combinations of fixture objects is to define the fixture objects as instance variables
of <em>fixture-context objects</em> whose instantiation forms the body of tests. Like get-fixture methods, fixture-context objects are anly
appropriate if you don't need to clean up the fixtures after using them.</p>

<p>To use this technique, you define instance variables intialized with fixture objects in traits and/or classes, then in each test instantiate an object that
contains just the fixture objects needed by the test. Keep in mind that traits allow you to mix together just the fixture objects needed by each test, whereas classes
allow you to pass data in via a constructor to configure the fixture objects. Here's an example in which fixture objects are partitioned into two traits
and each test just mixes together the traits it needs:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.fixturecontext
<br /><span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FlatSpec
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs the StringBuilder fixture</span>
  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be productive&quot;</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> {
    builder.append(<span class="stQuotedString">&quot;productive!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is productive!&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
  <span class="stQuotedString">&quot;Test code&quot;</span> should <span class="stQuotedString">&quot;be readable&quot;</span> in <span class="stReserved">new</span> <span class="stType">Buffer</span> {
    buffer += (<span class="stQuotedString">&quot;readable!&quot;</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;readable!&quot;</span>))
  }
<br />  <span class="stLineComment">// This test needs both the StringBuilder and ListBuffer</span>
  it should <span class="stQuotedString">&quot;be clear and concise&quot;</span> in <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
    builder.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
    buffer += (<span class="stQuotedString">&quot;concise!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
    assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;concise!&quot;</span>))
  }
}
</pre></p>

<p><a name="oneInstancePerTest"> </a></p><h4> Mixing in <code>OneInstancePerTest</code> </h4>

<p>If every test requires the same set of
mutable fixture objects, and none require cleanup, one other approach you can take is make them simply <code>val</code>s and mix in trait
<a href="@latestScaladocFor192/index.html#org.scalatest.OneInstancePerTest"><code>OneInstancePerTest</code></a>.  If you mix in <code>OneInstancePerTest</code>, each test
will be run in its own instance of the <code>Suite</code>, similar to the way JUnit tests are executed. Here's an example:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.oneinstancepertest
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSuite</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">OneInstancePerTest</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p>

<p>One way to think of <a href="@latestScaladocFor192/index.html#org.scalatest.OneInstancePerTest"><code>OneInstancePerTest</code></a> is that the entire <code>Suite</code> instance is like a fixture-context object,
but with the difference that the test code doesn't run during construction as it does with the real fixture-context object technique. Because this trait emulates JUnit's manner
of running tests, this trait can be helpful when porting JUnit tests to ScalaTest. The primary intended use of <code>OneInstancePerTest</code> is to serve as a supertrait for
<a href="@latestScaladocFor192/index.html#org.scalatest.ParallelTestExecution"><code>ParallelTestExecution</code></a> and the <a href="@latestScaladocFor192/index.html#org.scalatest.path.package">path traits</a>, but you can also mix it in
directly to help you port JUnit tests to ScalaTest or if you prefer JUnit's approach to test isolation.</p>

<p><a name="withFixtureNoArgTest"> </a></p><h4> Overriding <code>withFixture(NoArgTest)</code> </h4>

<p>Although the get-fixture method, fixture-context object, and <code>OneInstancePerTest</code> approaches take care of setting up a fixture at the beginning of each
test, they don't address the problem of cleaning up a fixture at the end of the test. If you just need to perform a side-effect at the beginning or end of
a test, and don't need to actually pass any fixture objects into the test, you can override <code>withFixture(NoArgTest)</code>, one of ScalaTest's
lifecycle methods defined in trait <a href="@latestScaladocFor192/index.html#org.scalatest.AbstractSuite"><code>AbstractSuite</code></a>.</p>

<p>Trait <code>Suite</code>'s implementation of <code>runTest</code> passes a no-arg test function to <code>withFixture(NoArgTest)</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function. <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p>

<p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation in trait Suite</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
  test()
}
</pre></p>

<p>You can, therefore, override <code>withFixture</code> to perform setup before and/or cleanup after invoking the test function. If
you have cleanup to perform, you should invoke the test function inside a <code>try</code> block and perform the cleanup in
a <code>finally</code> clause, because the exception that causes a test to fail will propagate through <code>withFixture</code> back
to <code>runTest</code>. (In other words, if the test fails, the test function invoked by <code>withFixture</code> will throw an exception.)</p>

<p>The <code>withFixture</code> method is designed to be stacked, and to enable this, you should always call the <code>super</code> implementation
of <code>withFixture</code>, and let it invoke the test function rather than invoking the test function directly. In other words, instead of writing
&ldquo;<code>test()</code>&rdquo;, you should write &ldquo;<code>super.withFixture(test)</code>&rdquo;, like this:</p>

<p><pre class="stHighlighted">
<span class="stLineComment">// Your implementation</span>
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
  <span class="stLineComment">// Perform setup</span>
  <span class="stReserved">try</span> {
    <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// Invoke the test function</span>
  }
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// Perform cleanup</span>
  }
}
</pre></p>

<p>Here's an example in which <code>withFixture(NoArgTest)</code> is used to take a snapshot of the working directory if a test fails, and
and send that information to the reporter:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.noargtest
<br /><span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> org.scalatest.FlatSpec
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
<br />    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test)
    <span class="stReserved">catch</span> {
      <span class="stReserved">case</span> e: <span class="stType">Exception</span> =&gt;
        <span class="stReserved">val</span> currDir = <span class="stReserved">new</span> <span class="stType">File</span>(<span class="stQuotedString">&quot;.&quot;</span>)
        <span class="stReserved">val</span> fileNames = currDir.list()
        info(<span class="stQuotedString">&quot;Dir snapshot: &quot;</span> + fileNames.mkString(<span class="stQuotedString">&quot;, &quot;</span>))
        <span class="stReserved">throw</span> e
    }
  }
<br />  <span class="stQuotedString">&quot;This test&quot;</span> should <span class="stQuotedString">&quot;succeed&quot;</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">2</span>)
  }
<br />  it should <span class="stQuotedString">&quot;fail&quot;</span> in {
    assert(<span class="stLiteral">1</span> + <span class="stLiteral">1</span> === <span class="stLiteral">3</span>)
  }
}
</pre></p>

<p>Running this version of <code>ExampleSuite</code> in the interpreter in a directory with two files, <code>hello.txt</code> and <code>world.txt</code>
would give the following output:</p>

<p><pre class="stREPL">
scala&gt; new ExampleSuite execute
<span class="stGreen">ExampleSuite:
This test
- should succeed
<span class="stRed">- should fail *** FAILED ***
  2 did not equal 3 (&lt;console&gt;:33)
  + Dir snapshot: hello.txt, world.txt </span>
</pre></p>

<p>Note that the <a href="@latestScaladocFor192/index.html#org.scalatest.Suite$NoArgTest"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name and the <a href="#configMapSection">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in your <code>withFixture</code>
implementation.</p>

<p><a name="loanFixtureMethods"> </a></p><h4> Calling loan-fixture methods </h4>

<p>If you need to both pass a fixture object into a test <em>and</em> and perform cleanup at the end of the test, you'll need to use the <em>loan pattern</em>.
If different tests need different fixtures that require cleanup, you can implement the loan pattern directly by writing <em>loan-fixture</em> methods.
A loan-fixture method takes a function whose body forms part or all of a test's code. It creates a fixture, passes it to the test code by invoking the
function, then cleans up the fixture after the function returns.</p>

<p>The following example shows three tests that use two fixtures, a database and a file. Both require cleanup after, so each is provided via a
loan-fixture method. (In this example, the database is simulated with a <code>StringBuffer</code>.)</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.loanfixture
<br /><span class="stReserved">import</span> java.util.concurrent.ConcurrentHashMap
<br /><span class="stReserved">object</span> <span class="stType">DbServer</span> { <span class="stLineComment">// Simulating a database server</span>
  <span class="stReserved">type</span> <span class="stType">Db</span> = <span class="stType">StringBuffer</span>
  <span class="stReserved">private</span> <span class="stReserved">val</span> databases = <span class="stReserved">new</span> <span class="stType">ConcurrentHashMap[String, Db]</span>
  <span class="stReserved">def</span> createDb(name: <span class="stType">String</span>): <span class="stType">Db</span> = {
    <span class="stReserved">val</span> db = <span class="stReserved">new</span> <span class="stType">StringBuffer</span>
    databases.put(name, db)
    db
  }
  <span class="stReserved">def</span> removeDb(name: <span class="stType">String</span>) {
    databases.remove(name)
  }
}
<br /><span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> DbServer._
<span class="stReserved">import</span> java.util.UUID.randomUUID
<span class="stReserved">import</span> java.io._
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">def</span> withDatabase(testCode: <span class="stType">Db</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> dbName = randomUUID.toString
    <span class="stReserved">val</span> db = createDb(dbName) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">try</span> {
      db.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// perform setup</span>
      testCode(db) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> removeDb(dbName) <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stReserved">def</span> withFile(testCode: (<span class="stType">File</span>, <span class="stType">FileWriter</span>) =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">&quot;hello&quot;</span>, <span class="stQuotedString">&quot;world&quot;</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// set up the fixture</span>
      testCode(file, writer) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stLineComment">// This test needs the file fixture</span>
  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be productive&quot;</span> in withFile { (file, writer) =&gt;
    writer.write(<span class="stQuotedString">&quot;productive!&quot;</span>)
    writer.flush()
    assert(file.length === <span class="stLiteral">24</span>)
  }
<br />  <span class="stLineComment">// This test needs the database fixture</span>
  <span class="stQuotedString">&quot;Test code&quot;</span> should <span class="stQuotedString">&quot;be readable&quot;</span> in withDatabase { db =&gt;
    db.append(<span class="stQuotedString">&quot;readable!&quot;</span>)
    assert(db.toString === <span class="stQuotedString">&quot;ScalaTest is readable!&quot;</span>)
  }
<br />  <span class="stLineComment">// This test needs both the file and the database</span>
  it should <span class="stQuotedString">&quot;be clear and concise&quot;</span> in withDatabase { db =&gt;
    withFile { (file, writer) =&gt; <span class="stLineComment">// loan-fixture methods compose</span>
      db.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
      writer.write(<span class="stQuotedString">&quot;concise!&quot;</span>)
      writer.flush()
      assert(db.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
      assert(file.length === <span class="stLiteral">21</span>)
    }
  }
}
</pre></p>

<p>As demonstrated by the last test, loan-fixture methods compose. Not only do loan-fixture methods allow you to
give each test the fixture it needs, they allow you to give a test multiple fixtures and clean everything up afterwords.</p>

<p>Also demonstrated in this example is the technique of giving each test its own &quot;fixture sandbox&quot; to play in. When your fixtures
involve external side-effects, like creating files or databases, it is a good idea to give each file or database a unique name as is
done in this example. This keeps tests completely isolated, allowing you to run them in parallel if desired.</p>

<p></pre>
<a name="withFixtureOneArgTest"></a></p><h4> Overriding <code>withFixture(OneArgTest)</code> </h4>

<p>If all or most tests need the same fixture, you can avoid some of the boilerplate of the loan-fixture method approach by using a <code>fixture.Suite</code>
and overriding <code>withFixture(OneArgTest)</code>.
Each test in a <code>fixture.Suite</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function.</p>

<p>To enable the stacking of traits that define <code>withFixture(NoArgTest)</code>, it is a good idea to let
<code>withFixture(NoArgTest)</code> invoke the test function instead of invoking the test
function directly. To do so, you'll need to convert the <code>OneArgTest</code> to a <code>NoArgTest</code>. You can do that by passing
the fixture object to the <code>toNoArgTest</code> method of <code>OneArgTest</code>. In other words, instead of
writing &ldquo;<code>test(theFixture)</code>&rdquo;, you'd delegate responsibility for
invoking the test function to the <code>withFixture(NoArgTest)</code> method of the same instance by writing:</p>

<p><pre>
withFixture(test.toNoArgTest(theFixture))
</pre></p>

<p>Here's a complete example:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.oneargtest
<br /><span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io._
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> {
<br />  <span class="stReserved">case</span> <span class="stReserved">class</span> F(file: <span class="stType">File</span>, writer: <span class="stType">FileWriter</span>)
  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = F
<br />  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) {
    <span class="stReserved">val</span> file = File.createTempFile(<span class="stQuotedString">&quot;hello&quot;</span>, <span class="stQuotedString">&quot;world&quot;</span>) <span class="stLineComment">// create the fixture</span>
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(file)
    <span class="stReserved">try</span> {
      writer.write(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// set up the fixture</span>
      withFixture(test.toNoArgTest(F(file, writer))) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> writer.close() <span class="stLineComment">// clean up the fixture</span>
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">&quot;easy!&quot;</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">18</span>)
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in { f =&gt;
    f.writer.write(<span class="stQuotedString">&quot;fun!&quot;</span>)
    f.writer.flush()
    assert(f.file.length === <span class="stLiteral">17</span>)
  }
}
</pre></p>

<p>In this example, the tests actually required two fixture objects, a <code>File</code> and a <code>FileWriter</code>. In such situations you can
simply define the <code>FixtureParam</code> type to be a tuple containing the objects, or as is done in this example, a case class containing
the objects.  For more information on the <code>withFixture(OneArgTest)</code> technique, see the <a href="@latestScaladocFor192/index.html#org.scalatest.fixture.Suite">documentation for <code>fixture.Suite</code></a>.</p>

<p><a name="beforeAndAfter"> </a></p><h4> Mixing in <code>BeforeAndAfter</code> </h4>

<p>In all the shared fixture examples shown so far, the activities of creating, setting up, and cleaning up the fixture objects have been
performed <em>during</em> the test.  This means that if an exception occurs during any of these activities, it will be reported as a test failure.
Sometimes, however, you may want setup to happen <em>before</em> the test starts, and cleanup <em>after</em> the test has completed, so that if an
exception occurs during setup or cleanup, the entire suite aborts and no more tests are attempted. The simplest way to accomplish this in ScalaTest is
to mix in trait <a href="@latestScaladocFor192/index.html#org.scalatest.BeforeAndAfter"><code>BeforeAndAfter</code></a>.  With this trait you can denote a bit of code to run before each test
with <code>before</code> and/or after each test each test with <code>after</code>, like this:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.beforeandafter
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  before {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  after {
    builder.clear()
    buffer.clear()
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p>

<p>Note that the only way <code>before</code> and <code>after</code> code can communicate with test code is via some side-effecting mechanism, commonly by
reassigning instance <code>var</code>s or by changing the state of mutable objects held from instance <code>val</code>s (as in this example). If using
instance <code>var</code>s or mutable objects held from instance <code>val</code>s you wouldn't be able to run tests in parallel in the same instance
of the test class unless you synchronized access to the shared, mutable state. This is why ScalaTest's <code>ParallelTestExecution</code> trait extends
<code>OneInstancePerTest</code>. By running each test in its own instance of the class, each test has its own copy of the instance variables, so you
don't need to synchronize. If you mixed <code>ParallelTestExecution</code> into the <code>ExampleSuite</code> above, the tests would run in parallel just fine
without any synchronization needed on the mutable <code>StringBuilder</code> and <code>ListBuffer[String]</code> objects.</p>

<p>Although <code>BeforeAndAfter</code> provides a minimal-boilerplate way to execute code before and after tests, it isn't designed to enable stackable
traits, because the order of execution would be non-obvious.  If you want to factor out before and after code that is common to multiple test suites, you
should use trait <code>BeforeAndAfterEach</code> instead, as shown later in the next section,
<a href="#composingFixtures">composing fixtures by stacking traits</a>.</p>

<p><a name="composingFixtures"> </a></p><h4> Composing fixtures by stacking traits </h4>

<p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingwithfixture
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AbstractSuite</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AbstractSuite</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p>

<p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSuite</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &quot;super&quot; to </code>Buffer</code>. If you wanted <code>Buffer</code> to be &quot;super&quot;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p>

<p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Suite</span> <span class="stReserved">extends</span> <span class="stType">Suite</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p>

<p>And if you only need one fixture you mix in only that trait:</p>

<p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Suite</span> <span class="stReserved">extends</span> <span class="stType">Suite</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p>

<p>Another way to create stackable fixture traits is by extending the <a href="@latestScaladocFor192/index.html#org.scalatest.BeforeAndAfterEach"><code>BeforeAndAfterEach</code></a>
and/or <a href="@latestScaladocFor192/index.html#org.scalatest.BeforeAndAfterAll"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p>

<p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalatest.examples.flatspec.composingbeforeandaftereach
<br /><span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> builder.clear()
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    <span class="stReserved">finally</span> buffer.clear()
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p>

<p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterEach</code> throws an exception.</p>

<p>The difference between stacking traits that extend <code>BeforeAndAfterEach</code> versus traits that implement <code>withFixture</code> is
that setup and cleanup code happens before and after the test in <code>BeforeAndAfterEach</code>, but at the beginning and
end of the test in <code>withFixture</code>. Thus if a <code>withFixture</code> method completes abruptly with an exception, it is
considered a failed test. By contrast, if any of the <code>beforeEach</code> or <code>afterEach</code> methods of <code>BeforeAndAfterEach</code>
complete abruptly, it is considered a failed suite, which will result in a <a href="@latestScaladocFor192/index.html#org.scalatest.events.SuiteAborted"><code>SuiteAborted</code></a> event.</p>

<p>
Next, learn about <a href="@routes.UserGuide192.sharingTests.url">sharing tests</a>.
</p>
</div>
}
